   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  24               	prvAddCurrentTaskToDelayedList:
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.3.1
   3:FreeRTOS/Source/tasks.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/tasks.c ****  *
   5:FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/tasks.c ****  *
  12:FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/tasks.c ****  *
  15:FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/tasks.c ****  *
  22:FreeRTOS/Source/tasks.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/tasks.c ****  *
  25:FreeRTOS/Source/tasks.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/tasks.c ****  */
  27:FreeRTOS/Source/tasks.c **** 
  28:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  29:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  30:FreeRTOS/Source/tasks.c **** #include <string.h>
  31:FreeRTOS/Source/tasks.c **** 
  32:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  35:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:FreeRTOS/Source/tasks.c **** 
  37:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  38:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  39:FreeRTOS/Source/tasks.c **** #include "task.h"
  40:FreeRTOS/Source/tasks.c **** #include "timers.h"
  41:FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  42:FreeRTOS/Source/tasks.c **** 
  43:FreeRTOS/Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:FreeRTOS/Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:FreeRTOS/Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:FreeRTOS/Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:FreeRTOS/Source/tasks.c **** 
  49:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  51:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  57:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:FreeRTOS/Source/tasks.c **** #else
  64:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:FreeRTOS/Source/tasks.c **** #endif
  66:FreeRTOS/Source/tasks.c **** 
  67:FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:FreeRTOS/Source/tasks.c **** 
  72:FreeRTOS/Source/tasks.c **** /*
  73:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:FreeRTOS/Source/tasks.c ****  */
  76:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:FreeRTOS/Source/tasks.c **** 
  78:FreeRTOS/Source/tasks.c **** /* Bits used to recored how a task's stack and TCB were allocated. */
  79:FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  80:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  81:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  82:FreeRTOS/Source/tasks.c **** 
  83:FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
  84:FreeRTOS/Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
  85:FreeRTOS/Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
  86:FreeRTOS/Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
  87:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
  88:FreeRTOS/Source/tasks.c **** #else
  89:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
  90:FreeRTOS/Source/tasks.c **** #endif
  91:FreeRTOS/Source/tasks.c **** 
  92:FreeRTOS/Source/tasks.c **** /*
  93:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
  94:FreeRTOS/Source/tasks.c ****  */
  95:FreeRTOS/Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
  96:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
  97:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
  98:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
  99:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 100:FreeRTOS/Source/tasks.c **** 
 101:FreeRTOS/Source/tasks.c **** /*
 102:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 103:FreeRTOS/Source/tasks.c ****  * global, rather than file scope.
 104:FreeRTOS/Source/tasks.c ****  */
 105:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 106:FreeRTOS/Source/tasks.c **** 	#define static
 107:FreeRTOS/Source/tasks.c **** #endif
 108:FreeRTOS/Source/tasks.c **** 
 109:FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 110:FreeRTOS/Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 111:FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 112:FreeRTOS/Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 113:FreeRTOS/Source/tasks.c **** #endif
 114:FreeRTOS/Source/tasks.c **** 
 115:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 116:FreeRTOS/Source/tasks.c **** 
 117:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 118:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 119:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 122:FreeRTOS/Source/tasks.c **** 	state task. */
 123:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 124:FreeRTOS/Source/tasks.c **** 	{																									\
 125:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 126:FreeRTOS/Source/tasks.c **** 		{																								\
 127:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 128:FreeRTOS/Source/tasks.c **** 		}																								\
 129:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 130:FreeRTOS/Source/tasks.c **** 
 131:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 132:FreeRTOS/Source/tasks.c **** 
 133:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 134:FreeRTOS/Source/tasks.c **** 	{																									\
 135:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 136:FreeRTOS/Source/tasks.c **** 																										\
 137:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 138:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 139:FreeRTOS/Source/tasks.c **** 		{																								\
 140:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 141:FreeRTOS/Source/tasks.c **** 			--uxTopPriority;																			\
 142:FreeRTOS/Source/tasks.c **** 		}																								\
 143:FreeRTOS/Source/tasks.c **** 																										\
 144:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 145:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 146:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 147:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 148:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 151:FreeRTOS/Source/tasks.c **** 
 152:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 153:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 154:FreeRTOS/Source/tasks.c **** 	being used. */
 155:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 156:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 157:FreeRTOS/Source/tasks.c **** 
 158:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 159:FreeRTOS/Source/tasks.c **** 
 160:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 161:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 162:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 163:FreeRTOS/Source/tasks.c **** 
 164:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 165:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:FreeRTOS/Source/tasks.c **** 
 169:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 170:FreeRTOS/Source/tasks.c **** 	{																								\
 171:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 172:FreeRTOS/Source/tasks.c **** 																									\
 173:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 174:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 175:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 176:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 177:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 178:FreeRTOS/Source/tasks.c **** 
 179:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 182:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 183:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 184:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 185:FreeRTOS/Source/tasks.c **** 	{																									\
 186:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 187:FreeRTOS/Source/tasks.c **** 		{																								\
 188:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 189:FreeRTOS/Source/tasks.c **** 		}																								\
 190:FreeRTOS/Source/tasks.c **** 	}
 191:FreeRTOS/Source/tasks.c **** 
 192:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 193:FreeRTOS/Source/tasks.c **** 
 194:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 195:FreeRTOS/Source/tasks.c **** 
 196:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 197:FreeRTOS/Source/tasks.c **** count overflows. */
 198:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 199:FreeRTOS/Source/tasks.c **** {																									\
 200:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 201:FreeRTOS/Source/tasks.c **** 																									\
 202:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 203:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 204:FreeRTOS/Source/tasks.c **** 																									\
 205:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 206:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 207:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 208:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 209:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 210:FreeRTOS/Source/tasks.c **** }
 211:FreeRTOS/Source/tasks.c **** 
 212:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:FreeRTOS/Source/tasks.c **** 
 214:FreeRTOS/Source/tasks.c **** /*
 215:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 216:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 217:FreeRTOS/Source/tasks.c ****  */
 218:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 219:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 220:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 221:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 222:FreeRTOS/Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 223:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 224:FreeRTOS/Source/tasks.c **** 
 225:FreeRTOS/Source/tasks.c **** /*
 226:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 227:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 228:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 229:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 230:FreeRTOS/Source/tasks.c ****  */
 231:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 232:FreeRTOS/Source/tasks.c **** 
 233:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 234:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 235:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 236:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 237:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 238:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 239:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 240:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 241:FreeRTOS/Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 242:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 243:FreeRTOS/Source/tasks.c **** #else
 244:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 245:FreeRTOS/Source/tasks.c **** #endif
 246:FreeRTOS/Source/tasks.c **** 
 247:FreeRTOS/Source/tasks.c **** /*
 248:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 249:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 250:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 251:FreeRTOS/Source/tasks.c ****  */
 252:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock 			/* The old naming convention is used to prevent breaking kern
 253:FreeRTOS/Source/tasks.c **** {
 254:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 255:FreeRTOS/Source/tasks.c **** 
 256:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 257:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 258:FreeRTOS/Source/tasks.c **** 	#endif
 259:FreeRTOS/Source/tasks.c **** 
 260:FreeRTOS/Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 261:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 262:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 263:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 264:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 265:FreeRTOS/Source/tasks.c **** 
 266:FreeRTOS/Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 267:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 268:FreeRTOS/Source/tasks.c **** 	#endif
 269:FreeRTOS/Source/tasks.c **** 
 270:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 271:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 272:FreeRTOS/Source/tasks.c **** 	#endif
 273:FreeRTOS/Source/tasks.c **** 
 274:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 275:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 276:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 277:FreeRTOS/Source/tasks.c **** 	#endif
 278:FreeRTOS/Source/tasks.c **** 
 279:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 280:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 281:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 282:FreeRTOS/Source/tasks.c **** 	#endif
 283:FreeRTOS/Source/tasks.c **** 
 284:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 285:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 286:FreeRTOS/Source/tasks.c **** 	#endif
 287:FreeRTOS/Source/tasks.c **** 
 288:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 289:FreeRTOS/Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 290:FreeRTOS/Source/tasks.c **** 	#endif
 291:FreeRTOS/Source/tasks.c **** 
 292:FreeRTOS/Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 293:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 294:FreeRTOS/Source/tasks.c **** 	#endif
 295:FreeRTOS/Source/tasks.c **** 
 296:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 297:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 298:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 299:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 300:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 301:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 302:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 303:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks.
 304:FreeRTOS/Source/tasks.c **** 
 305:FreeRTOS/Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 306:FreeRTOS/Source/tasks.c **** 		for additional information. */
 307:FreeRTOS/Source/tasks.c **** 		struct	_reent xNewLib_reent;
 308:FreeRTOS/Source/tasks.c **** 	#endif
 309:FreeRTOS/Source/tasks.c **** 
 310:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 311:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 312:FreeRTOS/Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 313:FreeRTOS/Source/tasks.c **** 	#endif
 314:FreeRTOS/Source/tasks.c **** 
 315:FreeRTOS/Source/tasks.c **** 	/* See the comments in FreeRTOS.h with the definition of
 316:FreeRTOS/Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 317:FreeRTOS/Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 318:FreeRTOS/Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 319:FreeRTOS/Source/tasks.c **** 	#endif
 320:FreeRTOS/Source/tasks.c **** 
 321:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 322:FreeRTOS/Source/tasks.c **** 		uint8_t ucDelayAborted;
 323:FreeRTOS/Source/tasks.c **** 	#endif
 324:FreeRTOS/Source/tasks.c **** 
 325:FreeRTOS/Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 326:FreeRTOS/Source/tasks.c **** 		int iTaskErrno;
 327:FreeRTOS/Source/tasks.c **** 	#endif
 328:FreeRTOS/Source/tasks.c **** 
 329:FreeRTOS/Source/tasks.c **** } tskTCB;
 330:FreeRTOS/Source/tasks.c **** 
 331:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 332:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 333:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 336:FreeRTOS/Source/tasks.c **** which static variables must be declared volatile. */
 337:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 338:FreeRTOS/Source/tasks.c **** 
 339:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 340:FreeRTOS/Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 341:FreeRTOS/Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 342:FreeRTOS/Source/tasks.c **** the static qualifier. */
 343:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 344:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 345:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 346:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 347:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 348:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 349:FreeRTOS/Source/tasks.c **** 
 350:FreeRTOS/Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 351:FreeRTOS/Source/tasks.c **** 
 352:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 353:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 354:FreeRTOS/Source/tasks.c **** 
 355:FreeRTOS/Source/tasks.c **** #endif
 356:FreeRTOS/Source/tasks.c **** 
 357:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 358:FreeRTOS/Source/tasks.c **** 
 359:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 360:FreeRTOS/Source/tasks.c **** 
 361:FreeRTOS/Source/tasks.c **** #endif
 362:FreeRTOS/Source/tasks.c **** 
 363:FreeRTOS/Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 364:FreeRTOS/Source/tasks.c **** the errno of the currently running task. */
 365:FreeRTOS/Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 366:FreeRTOS/Source/tasks.c **** 	int FreeRTOS_errno = 0;
 367:FreeRTOS/Source/tasks.c **** #endif
 368:FreeRTOS/Source/tasks.c **** 
 369:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 370:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 371:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 372:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 373:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 374:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xPendedTicks 			= ( TickType_t ) 0U;
 375:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 376:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 377:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 378:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 379:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 380:FreeRTOS/Source/tasks.c **** 
 381:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 382:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 383:FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 384:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 385:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 386:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 387:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 388:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 389:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 390:FreeRTOS/Source/tasks.c **** 
 391:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 392:FreeRTOS/Source/tasks.c **** 
 393:FreeRTOS/Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 394:FreeRTOS/Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 395:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 396:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 397:FreeRTOS/Source/tasks.c **** 
 398:FreeRTOS/Source/tasks.c **** #endif
 399:FreeRTOS/Source/tasks.c **** 
 400:FreeRTOS/Source/tasks.c **** /*lint -restore */
 401:FreeRTOS/Source/tasks.c **** 
 402:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 403:FreeRTOS/Source/tasks.c **** 
 404:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 405:FreeRTOS/Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 406:FreeRTOS/Source/tasks.c **** 
 407:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 408:FreeRTOS/Source/tasks.c **** 
 409:FreeRTOS/Source/tasks.c **** #endif
 410:FreeRTOS/Source/tasks.c **** 
 411:FreeRTOS/Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 414:FreeRTOS/Source/tasks.c **** 
 415:FreeRTOS/Source/tasks.c **** #endif
 416:FreeRTOS/Source/tasks.c **** 
 417:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 418:FreeRTOS/Source/tasks.c **** 
 419:FreeRTOS/Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 420:FreeRTOS/Source/tasks.c **** 
 421:FreeRTOS/Source/tasks.c **** #endif
 422:FreeRTOS/Source/tasks.c **** 
 423:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** /**
 426:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 427:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 428:FreeRTOS/Source/tasks.c ****  * is in any other state.
 429:FreeRTOS/Source/tasks.c ****  */
 430:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 431:FreeRTOS/Source/tasks.c **** 
 432:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 433:FreeRTOS/Source/tasks.c **** 
 434:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 435:FreeRTOS/Source/tasks.c **** 
 436:FreeRTOS/Source/tasks.c **** /*
 437:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 438:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 439:FreeRTOS/Source/tasks.c ****  */
 440:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 441:FreeRTOS/Source/tasks.c **** 
 442:FreeRTOS/Source/tasks.c **** /*
 443:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 444:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 445:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 446:FreeRTOS/Source/tasks.c ****  *
 447:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 448:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 449:FreeRTOS/Source/tasks.c ****  *
 450:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 451:FreeRTOS/Source/tasks.c ****  *
 452:FreeRTOS/Source/tasks.c ****  */
 453:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 454:FreeRTOS/Source/tasks.c **** 
 455:FreeRTOS/Source/tasks.c **** /*
 456:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 457:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 458:FreeRTOS/Source/tasks.c ****  *
 459:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 460:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 461:FreeRTOS/Source/tasks.c ****  */
 462:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 463:FreeRTOS/Source/tasks.c **** 
 464:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 465:FreeRTOS/Source/tasks.c **** 
 466:FreeRTOS/Source/tasks.c **** #endif
 467:FreeRTOS/Source/tasks.c **** 
 468:FreeRTOS/Source/tasks.c **** /*
 469:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 470:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 471:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 472:FreeRTOS/Source/tasks.c ****  */
 473:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 474:FreeRTOS/Source/tasks.c **** 
 475:FreeRTOS/Source/tasks.c **** /*
 476:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 477:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 478:FreeRTOS/Source/tasks.c ****  */
 479:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 480:FreeRTOS/Source/tasks.c **** 
 481:FreeRTOS/Source/tasks.c **** /*
 482:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 483:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 484:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 485:FreeRTOS/Source/tasks.c ****  *
 486:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 487:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 488:FreeRTOS/Source/tasks.c ****  */
 489:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 490:FreeRTOS/Source/tasks.c **** 
 491:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 492:FreeRTOS/Source/tasks.c **** 
 493:FreeRTOS/Source/tasks.c **** #endif
 494:FreeRTOS/Source/tasks.c **** 
 495:FreeRTOS/Source/tasks.c **** /*
 496:FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 497:FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 498:FreeRTOS/Source/tasks.c ****  */
 499:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 500:FreeRTOS/Source/tasks.c **** 
 501:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 502:FreeRTOS/Source/tasks.c **** 
 503:FreeRTOS/Source/tasks.c **** #endif
 504:FreeRTOS/Source/tasks.c **** 
 505:FreeRTOS/Source/tasks.c **** /*
 506:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 507:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 508:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 509:FreeRTOS/Source/tasks.c ****  */
 510:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
 511:FreeRTOS/Source/tasks.c **** 
 512:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 513:FreeRTOS/Source/tasks.c **** 
 514:FreeRTOS/Source/tasks.c **** #endif
 515:FreeRTOS/Source/tasks.c **** 
 516:FreeRTOS/Source/tasks.c **** /*
 517:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 518:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 519:FreeRTOS/Source/tasks.c ****  *
 520:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 521:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 522:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 523:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 524:FreeRTOS/Source/tasks.c ****  */
 525:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 526:FreeRTOS/Source/tasks.c **** 
 527:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 528:FreeRTOS/Source/tasks.c **** 
 529:FreeRTOS/Source/tasks.c **** #endif
 530:FreeRTOS/Source/tasks.c **** 
 531:FreeRTOS/Source/tasks.c **** /*
 532:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 533:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 534:FreeRTOS/Source/tasks.c ****  */
 535:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 536:FreeRTOS/Source/tasks.c **** 
 537:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 538:FreeRTOS/Source/tasks.c **** 
 539:FreeRTOS/Source/tasks.c **** 	/*
 540:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 541:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 542:FreeRTOS/Source/tasks.c **** 	 */
 543:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 544:FreeRTOS/Source/tasks.c **** 
 545:FreeRTOS/Source/tasks.c **** #endif
 546:FreeRTOS/Source/tasks.c **** 
 547:FreeRTOS/Source/tasks.c **** /*
 548:FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 549:FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 550:FreeRTOS/Source/tasks.c ****  */
 551:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 552:FreeRTOS/Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 553:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 554:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 555:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 556:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 557:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 558:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 559:FreeRTOS/Source/tasks.c **** 
 560:FreeRTOS/Source/tasks.c **** /*
 561:FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 562:FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 563:FreeRTOS/Source/tasks.c ****  */
 564:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 565:FreeRTOS/Source/tasks.c **** 
 566:FreeRTOS/Source/tasks.c **** /*
 567:FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 568:FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 569:FreeRTOS/Source/tasks.c ****  * called by the function.
 570:FreeRTOS/Source/tasks.c ****  */
 571:FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 572:FreeRTOS/Source/tasks.c **** 
 573:FreeRTOS/Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 574:FreeRTOS/Source/tasks.c **** 
 575:FreeRTOS/Source/tasks.c **** #endif
 576:FreeRTOS/Source/tasks.c **** 
 577:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 578:FreeRTOS/Source/tasks.c **** 
 579:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 580:FreeRTOS/Source/tasks.c **** 
 581:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 582:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 583:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 584:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 585:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 586:FreeRTOS/Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 587:FreeRTOS/Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 588:FreeRTOS/Source/tasks.c **** 	{
 589:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 590:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 591:FreeRTOS/Source/tasks.c **** 
 592:FreeRTOS/Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 593:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 596:FreeRTOS/Source/tasks.c **** 		{
 597:FreeRTOS/Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 598:FreeRTOS/Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 599:FreeRTOS/Source/tasks.c **** 			structure. */
 600:FreeRTOS/Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 601:FreeRTOS/Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 602:FreeRTOS/Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 603:FreeRTOS/Source/tasks.c **** 		}
 604:FreeRTOS/Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 605:FreeRTOS/Source/tasks.c **** 
 606:FreeRTOS/Source/tasks.c **** 
 607:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 608:FreeRTOS/Source/tasks.c **** 		{
 609:FreeRTOS/Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 610:FreeRTOS/Source/tasks.c **** 			function - use them. */
 611:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 612:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 613:FreeRTOS/Source/tasks.c **** 
 614:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 615:FreeRTOS/Source/tasks.c **** 			{
 616:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 617:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 618:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 619:FreeRTOS/Source/tasks.c **** 			}
 620:FreeRTOS/Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 621:FreeRTOS/Source/tasks.c **** 
 622:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 623:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 624:FreeRTOS/Source/tasks.c **** 		}
 625:FreeRTOS/Source/tasks.c **** 		else
 626:FreeRTOS/Source/tasks.c **** 		{
 627:FreeRTOS/Source/tasks.c **** 			xReturn = NULL;
 628:FreeRTOS/Source/tasks.c **** 		}
 629:FreeRTOS/Source/tasks.c **** 
 630:FreeRTOS/Source/tasks.c **** 		return xReturn;
 631:FreeRTOS/Source/tasks.c **** 	}
 632:FreeRTOS/Source/tasks.c **** 
 633:FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 634:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 637:FreeRTOS/Source/tasks.c **** 
 638:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 639:FreeRTOS/Source/tasks.c **** 	{
 640:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 641:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 642:FreeRTOS/Source/tasks.c **** 
 643:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 644:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 645:FreeRTOS/Source/tasks.c **** 
 646:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 647:FreeRTOS/Source/tasks.c **** 		{
 648:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 649:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 650:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 651:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 652:FreeRTOS/Source/tasks.c **** 
 653:FreeRTOS/Source/tasks.c **** 			/* Store the stack location in the TCB. */
 654:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 655:FreeRTOS/Source/tasks.c **** 
 656:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 657:FreeRTOS/Source/tasks.c **** 			{
 658:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 659:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 660:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 661:FreeRTOS/Source/tasks.c **** 			}
 662:FreeRTOS/Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 663:FreeRTOS/Source/tasks.c **** 
 664:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 665:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pcName,
 666:FreeRTOS/Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 667:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 668:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 669:FreeRTOS/Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 670:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->xRegions );
 671:FreeRTOS/Source/tasks.c **** 
 672:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 673:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 674:FreeRTOS/Source/tasks.c **** 		}
 675:FreeRTOS/Source/tasks.c **** 
 676:FreeRTOS/Source/tasks.c **** 		return xReturn;
 677:FreeRTOS/Source/tasks.c **** 	}
 678:FreeRTOS/Source/tasks.c **** 
 679:FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 680:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 681:FreeRTOS/Source/tasks.c **** 
 682:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 683:FreeRTOS/Source/tasks.c **** 
 684:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 685:FreeRTOS/Source/tasks.c **** 	{
 686:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 687:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 688:FreeRTOS/Source/tasks.c **** 
 689:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 690:FreeRTOS/Source/tasks.c **** 
 691:FreeRTOS/Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 692:FreeRTOS/Source/tasks.c **** 		{
 693:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 694:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 695:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 696:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 697:FreeRTOS/Source/tasks.c **** 
 698:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 699:FreeRTOS/Source/tasks.c **** 			{
 700:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
 701:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 702:FreeRTOS/Source/tasks.c **** 
 703:FreeRTOS/Source/tasks.c **** 				#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 704:FreeRTOS/Source/tasks.c **** 				{
 705:FreeRTOS/Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 706:FreeRTOS/Source/tasks.c **** 					this task had a statically allocated stack in case it is
 707:FreeRTOS/Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 708:FreeRTOS/Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 709:FreeRTOS/Source/tasks.c **** 				}
 710:FreeRTOS/Source/tasks.c **** 				#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 711:FreeRTOS/Source/tasks.c **** 
 712:FreeRTOS/Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 713:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pcName,
 714:FreeRTOS/Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 715:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 716:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 717:FreeRTOS/Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 718:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->xRegions );
 719:FreeRTOS/Source/tasks.c **** 
 720:FreeRTOS/Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 721:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 722:FreeRTOS/Source/tasks.c **** 			}
 723:FreeRTOS/Source/tasks.c **** 		}
 724:FreeRTOS/Source/tasks.c **** 
 725:FreeRTOS/Source/tasks.c **** 		return xReturn;
 726:FreeRTOS/Source/tasks.c **** 	}
 727:FreeRTOS/Source/tasks.c **** 
 728:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 729:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 730:FreeRTOS/Source/tasks.c **** 
 731:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 732:FreeRTOS/Source/tasks.c **** 
 733:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 734:FreeRTOS/Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 735:FreeRTOS/Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 736:FreeRTOS/Source/tasks.c **** 							void * const pvParameters,
 737:FreeRTOS/Source/tasks.c **** 							UBaseType_t uxPriority,
 738:FreeRTOS/Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 739:FreeRTOS/Source/tasks.c **** 	{
 740:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 741:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 742:FreeRTOS/Source/tasks.c **** 
 743:FreeRTOS/Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 744:FreeRTOS/Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 745:FreeRTOS/Source/tasks.c **** 		the TCB then the stack. */
 746:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 747:FreeRTOS/Source/tasks.c **** 		{
 748:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 749:FreeRTOS/Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 750:FreeRTOS/Source/tasks.c **** 			allocation is being used. */
 751:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 752:FreeRTOS/Source/tasks.c **** 
 753:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 754:FreeRTOS/Source/tasks.c **** 			{
 755:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 756:FreeRTOS/Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 757:FreeRTOS/Source/tasks.c **** 				be deleted later if required. */
 758:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 759:FreeRTOS/Source/tasks.c **** 
 760:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 761:FreeRTOS/Source/tasks.c **** 				{
 762:FreeRTOS/Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 763:FreeRTOS/Source/tasks.c **** 					vPortFree( pxNewTCB );
 764:FreeRTOS/Source/tasks.c **** 					pxNewTCB = NULL;
 765:FreeRTOS/Source/tasks.c **** 				}
 766:FreeRTOS/Source/tasks.c **** 			}
 767:FreeRTOS/Source/tasks.c **** 		}
 768:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 769:FreeRTOS/Source/tasks.c **** 		{
 770:FreeRTOS/Source/tasks.c **** 		StackType_t *pxStack;
 771:FreeRTOS/Source/tasks.c **** 
 772:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 773:FreeRTOS/Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 774:FreeRTOS/Source/tasks.c **** 
 775:FreeRTOS/Source/tasks.c **** 			if( pxStack != NULL )
 776:FreeRTOS/Source/tasks.c **** 			{
 777:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the TCB. */
 778:FreeRTOS/Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 779:FreeRTOS/Source/tasks.c **** 
 780:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB != NULL )
 781:FreeRTOS/Source/tasks.c **** 				{
 782:FreeRTOS/Source/tasks.c **** 					/* Store the stack location in the TCB. */
 783:FreeRTOS/Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 784:FreeRTOS/Source/tasks.c **** 				}
 785:FreeRTOS/Source/tasks.c **** 				else
 786:FreeRTOS/Source/tasks.c **** 				{
 787:FreeRTOS/Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 788:FreeRTOS/Source/tasks.c **** 					it again. */
 789:FreeRTOS/Source/tasks.c **** 					vPortFree( pxStack );
 790:FreeRTOS/Source/tasks.c **** 				}
 791:FreeRTOS/Source/tasks.c **** 			}
 792:FreeRTOS/Source/tasks.c **** 			else
 793:FreeRTOS/Source/tasks.c **** 			{
 794:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
 795:FreeRTOS/Source/tasks.c **** 			}
 796:FreeRTOS/Source/tasks.c **** 		}
 797:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 798:FreeRTOS/Source/tasks.c **** 
 799:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
 800:FreeRTOS/Source/tasks.c **** 		{
 801:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 802:FreeRTOS/Source/tasks.c **** 			{
 803:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 804:FreeRTOS/Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 805:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 806:FreeRTOS/Source/tasks.c **** 			}
 807:FreeRTOS/Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 808:FreeRTOS/Source/tasks.c **** 
 809:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 810:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 811:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 812:FreeRTOS/Source/tasks.c **** 		}
 813:FreeRTOS/Source/tasks.c **** 		else
 814:FreeRTOS/Source/tasks.c **** 		{
 815:FreeRTOS/Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 816:FreeRTOS/Source/tasks.c **** 		}
 817:FreeRTOS/Source/tasks.c **** 
 818:FreeRTOS/Source/tasks.c **** 		return xReturn;
 819:FreeRTOS/Source/tasks.c **** 	}
 820:FreeRTOS/Source/tasks.c **** 
 821:FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 822:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 823:FreeRTOS/Source/tasks.c **** 
 824:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 825:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 826:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 827:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 828:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 829:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 830:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 831:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 832:FreeRTOS/Source/tasks.c **** {
 833:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 834:FreeRTOS/Source/tasks.c **** UBaseType_t x;
 835:FreeRTOS/Source/tasks.c **** 
 836:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 837:FreeRTOS/Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 838:FreeRTOS/Source/tasks.c **** 		BaseType_t xRunPrivileged;
 839:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 840:FreeRTOS/Source/tasks.c **** 		{
 841:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 842:FreeRTOS/Source/tasks.c **** 		}
 843:FreeRTOS/Source/tasks.c **** 		else
 844:FreeRTOS/Source/tasks.c **** 		{
 845:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 846:FreeRTOS/Source/tasks.c **** 		}
 847:FreeRTOS/Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 848:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 849:FreeRTOS/Source/tasks.c **** 
 850:FreeRTOS/Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 851:FreeRTOS/Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 852:FreeRTOS/Source/tasks.c **** 	{
 853:FreeRTOS/Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 854:FreeRTOS/Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 855:FreeRTOS/Source/tasks.c **** 	}
 856:FreeRTOS/Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 857:FreeRTOS/Source/tasks.c **** 
 858:FreeRTOS/Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 859:FreeRTOS/Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 860:FreeRTOS/Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 861:FreeRTOS/Source/tasks.c **** 	by the port. */
 862:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 863:FreeRTOS/Source/tasks.c **** 	{
 864:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 865:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 866:FreeRTOS/Source/tasks.c **** 
 867:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 868:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 869:FreeRTOS/Source/tasks.c **** 
 870:FreeRTOS/Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 871:FreeRTOS/Source/tasks.c **** 		{
 872:FreeRTOS/Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 873:FreeRTOS/Source/tasks.c **** 			debugging. */
 874:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 875:FreeRTOS/Source/tasks.c **** 		}
 876:FreeRTOS/Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 877:FreeRTOS/Source/tasks.c **** 	}
 878:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 879:FreeRTOS/Source/tasks.c **** 	{
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 881:FreeRTOS/Source/tasks.c **** 
 882:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 883:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 884:FreeRTOS/Source/tasks.c **** 
 885:FreeRTOS/Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 886:FreeRTOS/Source/tasks.c **** 		performed. */
 887:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 888:FreeRTOS/Source/tasks.c **** 	}
 889:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 890:FreeRTOS/Source/tasks.c **** 
 891:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
 892:FreeRTOS/Source/tasks.c **** 	if( pcName != NULL )
 893:FreeRTOS/Source/tasks.c **** 	{
 894:FreeRTOS/Source/tasks.c **** 		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 895:FreeRTOS/Source/tasks.c **** 		{
 896:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 897:FreeRTOS/Source/tasks.c **** 
 898:FreeRTOS/Source/tasks.c **** 			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 899:FreeRTOS/Source/tasks.c **** 			configMAX_TASK_NAME_LEN characters just in case the memory after the
 900:FreeRTOS/Source/tasks.c **** 			string is not accessible (extremely unlikely). */
 901:FreeRTOS/Source/tasks.c **** 			if( pcName[ x ] == ( char ) 0x00 )
 902:FreeRTOS/Source/tasks.c **** 			{
 903:FreeRTOS/Source/tasks.c **** 				break;
 904:FreeRTOS/Source/tasks.c **** 			}
 905:FreeRTOS/Source/tasks.c **** 			else
 906:FreeRTOS/Source/tasks.c **** 			{
 907:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 908:FreeRTOS/Source/tasks.c **** 			}
 909:FreeRTOS/Source/tasks.c **** 		}
 910:FreeRTOS/Source/tasks.c **** 
 911:FreeRTOS/Source/tasks.c **** 		/* Ensure the name string is terminated in the case that the string length
 912:FreeRTOS/Source/tasks.c **** 		was greater or equal to configMAX_TASK_NAME_LEN. */
 913:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 914:FreeRTOS/Source/tasks.c **** 	}
 915:FreeRTOS/Source/tasks.c **** 	else
 916:FreeRTOS/Source/tasks.c **** 	{
 917:FreeRTOS/Source/tasks.c **** 		/* The task has not been given a name, so just ensure there is a NULL
 918:FreeRTOS/Source/tasks.c **** 		terminator when it is read out. */
 919:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 920:FreeRTOS/Source/tasks.c **** 	}
 921:FreeRTOS/Source/tasks.c **** 
 922:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 923:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
 924:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 925:FreeRTOS/Source/tasks.c **** 	{
 926:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 927:FreeRTOS/Source/tasks.c **** 	}
 928:FreeRTOS/Source/tasks.c **** 	else
 929:FreeRTOS/Source/tasks.c **** 	{
 930:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 931:FreeRTOS/Source/tasks.c **** 	}
 932:FreeRTOS/Source/tasks.c **** 
 933:FreeRTOS/Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 934:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 935:FreeRTOS/Source/tasks.c **** 	{
 936:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 937:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 938:FreeRTOS/Source/tasks.c **** 	}
 939:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 940:FreeRTOS/Source/tasks.c **** 
 941:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 942:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 943:FreeRTOS/Source/tasks.c **** 
 944:FreeRTOS/Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 945:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 946:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 947:FreeRTOS/Source/tasks.c **** 
 948:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
 949:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 950:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 951:FreeRTOS/Source/tasks.c **** 
 952:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 953:FreeRTOS/Source/tasks.c **** 	{
 954:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 955:FreeRTOS/Source/tasks.c **** 	}
 956:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 957:FreeRTOS/Source/tasks.c **** 
 958:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 959:FreeRTOS/Source/tasks.c **** 	{
 960:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 961:FreeRTOS/Source/tasks.c **** 	}
 962:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 963:FreeRTOS/Source/tasks.c **** 
 964:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 965:FreeRTOS/Source/tasks.c **** 	{
 966:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 967:FreeRTOS/Source/tasks.c **** 	}
 968:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 969:FreeRTOS/Source/tasks.c **** 
 970:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 971:FreeRTOS/Source/tasks.c **** 	{
 972:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 973:FreeRTOS/Source/tasks.c **** 	}
 974:FreeRTOS/Source/tasks.c **** 	#else
 975:FreeRTOS/Source/tasks.c **** 	{
 976:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 977:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
 978:FreeRTOS/Source/tasks.c **** 	}
 979:FreeRTOS/Source/tasks.c **** 	#endif
 980:FreeRTOS/Source/tasks.c **** 
 981:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 982:FreeRTOS/Source/tasks.c **** 	{
 983:FreeRTOS/Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 984:FreeRTOS/Source/tasks.c **** 		{
 985:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 986:FreeRTOS/Source/tasks.c **** 		}
 987:FreeRTOS/Source/tasks.c **** 	}
 988:FreeRTOS/Source/tasks.c **** 	#endif
 989:FreeRTOS/Source/tasks.c **** 
 990:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 991:FreeRTOS/Source/tasks.c **** 	{
 992:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 993:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 994:FreeRTOS/Source/tasks.c **** 	}
 995:FreeRTOS/Source/tasks.c **** 	#endif
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 998:FreeRTOS/Source/tasks.c **** 	{
 999:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure.
1000:FreeRTOS/Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
1001:FreeRTOS/Source/tasks.c **** 		for additional information. */
1002:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1003:FreeRTOS/Source/tasks.c **** 	}
1004:FreeRTOS/Source/tasks.c **** 	#endif
1005:FreeRTOS/Source/tasks.c **** 
1006:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1007:FreeRTOS/Source/tasks.c **** 	{
1008:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1009:FreeRTOS/Source/tasks.c **** 	}
1010:FreeRTOS/Source/tasks.c **** 	#endif
1011:FreeRTOS/Source/tasks.c **** 
1012:FreeRTOS/Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1013:FreeRTOS/Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1014:FreeRTOS/Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1015:FreeRTOS/Source/tasks.c **** 	the top of stack variable is updated. */
1016:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1017:FreeRTOS/Source/tasks.c **** 	{
1018:FreeRTOS/Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1019:FreeRTOS/Source/tasks.c **** 		pass the stack end address to the stack initialization
1020:FreeRTOS/Source/tasks.c **** 		function as well. */
1021:FreeRTOS/Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1022:FreeRTOS/Source/tasks.c **** 		{
1023:FreeRTOS/Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1024:FreeRTOS/Source/tasks.c **** 			{
1025:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1026:FreeRTOS/Source/tasks.c **** 			}
1027:FreeRTOS/Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1028:FreeRTOS/Source/tasks.c **** 			{
1029:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1030:FreeRTOS/Source/tasks.c **** 			}
1031:FreeRTOS/Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1032:FreeRTOS/Source/tasks.c **** 		}
1033:FreeRTOS/Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1034:FreeRTOS/Source/tasks.c **** 		{
1035:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
1036:FreeRTOS/Source/tasks.c **** 		}
1037:FreeRTOS/Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1038:FreeRTOS/Source/tasks.c **** 	}
1039:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1040:FreeRTOS/Source/tasks.c **** 	{
1041:FreeRTOS/Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1042:FreeRTOS/Source/tasks.c **** 		pass the stack end address to the stack initialization
1043:FreeRTOS/Source/tasks.c **** 		function as well. */
1044:FreeRTOS/Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1045:FreeRTOS/Source/tasks.c **** 		{
1046:FreeRTOS/Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1047:FreeRTOS/Source/tasks.c **** 			{
1048:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1049:FreeRTOS/Source/tasks.c **** 			}
1050:FreeRTOS/Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1051:FreeRTOS/Source/tasks.c **** 			{
1052:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1053:FreeRTOS/Source/tasks.c **** 			}
1054:FreeRTOS/Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1055:FreeRTOS/Source/tasks.c **** 		}
1056:FreeRTOS/Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1057:FreeRTOS/Source/tasks.c **** 		{
1058:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1059:FreeRTOS/Source/tasks.c **** 		}
1060:FreeRTOS/Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1061:FreeRTOS/Source/tasks.c **** 	}
1062:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1063:FreeRTOS/Source/tasks.c **** 
1064:FreeRTOS/Source/tasks.c **** 	if( pxCreatedTask != NULL )
1065:FreeRTOS/Source/tasks.c **** 	{
1066:FreeRTOS/Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1067:FreeRTOS/Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1068:FreeRTOS/Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1069:FreeRTOS/Source/tasks.c **** 	}
1070:FreeRTOS/Source/tasks.c **** 	else
1071:FreeRTOS/Source/tasks.c **** 	{
1072:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1073:FreeRTOS/Source/tasks.c **** 	}
1074:FreeRTOS/Source/tasks.c **** }
1075:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1076:FreeRTOS/Source/tasks.c **** 
1077:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1078:FreeRTOS/Source/tasks.c **** {
1079:FreeRTOS/Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1080:FreeRTOS/Source/tasks.c **** 	updated. */
1081:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1082:FreeRTOS/Source/tasks.c **** 	{
1083:FreeRTOS/Source/tasks.c **** 		uxCurrentNumberOfTasks++;
1084:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
1085:FreeRTOS/Source/tasks.c **** 		{
1086:FreeRTOS/Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1087:FreeRTOS/Source/tasks.c **** 			the suspended state - make this the current task. */
1088:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1089:FreeRTOS/Source/tasks.c **** 
1090:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1091:FreeRTOS/Source/tasks.c **** 			{
1092:FreeRTOS/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1093:FreeRTOS/Source/tasks.c **** 				initialisation required.  We will not recover if this call
1094:FreeRTOS/Source/tasks.c **** 				fails, but we will report the failure. */
1095:FreeRTOS/Source/tasks.c **** 				prvInitialiseTaskLists();
1096:FreeRTOS/Source/tasks.c **** 			}
1097:FreeRTOS/Source/tasks.c **** 			else
1098:FreeRTOS/Source/tasks.c **** 			{
1099:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1100:FreeRTOS/Source/tasks.c **** 			}
1101:FreeRTOS/Source/tasks.c **** 		}
1102:FreeRTOS/Source/tasks.c **** 		else
1103:FreeRTOS/Source/tasks.c **** 		{
1104:FreeRTOS/Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1105:FreeRTOS/Source/tasks.c **** 			current task if it is the highest priority task to be created
1106:FreeRTOS/Source/tasks.c **** 			so far. */
1107:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1108:FreeRTOS/Source/tasks.c **** 			{
1109:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1110:FreeRTOS/Source/tasks.c **** 				{
1111:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1112:FreeRTOS/Source/tasks.c **** 				}
1113:FreeRTOS/Source/tasks.c **** 				else
1114:FreeRTOS/Source/tasks.c **** 				{
1115:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1116:FreeRTOS/Source/tasks.c **** 				}
1117:FreeRTOS/Source/tasks.c **** 			}
1118:FreeRTOS/Source/tasks.c **** 			else
1119:FreeRTOS/Source/tasks.c **** 			{
1120:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1121:FreeRTOS/Source/tasks.c **** 			}
1122:FreeRTOS/Source/tasks.c **** 		}
1123:FreeRTOS/Source/tasks.c **** 
1124:FreeRTOS/Source/tasks.c **** 		uxTaskNumber++;
1125:FreeRTOS/Source/tasks.c **** 
1126:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1127:FreeRTOS/Source/tasks.c **** 		{
1128:FreeRTOS/Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1129:FreeRTOS/Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1130:FreeRTOS/Source/tasks.c **** 		}
1131:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1132:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1133:FreeRTOS/Source/tasks.c **** 
1134:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1135:FreeRTOS/Source/tasks.c **** 
1136:FreeRTOS/Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1137:FreeRTOS/Source/tasks.c **** 	}
1138:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1139:FreeRTOS/Source/tasks.c **** 
1140:FreeRTOS/Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1141:FreeRTOS/Source/tasks.c **** 	{
1142:FreeRTOS/Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1143:FreeRTOS/Source/tasks.c **** 		then it should run now. */
1144:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1145:FreeRTOS/Source/tasks.c **** 		{
1146:FreeRTOS/Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1147:FreeRTOS/Source/tasks.c **** 		}
1148:FreeRTOS/Source/tasks.c **** 		else
1149:FreeRTOS/Source/tasks.c **** 		{
1150:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1151:FreeRTOS/Source/tasks.c **** 		}
1152:FreeRTOS/Source/tasks.c **** 	}
1153:FreeRTOS/Source/tasks.c **** 	else
1154:FreeRTOS/Source/tasks.c **** 	{
1155:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1156:FreeRTOS/Source/tasks.c **** 	}
1157:FreeRTOS/Source/tasks.c **** }
1158:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1159:FreeRTOS/Source/tasks.c **** 
1160:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1161:FreeRTOS/Source/tasks.c **** 
1162:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1163:FreeRTOS/Source/tasks.c **** 	{
1164:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1165:FreeRTOS/Source/tasks.c **** 
1166:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1167:FreeRTOS/Source/tasks.c **** 		{
1168:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1169:FreeRTOS/Source/tasks.c **** 			being deleted. */
1170:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1171:FreeRTOS/Source/tasks.c **** 
1172:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list. */
1173:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1174:FreeRTOS/Source/tasks.c **** 			{
1175:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1176:FreeRTOS/Source/tasks.c **** 			}
1177:FreeRTOS/Source/tasks.c **** 			else
1178:FreeRTOS/Source/tasks.c **** 			{
1179:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1180:FreeRTOS/Source/tasks.c **** 			}
1181:FreeRTOS/Source/tasks.c **** 
1182:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1183:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1184:FreeRTOS/Source/tasks.c **** 			{
1185:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1186:FreeRTOS/Source/tasks.c **** 			}
1187:FreeRTOS/Source/tasks.c **** 			else
1188:FreeRTOS/Source/tasks.c **** 			{
1189:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1190:FreeRTOS/Source/tasks.c **** 			}
1191:FreeRTOS/Source/tasks.c **** 
1192:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1193:FreeRTOS/Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1194:FreeRTOS/Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1195:FreeRTOS/Source/tasks.c **** 			not return. */
1196:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
1197:FreeRTOS/Source/tasks.c **** 
1198:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1199:FreeRTOS/Source/tasks.c **** 			{
1200:FreeRTOS/Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1201:FreeRTOS/Source/tasks.c **** 				task itself, as a context switch to another task is required.
1202:FreeRTOS/Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1203:FreeRTOS/Source/tasks.c **** 				check the termination list and free up any memory allocated by
1204:FreeRTOS/Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1205:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1206:FreeRTOS/Source/tasks.c **** 
1207:FreeRTOS/Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1208:FreeRTOS/Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1209:FreeRTOS/Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1210:FreeRTOS/Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1211:FreeRTOS/Source/tasks.c **** 
1212:FreeRTOS/Source/tasks.c **** 				/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
1213:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
1214:FreeRTOS/Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1215:FreeRTOS/Source/tasks.c **** 
1216:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1217:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1218:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
1219:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1220:FreeRTOS/Source/tasks.c **** 				required. */
1221:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1222:FreeRTOS/Source/tasks.c **** 			}
1223:FreeRTOS/Source/tasks.c **** 			else
1224:FreeRTOS/Source/tasks.c **** 			{
1225:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
1226:FreeRTOS/Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1227:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1228:FreeRTOS/Source/tasks.c **** 
1229:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1230:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
1231:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1232:FreeRTOS/Source/tasks.c **** 			}
1233:FreeRTOS/Source/tasks.c **** 		}
1234:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1235:FreeRTOS/Source/tasks.c **** 
1236:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1237:FreeRTOS/Source/tasks.c **** 		been deleted. */
1238:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1239:FreeRTOS/Source/tasks.c **** 		{
1240:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1241:FreeRTOS/Source/tasks.c **** 			{
1242:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1243:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1244:FreeRTOS/Source/tasks.c **** 			}
1245:FreeRTOS/Source/tasks.c **** 			else
1246:FreeRTOS/Source/tasks.c **** 			{
1247:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1248:FreeRTOS/Source/tasks.c **** 			}
1249:FreeRTOS/Source/tasks.c **** 		}
1250:FreeRTOS/Source/tasks.c **** 	}
1251:FreeRTOS/Source/tasks.c **** 
1252:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1254:FreeRTOS/Source/tasks.c **** 
1255:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1256:FreeRTOS/Source/tasks.c **** 
1257:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1258:FreeRTOS/Source/tasks.c **** 	{
1259:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
1260:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1261:FreeRTOS/Source/tasks.c **** 
1262:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1263:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1264:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1265:FreeRTOS/Source/tasks.c **** 
1266:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1267:FreeRTOS/Source/tasks.c **** 		{
1268:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1269:FreeRTOS/Source/tasks.c **** 			block. */
1270:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1271:FreeRTOS/Source/tasks.c **** 
1272:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1273:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1274:FreeRTOS/Source/tasks.c **** 
1275:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1276:FreeRTOS/Source/tasks.c **** 			{
1277:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
1278:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1279:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1280:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1281:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1282:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1283:FreeRTOS/Source/tasks.c **** 				{
1284:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1285:FreeRTOS/Source/tasks.c **** 				}
1286:FreeRTOS/Source/tasks.c **** 				else
1287:FreeRTOS/Source/tasks.c **** 				{
1288:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1289:FreeRTOS/Source/tasks.c **** 				}
1290:FreeRTOS/Source/tasks.c **** 			}
1291:FreeRTOS/Source/tasks.c **** 			else
1292:FreeRTOS/Source/tasks.c **** 			{
1293:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1294:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1295:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
1296:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1297:FreeRTOS/Source/tasks.c **** 				{
1298:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1299:FreeRTOS/Source/tasks.c **** 				}
1300:FreeRTOS/Source/tasks.c **** 				else
1301:FreeRTOS/Source/tasks.c **** 				{
1302:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1303:FreeRTOS/Source/tasks.c **** 				}
1304:FreeRTOS/Source/tasks.c **** 			}
1305:FreeRTOS/Source/tasks.c **** 
1306:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1307:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1308:FreeRTOS/Source/tasks.c **** 
1309:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
1310:FreeRTOS/Source/tasks.c **** 			{
1311:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1312:FreeRTOS/Source/tasks.c **** 
1313:FreeRTOS/Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1314:FreeRTOS/Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1315:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1316:FreeRTOS/Source/tasks.c **** 			}
1317:FreeRTOS/Source/tasks.c **** 			else
1318:FreeRTOS/Source/tasks.c **** 			{
1319:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1320:FreeRTOS/Source/tasks.c **** 			}
1321:FreeRTOS/Source/tasks.c **** 		}
1322:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1323:FreeRTOS/Source/tasks.c **** 
1324:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1325:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1326:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1327:FreeRTOS/Source/tasks.c **** 		{
1328:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1329:FreeRTOS/Source/tasks.c **** 		}
1330:FreeRTOS/Source/tasks.c **** 		else
1331:FreeRTOS/Source/tasks.c **** 		{
1332:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1333:FreeRTOS/Source/tasks.c **** 		}
1334:FreeRTOS/Source/tasks.c **** 	}
1335:FreeRTOS/Source/tasks.c **** 
1336:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1337:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1338:FreeRTOS/Source/tasks.c **** 
1339:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1340:FreeRTOS/Source/tasks.c **** 
1341:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1342:FreeRTOS/Source/tasks.c **** 	{
1343:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1344:FreeRTOS/Source/tasks.c **** 
1345:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1346:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1347:FreeRTOS/Source/tasks.c **** 		{
1348:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1349:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
1350:FreeRTOS/Source/tasks.c **** 			{
1351:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
1352:FreeRTOS/Source/tasks.c **** 
1353:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
1354:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1355:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1356:FreeRTOS/Source/tasks.c **** 				is resumed.
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1359:FreeRTOS/Source/tasks.c **** 				executing task. */
1360:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1361:FreeRTOS/Source/tasks.c **** 			}
1362:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1363:FreeRTOS/Source/tasks.c **** 		}
1364:FreeRTOS/Source/tasks.c **** 		else
1365:FreeRTOS/Source/tasks.c **** 		{
1366:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1367:FreeRTOS/Source/tasks.c **** 		}
1368:FreeRTOS/Source/tasks.c **** 
1369:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1370:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1371:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1372:FreeRTOS/Source/tasks.c **** 		{
1373:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1374:FreeRTOS/Source/tasks.c **** 		}
1375:FreeRTOS/Source/tasks.c **** 		else
1376:FreeRTOS/Source/tasks.c **** 		{
1377:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1378:FreeRTOS/Source/tasks.c **** 		}
1379:FreeRTOS/Source/tasks.c **** 	}
1380:FreeRTOS/Source/tasks.c **** 
1381:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1382:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1383:FreeRTOS/Source/tasks.c **** 
1384:FreeRTOS/Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDel
1385:FreeRTOS/Source/tasks.c **** 
1386:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1387:FreeRTOS/Source/tasks.c **** 	{
1388:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
1389:FreeRTOS/Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1390:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1391:FreeRTOS/Source/tasks.c **** 
1392:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1393:FreeRTOS/Source/tasks.c **** 
1394:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1395:FreeRTOS/Source/tasks.c **** 		{
1396:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1397:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
1398:FreeRTOS/Source/tasks.c **** 		}
1399:FreeRTOS/Source/tasks.c **** 		else
1400:FreeRTOS/Source/tasks.c **** 		{
1401:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1402:FreeRTOS/Source/tasks.c **** 			{
1403:FreeRTOS/Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1404:FreeRTOS/Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1405:FreeRTOS/Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1406:FreeRTOS/Source/tasks.c **** 			}
1407:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1408:FreeRTOS/Source/tasks.c **** 
1409:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1410:FreeRTOS/Source/tasks.c **** 			{
1411:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1412:FreeRTOS/Source/tasks.c **** 				lists. */
1413:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1414:FreeRTOS/Source/tasks.c **** 			}
1415:FreeRTOS/Source/tasks.c **** 
1416:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1417:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1418:FreeRTOS/Source/tasks.c **** 				{
1419:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1420:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1421:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1422:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1423:FreeRTOS/Source/tasks.c **** 					{
1424:FreeRTOS/Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1425:FreeRTOS/Source/tasks.c **** 						{
1426:FreeRTOS/Source/tasks.c **** 							/* The task does not appear on the event list item of
1427:FreeRTOS/Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1428:FreeRTOS/Source/tasks.c **** 							blocked state if it is waiting on its notification
1429:FreeRTOS/Source/tasks.c **** 							rather than waiting on an object. */
1430:FreeRTOS/Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1431:FreeRTOS/Source/tasks.c **** 							{
1432:FreeRTOS/Source/tasks.c **** 								eReturn = eBlocked;
1433:FreeRTOS/Source/tasks.c **** 							}
1434:FreeRTOS/Source/tasks.c **** 							else
1435:FreeRTOS/Source/tasks.c **** 							{
1436:FreeRTOS/Source/tasks.c **** 								eReturn = eSuspended;
1437:FreeRTOS/Source/tasks.c **** 							}
1438:FreeRTOS/Source/tasks.c **** 						}
1439:FreeRTOS/Source/tasks.c **** 						#else
1440:FreeRTOS/Source/tasks.c **** 						{
1441:FreeRTOS/Source/tasks.c **** 							eReturn = eSuspended;
1442:FreeRTOS/Source/tasks.c **** 						}
1443:FreeRTOS/Source/tasks.c **** 						#endif
1444:FreeRTOS/Source/tasks.c **** 					}
1445:FreeRTOS/Source/tasks.c **** 					else
1446:FreeRTOS/Source/tasks.c **** 					{
1447:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1448:FreeRTOS/Source/tasks.c **** 					}
1449:FreeRTOS/Source/tasks.c **** 				}
1450:FreeRTOS/Source/tasks.c **** 			#endif
1451:FreeRTOS/Source/tasks.c **** 
1452:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1453:FreeRTOS/Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1454:FreeRTOS/Source/tasks.c **** 				{
1455:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1456:FreeRTOS/Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1457:FreeRTOS/Source/tasks.c **** 					all. */
1458:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1459:FreeRTOS/Source/tasks.c **** 				}
1460:FreeRTOS/Source/tasks.c **** 			#endif
1461:FreeRTOS/Source/tasks.c **** 
1462:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1463:FreeRTOS/Source/tasks.c **** 			{
1464:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1465:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1466:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1467:FreeRTOS/Source/tasks.c **** 			}
1468:FreeRTOS/Source/tasks.c **** 		}
1469:FreeRTOS/Source/tasks.c **** 
1470:FreeRTOS/Source/tasks.c **** 		return eReturn;
1471:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1472:FreeRTOS/Source/tasks.c **** 
1473:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1474:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1475:FreeRTOS/Source/tasks.c **** 
1476:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1477:FreeRTOS/Source/tasks.c **** 
1478:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1479:FreeRTOS/Source/tasks.c **** 	{
1480:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1481:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1482:FreeRTOS/Source/tasks.c **** 
1483:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1484:FreeRTOS/Source/tasks.c **** 		{
1485:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1486:FreeRTOS/Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1487:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1488:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1489:FreeRTOS/Source/tasks.c **** 		}
1490:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1491:FreeRTOS/Source/tasks.c **** 
1492:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1493:FreeRTOS/Source/tasks.c **** 	}
1494:FreeRTOS/Source/tasks.c **** 
1495:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1496:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1497:FreeRTOS/Source/tasks.c **** 
1498:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1499:FreeRTOS/Source/tasks.c **** 
1500:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1501:FreeRTOS/Source/tasks.c **** 	{
1502:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1503:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1504:FreeRTOS/Source/tasks.c **** 
1505:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1506:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1507:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1508:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1509:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1510:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1511:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1512:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1513:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1514:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1515:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1516:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1517:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1518:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1519:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1520:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1521:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1522:FreeRTOS/Source/tasks.c **** 
1523:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1524:FreeRTOS/Source/tasks.c **** 		{
1525:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1526:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1527:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1528:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1529:FreeRTOS/Source/tasks.c **** 		}
1530:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1531:FreeRTOS/Source/tasks.c **** 
1532:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1533:FreeRTOS/Source/tasks.c **** 	}
1534:FreeRTOS/Source/tasks.c **** 
1535:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1536:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1537:FreeRTOS/Source/tasks.c **** 
1538:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1539:FreeRTOS/Source/tasks.c **** 
1540:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1541:FreeRTOS/Source/tasks.c **** 	{
1542:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1543:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1544:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1545:FreeRTOS/Source/tasks.c **** 
1546:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1547:FreeRTOS/Source/tasks.c **** 
1548:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1549:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1550:FreeRTOS/Source/tasks.c **** 		{
1551:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1552:FreeRTOS/Source/tasks.c **** 		}
1553:FreeRTOS/Source/tasks.c **** 		else
1554:FreeRTOS/Source/tasks.c **** 		{
1555:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1556:FreeRTOS/Source/tasks.c **** 		}
1557:FreeRTOS/Source/tasks.c **** 
1558:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1559:FreeRTOS/Source/tasks.c **** 		{
1560:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1561:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1562:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1563:FreeRTOS/Source/tasks.c **** 
1564:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1565:FreeRTOS/Source/tasks.c **** 
1566:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1567:FreeRTOS/Source/tasks.c **** 			{
1568:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1569:FreeRTOS/Source/tasks.c **** 			}
1570:FreeRTOS/Source/tasks.c **** 			#else
1571:FreeRTOS/Source/tasks.c **** 			{
1572:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1573:FreeRTOS/Source/tasks.c **** 			}
1574:FreeRTOS/Source/tasks.c **** 			#endif
1575:FreeRTOS/Source/tasks.c **** 
1576:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1577:FreeRTOS/Source/tasks.c **** 			{
1578:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1579:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1580:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1581:FreeRTOS/Source/tasks.c **** 				{
1582:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1583:FreeRTOS/Source/tasks.c **** 					{
1584:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1585:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1586:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1587:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1588:FreeRTOS/Source/tasks.c **** 						{
1589:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1590:FreeRTOS/Source/tasks.c **** 						}
1591:FreeRTOS/Source/tasks.c **** 						else
1592:FreeRTOS/Source/tasks.c **** 						{
1593:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1594:FreeRTOS/Source/tasks.c **** 						}
1595:FreeRTOS/Source/tasks.c **** 					}
1596:FreeRTOS/Source/tasks.c **** 					else
1597:FreeRTOS/Source/tasks.c **** 					{
1598:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1599:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1600:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1601:FreeRTOS/Source/tasks.c **** 					}
1602:FreeRTOS/Source/tasks.c **** 				}
1603:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1604:FreeRTOS/Source/tasks.c **** 				{
1605:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1606:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1607:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1608:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1609:FreeRTOS/Source/tasks.c **** 				}
1610:FreeRTOS/Source/tasks.c **** 				else
1611:FreeRTOS/Source/tasks.c **** 				{
1612:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1613:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1614:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1615:FreeRTOS/Source/tasks.c **** 				}
1616:FreeRTOS/Source/tasks.c **** 
1617:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1618:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1619:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1620:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1621:FreeRTOS/Source/tasks.c **** 
1622:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1623:FreeRTOS/Source/tasks.c **** 				{
1624:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1625:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1626:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1627:FreeRTOS/Source/tasks.c **** 					{
1628:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1629:FreeRTOS/Source/tasks.c **** 					}
1630:FreeRTOS/Source/tasks.c **** 					else
1631:FreeRTOS/Source/tasks.c **** 					{
1632:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1633:FreeRTOS/Source/tasks.c **** 					}
1634:FreeRTOS/Source/tasks.c **** 
1635:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1636:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1637:FreeRTOS/Source/tasks.c **** 				}
1638:FreeRTOS/Source/tasks.c **** 				#else
1639:FreeRTOS/Source/tasks.c **** 				{
1640:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1641:FreeRTOS/Source/tasks.c **** 				}
1642:FreeRTOS/Source/tasks.c **** 				#endif
1643:FreeRTOS/Source/tasks.c **** 
1644:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1645:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1646:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1647:FreeRTOS/Source/tasks.c **** 				{
1648:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1649:FreeRTOS/Source/tasks.c **** 				}
1650:FreeRTOS/Source/tasks.c **** 				else
1651:FreeRTOS/Source/tasks.c **** 				{
1652:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:FreeRTOS/Source/tasks.c **** 				}
1654:FreeRTOS/Source/tasks.c **** 
1655:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1656:FreeRTOS/Source/tasks.c **** 				nothing more than change its priority variable. However, if
1657:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1658:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1659:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1660:FreeRTOS/Source/tasks.c **** 				{
1661:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1662:FreeRTOS/Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1663:FreeRTOS/Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1664:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1665:FreeRTOS/Source/tasks.c **** 					{
1666:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1667:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1668:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1669:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1670:FreeRTOS/Source/tasks.c **** 					}
1671:FreeRTOS/Source/tasks.c **** 					else
1672:FreeRTOS/Source/tasks.c **** 					{
1673:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1674:FreeRTOS/Source/tasks.c **** 					}
1675:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1676:FreeRTOS/Source/tasks.c **** 				}
1677:FreeRTOS/Source/tasks.c **** 				else
1678:FreeRTOS/Source/tasks.c **** 				{
1679:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1680:FreeRTOS/Source/tasks.c **** 				}
1681:FreeRTOS/Source/tasks.c **** 
1682:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
1683:FreeRTOS/Source/tasks.c **** 				{
1684:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1685:FreeRTOS/Source/tasks.c **** 				}
1686:FreeRTOS/Source/tasks.c **** 				else
1687:FreeRTOS/Source/tasks.c **** 				{
1688:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1689:FreeRTOS/Source/tasks.c **** 				}
1690:FreeRTOS/Source/tasks.c **** 
1691:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1692:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1693:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1694:FreeRTOS/Source/tasks.c **** 			}
1695:FreeRTOS/Source/tasks.c **** 		}
1696:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1697:FreeRTOS/Source/tasks.c **** 	}
1698:FreeRTOS/Source/tasks.c **** 
1699:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1700:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1701:FreeRTOS/Source/tasks.c **** 
1702:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1703:FreeRTOS/Source/tasks.c **** 
1704:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1705:FreeRTOS/Source/tasks.c **** 	{
1706:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1707:FreeRTOS/Source/tasks.c **** 
1708:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1709:FreeRTOS/Source/tasks.c **** 		{
1710:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1711:FreeRTOS/Source/tasks.c **** 			being suspended. */
1712:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1713:FreeRTOS/Source/tasks.c **** 
1714:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1715:FreeRTOS/Source/tasks.c **** 
1716:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1717:FreeRTOS/Source/tasks.c **** 			suspended list. */
1718:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1719:FreeRTOS/Source/tasks.c **** 			{
1720:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1721:FreeRTOS/Source/tasks.c **** 			}
1722:FreeRTOS/Source/tasks.c **** 			else
1723:FreeRTOS/Source/tasks.c **** 			{
1724:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1725:FreeRTOS/Source/tasks.c **** 			}
1726:FreeRTOS/Source/tasks.c **** 
1727:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1728:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1729:FreeRTOS/Source/tasks.c **** 			{
1730:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1731:FreeRTOS/Source/tasks.c **** 			}
1732:FreeRTOS/Source/tasks.c **** 			else
1733:FreeRTOS/Source/tasks.c **** 			{
1734:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1735:FreeRTOS/Source/tasks.c **** 			}
1736:FreeRTOS/Source/tasks.c **** 
1737:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1738:FreeRTOS/Source/tasks.c **** 
1739:FreeRTOS/Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1740:FreeRTOS/Source/tasks.c **** 			{
1741:FreeRTOS/Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1742:FreeRTOS/Source/tasks.c **** 				{
1743:FreeRTOS/Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1744:FreeRTOS/Source/tasks.c **** 					now suspended, so no notification was received. */
1745:FreeRTOS/Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1746:FreeRTOS/Source/tasks.c **** 				}
1747:FreeRTOS/Source/tasks.c **** 			}
1748:FreeRTOS/Source/tasks.c **** 			#endif
1749:FreeRTOS/Source/tasks.c **** 		}
1750:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1751:FreeRTOS/Source/tasks.c **** 
1752:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1753:FreeRTOS/Source/tasks.c **** 		{
1754:FreeRTOS/Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1755:FreeRTOS/Source/tasks.c **** 			task that is now in the Suspended state. */
1756:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1757:FreeRTOS/Source/tasks.c **** 			{
1758:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1759:FreeRTOS/Source/tasks.c **** 			}
1760:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1761:FreeRTOS/Source/tasks.c **** 		}
1762:FreeRTOS/Source/tasks.c **** 		else
1763:FreeRTOS/Source/tasks.c **** 		{
1764:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1765:FreeRTOS/Source/tasks.c **** 		}
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1768:FreeRTOS/Source/tasks.c **** 		{
1769:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1770:FreeRTOS/Source/tasks.c **** 			{
1771:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1772:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1773:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1774:FreeRTOS/Source/tasks.c **** 			}
1775:FreeRTOS/Source/tasks.c **** 			else
1776:FreeRTOS/Source/tasks.c **** 			{
1777:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1778:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1779:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1780:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1781:FreeRTOS/Source/tasks.c **** 				{
1782:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1783:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1784:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1785:FreeRTOS/Source/tasks.c **** 					is. */
1786:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1787:FreeRTOS/Source/tasks.c **** 				}
1788:FreeRTOS/Source/tasks.c **** 				else
1789:FreeRTOS/Source/tasks.c **** 				{
1790:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1791:FreeRTOS/Source/tasks.c **** 				}
1792:FreeRTOS/Source/tasks.c **** 			}
1793:FreeRTOS/Source/tasks.c **** 		}
1794:FreeRTOS/Source/tasks.c **** 		else
1795:FreeRTOS/Source/tasks.c **** 		{
1796:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1797:FreeRTOS/Source/tasks.c **** 		}
1798:FreeRTOS/Source/tasks.c **** 	}
1799:FreeRTOS/Source/tasks.c **** 
1800:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1801:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1802:FreeRTOS/Source/tasks.c **** 
1803:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1804:FreeRTOS/Source/tasks.c **** 
1805:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1806:FreeRTOS/Source/tasks.c **** 	{
1807:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1808:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1809:FreeRTOS/Source/tasks.c **** 
1810:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1811:FreeRTOS/Source/tasks.c **** 		section. */
1812:FreeRTOS/Source/tasks.c **** 
1813:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1814:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1815:FreeRTOS/Source/tasks.c **** 
1816:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1817:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1818:FreeRTOS/Source/tasks.c **** 		{
1819:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1820:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1821:FreeRTOS/Source/tasks.c **** 			{
1822:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1823:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1824:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1825:FreeRTOS/Source/tasks.c **** 				{
1826:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1827:FreeRTOS/Source/tasks.c **** 				}
1828:FreeRTOS/Source/tasks.c **** 				else
1829:FreeRTOS/Source/tasks.c **** 				{
1830:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1831:FreeRTOS/Source/tasks.c **** 				}
1832:FreeRTOS/Source/tasks.c **** 			}
1833:FreeRTOS/Source/tasks.c **** 			else
1834:FreeRTOS/Source/tasks.c **** 			{
1835:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1836:FreeRTOS/Source/tasks.c **** 			}
1837:FreeRTOS/Source/tasks.c **** 		}
1838:FreeRTOS/Source/tasks.c **** 		else
1839:FreeRTOS/Source/tasks.c **** 		{
1840:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1841:FreeRTOS/Source/tasks.c **** 		}
1842:FreeRTOS/Source/tasks.c **** 
1843:FreeRTOS/Source/tasks.c **** 		return xReturn;
1844:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1845:FreeRTOS/Source/tasks.c **** 
1846:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1847:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1848:FreeRTOS/Source/tasks.c **** 
1849:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1850:FreeRTOS/Source/tasks.c **** 
1851:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1852:FreeRTOS/Source/tasks.c **** 	{
1853:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1854:FreeRTOS/Source/tasks.c **** 
1855:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1856:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1857:FreeRTOS/Source/tasks.c **** 
1858:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1859:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1860:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1861:FreeRTOS/Source/tasks.c **** 		{
1862:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1863:FreeRTOS/Source/tasks.c **** 			{
1864:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1865:FreeRTOS/Source/tasks.c **** 				{
1866:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1867:FreeRTOS/Source/tasks.c **** 
1868:FreeRTOS/Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1869:FreeRTOS/Source/tasks.c **** 					suspended because this is inside a critical section. */
1870:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1871:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1872:FreeRTOS/Source/tasks.c **** 
1873:FreeRTOS/Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1874:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1875:FreeRTOS/Source/tasks.c **** 					{
1876:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1877:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1878:FreeRTOS/Source/tasks.c **** 						next yield. */
1879:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1880:FreeRTOS/Source/tasks.c **** 					}
1881:FreeRTOS/Source/tasks.c **** 					else
1882:FreeRTOS/Source/tasks.c **** 					{
1883:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1884:FreeRTOS/Source/tasks.c **** 					}
1885:FreeRTOS/Source/tasks.c **** 				}
1886:FreeRTOS/Source/tasks.c **** 				else
1887:FreeRTOS/Source/tasks.c **** 				{
1888:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1889:FreeRTOS/Source/tasks.c **** 				}
1890:FreeRTOS/Source/tasks.c **** 			}
1891:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1892:FreeRTOS/Source/tasks.c **** 		}
1893:FreeRTOS/Source/tasks.c **** 		else
1894:FreeRTOS/Source/tasks.c **** 		{
1895:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1896:FreeRTOS/Source/tasks.c **** 		}
1897:FreeRTOS/Source/tasks.c **** 	}
1898:FreeRTOS/Source/tasks.c **** 
1899:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1900:FreeRTOS/Source/tasks.c **** 
1901:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1902:FreeRTOS/Source/tasks.c **** 
1903:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1904:FreeRTOS/Source/tasks.c **** 
1905:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1906:FreeRTOS/Source/tasks.c **** 	{
1907:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1908:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1909:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1910:FreeRTOS/Source/tasks.c **** 
1911:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1912:FreeRTOS/Source/tasks.c **** 
1913:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1914:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1915:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1916:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1917:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1918:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1919:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1920:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1921:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1922:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1923:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1924:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1925:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1926:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1927:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1928:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1929:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1930:FreeRTOS/Source/tasks.c **** 
1931:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1932:FreeRTOS/Source/tasks.c **** 		{
1933:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1934:FreeRTOS/Source/tasks.c **** 			{
1935:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1936:FreeRTOS/Source/tasks.c **** 
1937:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1938:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1939:FreeRTOS/Source/tasks.c **** 				{
1940:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1941:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1942:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1943:FreeRTOS/Source/tasks.c **** 					{
1944:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1945:FreeRTOS/Source/tasks.c **** 					}
1946:FreeRTOS/Source/tasks.c **** 					else
1947:FreeRTOS/Source/tasks.c **** 					{
1948:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1949:FreeRTOS/Source/tasks.c **** 					}
1950:FreeRTOS/Source/tasks.c **** 
1951:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1952:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1953:FreeRTOS/Source/tasks.c **** 				}
1954:FreeRTOS/Source/tasks.c **** 				else
1955:FreeRTOS/Source/tasks.c **** 				{
1956:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1957:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1958:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1959:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1960:FreeRTOS/Source/tasks.c **** 				}
1961:FreeRTOS/Source/tasks.c **** 			}
1962:FreeRTOS/Source/tasks.c **** 			else
1963:FreeRTOS/Source/tasks.c **** 			{
1964:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1965:FreeRTOS/Source/tasks.c **** 			}
1966:FreeRTOS/Source/tasks.c **** 		}
1967:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1968:FreeRTOS/Source/tasks.c **** 
1969:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1970:FreeRTOS/Source/tasks.c **** 	}
1971:FreeRTOS/Source/tasks.c **** 
1972:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1973:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1974:FreeRTOS/Source/tasks.c **** 
1975:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1976:FreeRTOS/Source/tasks.c **** {
1977:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1978:FreeRTOS/Source/tasks.c **** 
1979:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1980:FreeRTOS/Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1981:FreeRTOS/Source/tasks.c **** 	{
1982:FreeRTOS/Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1983:FreeRTOS/Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1984:FreeRTOS/Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1985:FreeRTOS/Source/tasks.c **** 
1986:FreeRTOS/Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1987:FreeRTOS/Source/tasks.c **** 		address of the RAM then create the idle task. */
1988:FreeRTOS/Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1989:FreeRTOS/Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1990:FreeRTOS/Source/tasks.c **** 												configIDLE_TASK_NAME,
1991:FreeRTOS/Source/tasks.c **** 												ulIdleTaskStackSize,
1992:FreeRTOS/Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1993:FreeRTOS/Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1994:FreeRTOS/Source/tasks.c **** 												pxIdleTaskStackBuffer,
1995:FreeRTOS/Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1996:FreeRTOS/Source/tasks.c **** 
1997:FreeRTOS/Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1998:FreeRTOS/Source/tasks.c **** 		{
1999:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
2000:FreeRTOS/Source/tasks.c **** 		}
2001:FreeRTOS/Source/tasks.c **** 		else
2002:FreeRTOS/Source/tasks.c **** 		{
2003:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2004:FreeRTOS/Source/tasks.c **** 		}
2005:FreeRTOS/Source/tasks.c **** 	}
2006:FreeRTOS/Source/tasks.c **** 	#else
2007:FreeRTOS/Source/tasks.c **** 	{
2008:FreeRTOS/Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
2009:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
2010:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
2011:FreeRTOS/Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
2012:FreeRTOS/Source/tasks.c **** 								( void * ) NULL,
2013:FreeRTOS/Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
2014:FreeRTOS/Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
2015:FreeRTOS/Source/tasks.c **** 	}
2016:FreeRTOS/Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
2017:FreeRTOS/Source/tasks.c **** 
2018:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
2019:FreeRTOS/Source/tasks.c **** 	{
2020:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
2021:FreeRTOS/Source/tasks.c **** 		{
2022:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
2023:FreeRTOS/Source/tasks.c **** 		}
2024:FreeRTOS/Source/tasks.c **** 		else
2025:FreeRTOS/Source/tasks.c **** 		{
2026:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2027:FreeRTOS/Source/tasks.c **** 		}
2028:FreeRTOS/Source/tasks.c **** 	}
2029:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
2030:FreeRTOS/Source/tasks.c **** 
2031:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
2032:FreeRTOS/Source/tasks.c **** 	{
2033:FreeRTOS/Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
2034:FreeRTOS/Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
2035:FreeRTOS/Source/tasks.c **** 		the only macro called by the function. */
2036:FreeRTOS/Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2037:FreeRTOS/Source/tasks.c **** 		{
2038:FreeRTOS/Source/tasks.c **** 			freertos_tasks_c_additions_init();
2039:FreeRTOS/Source/tasks.c **** 		}
2040:FreeRTOS/Source/tasks.c **** 		#endif
2041:FreeRTOS/Source/tasks.c **** 
2042:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2043:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2044:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2045:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2046:FreeRTOS/Source/tasks.c **** 		starts to run. */
2047:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2048:FreeRTOS/Source/tasks.c **** 
2049:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2050:FreeRTOS/Source/tasks.c **** 		{
2051:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2052:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first.
2053:FreeRTOS/Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
2054:FreeRTOS/Source/tasks.c **** 			for additional information. */
2055:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2056:FreeRTOS/Source/tasks.c **** 		}
2057:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2058:FreeRTOS/Source/tasks.c **** 
2059:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
2060:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
2061:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2062:FreeRTOS/Source/tasks.c **** 
2063:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2064:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2065:FreeRTOS/Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2066:FreeRTOS/Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2067:FreeRTOS/Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2068:FreeRTOS/Source/tasks.c **** 		FreeRTOSConfig.h file. */
2069:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2070:FreeRTOS/Source/tasks.c **** 
2071:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2072:FreeRTOS/Source/tasks.c **** 
2073:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2074:FreeRTOS/Source/tasks.c **** 		portable interface. */
2075:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2076:FreeRTOS/Source/tasks.c **** 		{
2077:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2078:FreeRTOS/Source/tasks.c **** 			function will not return. */
2079:FreeRTOS/Source/tasks.c **** 		}
2080:FreeRTOS/Source/tasks.c **** 		else
2081:FreeRTOS/Source/tasks.c **** 		{
2082:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2083:FreeRTOS/Source/tasks.c **** 		}
2084:FreeRTOS/Source/tasks.c **** 	}
2085:FreeRTOS/Source/tasks.c **** 	else
2086:FreeRTOS/Source/tasks.c **** 	{
2087:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2088:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2089:FreeRTOS/Source/tasks.c **** 		or the timer task. */
2090:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2091:FreeRTOS/Source/tasks.c **** 	}
2092:FreeRTOS/Source/tasks.c **** 
2093:FreeRTOS/Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2094:FreeRTOS/Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2095:FreeRTOS/Source/tasks.c **** 	( void ) xIdleTaskHandle;
2096:FreeRTOS/Source/tasks.c **** }
2097:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2098:FreeRTOS/Source/tasks.c **** 
2099:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2100:FreeRTOS/Source/tasks.c **** {
2101:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2102:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2103:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2104:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2105:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
2106:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
2107:FreeRTOS/Source/tasks.c **** }
2108:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2109:FreeRTOS/Source/tasks.c **** 
2110:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2111:FreeRTOS/Source/tasks.c **** {
2112:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2113:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2114:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2115:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
2116:FreeRTOS/Source/tasks.c **** 
2117:FreeRTOS/Source/tasks.c **** 	/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
2118:FreeRTOS/Source/tasks.c **** 	do not otherwise exhibit real time behaviour. */
2119:FreeRTOS/Source/tasks.c **** 	portSOFTWARE_BARRIER();
2120:FreeRTOS/Source/tasks.c **** 
2121:FreeRTOS/Source/tasks.c **** 	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
2122:FreeRTOS/Source/tasks.c **** 	is used to allow calls to vTaskSuspendAll() to nest. */
2123:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
2124:FreeRTOS/Source/tasks.c **** 
2125:FreeRTOS/Source/tasks.c **** 	/* Enforces ordering for ports and optimised compilers that may otherwise place
2126:FreeRTOS/Source/tasks.c **** 	the above increment elsewhere. */
2127:FreeRTOS/Source/tasks.c **** 	portMEMORY_BARRIER();
2128:FreeRTOS/Source/tasks.c **** }
2129:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2130:FreeRTOS/Source/tasks.c **** 
2131:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2132:FreeRTOS/Source/tasks.c **** 
2133:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2134:FreeRTOS/Source/tasks.c **** 	{
2135:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
2136:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2137:FreeRTOS/Source/tasks.c **** 
2138:FreeRTOS/Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2139:FreeRTOS/Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2140:FreeRTOS/Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2141:FreeRTOS/Source/tasks.c **** 		running. */
2142:FreeRTOS/Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2143:FreeRTOS/Source/tasks.c **** 		{
2144:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2145:FreeRTOS/Source/tasks.c **** 			{
2146:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2147:FreeRTOS/Source/tasks.c **** 			}
2148:FreeRTOS/Source/tasks.c **** 		}
2149:FreeRTOS/Source/tasks.c **** 		#else
2150:FreeRTOS/Source/tasks.c **** 		{
2151:FreeRTOS/Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2152:FreeRTOS/Source/tasks.c **** 
2153:FreeRTOS/Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2154:FreeRTOS/Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2155:FreeRTOS/Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2156:FreeRTOS/Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2157:FreeRTOS/Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2158:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2159:FreeRTOS/Source/tasks.c **** 			{
2160:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2161:FreeRTOS/Source/tasks.c **** 			}
2162:FreeRTOS/Source/tasks.c **** 		}
2163:FreeRTOS/Source/tasks.c **** 		#endif
2164:FreeRTOS/Source/tasks.c **** 
2165:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2166:FreeRTOS/Source/tasks.c **** 		{
2167:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2168:FreeRTOS/Source/tasks.c **** 		}
2169:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2170:FreeRTOS/Source/tasks.c **** 		{
2171:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2172:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2173:FreeRTOS/Source/tasks.c **** 			processed. */
2174:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2175:FreeRTOS/Source/tasks.c **** 		}
2176:FreeRTOS/Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2177:FreeRTOS/Source/tasks.c **** 		{
2178:FreeRTOS/Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2179:FreeRTOS/Source/tasks.c **** 			idle priority.  This path can only be reached if
2180:FreeRTOS/Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2181:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2182:FreeRTOS/Source/tasks.c **** 		}
2183:FreeRTOS/Source/tasks.c **** 		else
2184:FreeRTOS/Source/tasks.c **** 		{
2185:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2186:FreeRTOS/Source/tasks.c **** 		}
2187:FreeRTOS/Source/tasks.c **** 
2188:FreeRTOS/Source/tasks.c **** 		return xReturn;
2189:FreeRTOS/Source/tasks.c **** 	}
2190:FreeRTOS/Source/tasks.c **** 
2191:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2192:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2193:FreeRTOS/Source/tasks.c **** 
2194:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2195:FreeRTOS/Source/tasks.c **** {
2196:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
2197:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2198:FreeRTOS/Source/tasks.c **** 
2199:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2200:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2201:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2202:FreeRTOS/Source/tasks.c **** 
2203:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2204:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2205:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2206:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2207:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2208:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2209:FreeRTOS/Source/tasks.c **** 	{
2210:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
2211:FreeRTOS/Source/tasks.c **** 
2212:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2213:FreeRTOS/Source/tasks.c **** 		{
2214:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2215:FreeRTOS/Source/tasks.c **** 			{
2216:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2217:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
2218:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2219:FreeRTOS/Source/tasks.c **** 				{
2220:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
2221:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2222:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2223:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2224:FreeRTOS/Source/tasks.c **** 
2225:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2226:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
2227:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2228:FreeRTOS/Source/tasks.c **** 					{
2229:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2230:FreeRTOS/Source/tasks.c **** 					}
2231:FreeRTOS/Source/tasks.c **** 					else
2232:FreeRTOS/Source/tasks.c **** 					{
2233:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2234:FreeRTOS/Source/tasks.c **** 					}
2235:FreeRTOS/Source/tasks.c **** 				}
2236:FreeRTOS/Source/tasks.c **** 
2237:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2238:FreeRTOS/Source/tasks.c **** 				{
2239:FreeRTOS/Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2240:FreeRTOS/Source/tasks.c **** 					which may have prevented the next unblock time from being
2241:FreeRTOS/Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2242:FreeRTOS/Source/tasks.c **** 					important for low power tickless implementations, where
2243:FreeRTOS/Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2244:FreeRTOS/Source/tasks.c **** 					state. */
2245:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
2246:FreeRTOS/Source/tasks.c **** 				}
2247:FreeRTOS/Source/tasks.c **** 
2248:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2249:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2250:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2251:FreeRTOS/Source/tasks.c **** 				time. */
2252:FreeRTOS/Source/tasks.c **** 				{
2253:FreeRTOS/Source/tasks.c **** 					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
2254:FreeRTOS/Source/tasks.c **** 
2255:FreeRTOS/Source/tasks.c **** 					if( xPendedCounts > ( TickType_t ) 0U )
2256:FreeRTOS/Source/tasks.c **** 					{
2257:FreeRTOS/Source/tasks.c **** 						do
2258:FreeRTOS/Source/tasks.c **** 						{
2259:FreeRTOS/Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2260:FreeRTOS/Source/tasks.c **** 							{
2261:FreeRTOS/Source/tasks.c **** 								xYieldPending = pdTRUE;
2262:FreeRTOS/Source/tasks.c **** 							}
2263:FreeRTOS/Source/tasks.c **** 							else
2264:FreeRTOS/Source/tasks.c **** 							{
2265:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2266:FreeRTOS/Source/tasks.c **** 							}
2267:FreeRTOS/Source/tasks.c **** 							--xPendedCounts;
2268:FreeRTOS/Source/tasks.c **** 						} while( xPendedCounts > ( TickType_t ) 0U );
2269:FreeRTOS/Source/tasks.c **** 
2270:FreeRTOS/Source/tasks.c **** 						xPendedTicks = 0;
2271:FreeRTOS/Source/tasks.c **** 					}
2272:FreeRTOS/Source/tasks.c **** 					else
2273:FreeRTOS/Source/tasks.c **** 					{
2274:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2275:FreeRTOS/Source/tasks.c **** 					}
2276:FreeRTOS/Source/tasks.c **** 				}
2277:FreeRTOS/Source/tasks.c **** 
2278:FreeRTOS/Source/tasks.c **** 				if( xYieldPending != pdFALSE )
2279:FreeRTOS/Source/tasks.c **** 				{
2280:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2281:FreeRTOS/Source/tasks.c **** 					{
2282:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
2283:FreeRTOS/Source/tasks.c **** 					}
2284:FreeRTOS/Source/tasks.c **** 					#endif
2285:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2286:FreeRTOS/Source/tasks.c **** 				}
2287:FreeRTOS/Source/tasks.c **** 				else
2288:FreeRTOS/Source/tasks.c **** 				{
2289:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2290:FreeRTOS/Source/tasks.c **** 				}
2291:FreeRTOS/Source/tasks.c **** 			}
2292:FreeRTOS/Source/tasks.c **** 		}
2293:FreeRTOS/Source/tasks.c **** 		else
2294:FreeRTOS/Source/tasks.c **** 		{
2295:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2296:FreeRTOS/Source/tasks.c **** 		}
2297:FreeRTOS/Source/tasks.c **** 	}
2298:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2299:FreeRTOS/Source/tasks.c **** 
2300:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
2301:FreeRTOS/Source/tasks.c **** }
2302:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2303:FreeRTOS/Source/tasks.c **** 
2304:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2305:FreeRTOS/Source/tasks.c **** {
2306:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
2307:FreeRTOS/Source/tasks.c **** 
2308:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2309:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2310:FreeRTOS/Source/tasks.c **** 	{
2311:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
2312:FreeRTOS/Source/tasks.c **** 	}
2313:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2314:FreeRTOS/Source/tasks.c **** 
2315:FreeRTOS/Source/tasks.c **** 	return xTicks;
2316:FreeRTOS/Source/tasks.c **** }
2317:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2318:FreeRTOS/Source/tasks.c **** 
2319:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2320:FreeRTOS/Source/tasks.c **** {
2321:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
2322:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2323:FreeRTOS/Source/tasks.c **** 
2324:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2325:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2326:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2327:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2328:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2329:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2330:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2331:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2332:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2333:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2334:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2335:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2336:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2337:FreeRTOS/Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2338:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2341:FreeRTOS/Source/tasks.c **** 	{
2342:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
2343:FreeRTOS/Source/tasks.c **** 	}
2344:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2345:FreeRTOS/Source/tasks.c **** 
2346:FreeRTOS/Source/tasks.c **** 	return xReturn;
2347:FreeRTOS/Source/tasks.c **** }
2348:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2349:FreeRTOS/Source/tasks.c **** 
2350:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2351:FreeRTOS/Source/tasks.c **** {
2352:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2353:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
2354:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
2355:FreeRTOS/Source/tasks.c **** }
2356:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2357:FreeRTOS/Source/tasks.c **** 
2358:FreeRTOS/Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2359:FreeRTOS/Source/tasks.c **** {
2360:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
2361:FreeRTOS/Source/tasks.c **** 
2362:FreeRTOS/Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2363:FreeRTOS/Source/tasks.c **** 	queried. */
2364:FreeRTOS/Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2365:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
2366:FreeRTOS/Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2367:FreeRTOS/Source/tasks.c **** }
2368:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2369:FreeRTOS/Source/tasks.c **** 
2370:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2371:FreeRTOS/Source/tasks.c **** 
2372:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2373:FreeRTOS/Source/tasks.c **** 	{
2374:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2375:FreeRTOS/Source/tasks.c **** 	UBaseType_t x;
2376:FreeRTOS/Source/tasks.c **** 	char cNextChar;
2377:FreeRTOS/Source/tasks.c **** 	BaseType_t xBreakLoop;
2378:FreeRTOS/Source/tasks.c **** 
2379:FreeRTOS/Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2380:FreeRTOS/Source/tasks.c **** 
2381:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2382:FreeRTOS/Source/tasks.c **** 		{
2383:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2384:FreeRTOS/Source/tasks.c **** 
2385:FreeRTOS/Source/tasks.c **** 			do
2386:FreeRTOS/Source/tasks.c **** 			{
2387:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** 				/* Check each character in the name looking for a match or
2390:FreeRTOS/Source/tasks.c **** 				mismatch. */
2391:FreeRTOS/Source/tasks.c **** 				xBreakLoop = pdFALSE;
2392:FreeRTOS/Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2393:FreeRTOS/Source/tasks.c **** 				{
2394:FreeRTOS/Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2395:FreeRTOS/Source/tasks.c **** 
2396:FreeRTOS/Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2397:FreeRTOS/Source/tasks.c **** 					{
2398:FreeRTOS/Source/tasks.c **** 						/* Characters didn't match. */
2399:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2400:FreeRTOS/Source/tasks.c **** 					}
2401:FreeRTOS/Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2402:FreeRTOS/Source/tasks.c **** 					{
2403:FreeRTOS/Source/tasks.c **** 						/* Both strings terminated, a match must have been
2404:FreeRTOS/Source/tasks.c **** 						found. */
2405:FreeRTOS/Source/tasks.c **** 						pxReturn = pxNextTCB;
2406:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2407:FreeRTOS/Source/tasks.c **** 					}
2408:FreeRTOS/Source/tasks.c **** 					else
2409:FreeRTOS/Source/tasks.c **** 					{
2410:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2411:FreeRTOS/Source/tasks.c **** 					}
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2414:FreeRTOS/Source/tasks.c **** 					{
2415:FreeRTOS/Source/tasks.c **** 						break;
2416:FreeRTOS/Source/tasks.c **** 					}
2417:FreeRTOS/Source/tasks.c **** 				}
2418:FreeRTOS/Source/tasks.c **** 
2419:FreeRTOS/Source/tasks.c **** 				if( pxReturn != NULL )
2420:FreeRTOS/Source/tasks.c **** 				{
2421:FreeRTOS/Source/tasks.c **** 					/* The handle has been found. */
2422:FreeRTOS/Source/tasks.c **** 					break;
2423:FreeRTOS/Source/tasks.c **** 				}
2424:FreeRTOS/Source/tasks.c **** 
2425:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2426:FreeRTOS/Source/tasks.c **** 		}
2427:FreeRTOS/Source/tasks.c **** 		else
2428:FreeRTOS/Source/tasks.c **** 		{
2429:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2430:FreeRTOS/Source/tasks.c **** 		}
2431:FreeRTOS/Source/tasks.c **** 
2432:FreeRTOS/Source/tasks.c **** 		return pxReturn;
2433:FreeRTOS/Source/tasks.c **** 	}
2434:FreeRTOS/Source/tasks.c **** 
2435:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2436:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2437:FreeRTOS/Source/tasks.c **** 
2438:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2439:FreeRTOS/Source/tasks.c **** 
2440:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2441:FreeRTOS/Source/tasks.c **** 	{
2442:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2443:FreeRTOS/Source/tasks.c **** 	TCB_t* pxTCB;
2444:FreeRTOS/Source/tasks.c **** 
2445:FreeRTOS/Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2446:FreeRTOS/Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2447:FreeRTOS/Source/tasks.c **** 
2448:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2449:FreeRTOS/Source/tasks.c **** 		{
2450:FreeRTOS/Source/tasks.c **** 			/* Search the ready lists. */
2451:FreeRTOS/Source/tasks.c **** 			do
2452:FreeRTOS/Source/tasks.c **** 			{
2453:FreeRTOS/Source/tasks.c **** 				uxQueue--;
2454:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2455:FreeRTOS/Source/tasks.c **** 
2456:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2457:FreeRTOS/Source/tasks.c **** 				{
2458:FreeRTOS/Source/tasks.c **** 					/* Found the handle. */
2459:FreeRTOS/Source/tasks.c **** 					break;
2460:FreeRTOS/Source/tasks.c **** 				}
2461:FreeRTOS/Source/tasks.c **** 
2462:FreeRTOS/Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2463:FreeRTOS/Source/tasks.c **** 
2464:FreeRTOS/Source/tasks.c **** 			/* Search the delayed lists. */
2465:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2466:FreeRTOS/Source/tasks.c **** 			{
2467:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2468:FreeRTOS/Source/tasks.c **** 			}
2469:FreeRTOS/Source/tasks.c **** 
2470:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2471:FreeRTOS/Source/tasks.c **** 			{
2472:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2473:FreeRTOS/Source/tasks.c **** 			}
2474:FreeRTOS/Source/tasks.c **** 
2475:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2476:FreeRTOS/Source/tasks.c **** 			{
2477:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2478:FreeRTOS/Source/tasks.c **** 				{
2479:FreeRTOS/Source/tasks.c **** 					/* Search the suspended list. */
2480:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2481:FreeRTOS/Source/tasks.c **** 				}
2482:FreeRTOS/Source/tasks.c **** 			}
2483:FreeRTOS/Source/tasks.c **** 			#endif
2484:FreeRTOS/Source/tasks.c **** 
2485:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2486:FreeRTOS/Source/tasks.c **** 			{
2487:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2488:FreeRTOS/Source/tasks.c **** 				{
2489:FreeRTOS/Source/tasks.c **** 					/* Search the deleted list. */
2490:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2491:FreeRTOS/Source/tasks.c **** 				}
2492:FreeRTOS/Source/tasks.c **** 			}
2493:FreeRTOS/Source/tasks.c **** 			#endif
2494:FreeRTOS/Source/tasks.c **** 		}
2495:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2496:FreeRTOS/Source/tasks.c **** 
2497:FreeRTOS/Source/tasks.c **** 		return pxTCB;
2498:FreeRTOS/Source/tasks.c **** 	}
2499:FreeRTOS/Source/tasks.c **** 
2500:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2501:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2502:FreeRTOS/Source/tasks.c **** 
2503:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2504:FreeRTOS/Source/tasks.c **** 
2505:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2506:FreeRTOS/Source/tasks.c **** 	{
2507:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2508:FreeRTOS/Source/tasks.c **** 
2509:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2510:FreeRTOS/Source/tasks.c **** 		{
2511:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2512:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2513:FreeRTOS/Source/tasks.c **** 			{
2514:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2515:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
2516:FreeRTOS/Source/tasks.c **** 				do
2517:FreeRTOS/Source/tasks.c **** 				{
2518:FreeRTOS/Source/tasks.c **** 					uxQueue--;
2519:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2520:FreeRTOS/Source/tasks.c **** 
2521:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2522:FreeRTOS/Source/tasks.c **** 
2523:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2524:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
2525:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2526:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2527:FreeRTOS/Source/tasks.c **** 
2528:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2529:FreeRTOS/Source/tasks.c **** 				{
2530:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2531:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2532:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2533:FreeRTOS/Source/tasks.c **** 				}
2534:FreeRTOS/Source/tasks.c **** 				#endif
2535:FreeRTOS/Source/tasks.c **** 
2536:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2537:FreeRTOS/Source/tasks.c **** 				{
2538:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2539:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
2540:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2541:FreeRTOS/Source/tasks.c **** 				}
2542:FreeRTOS/Source/tasks.c **** 				#endif
2543:FreeRTOS/Source/tasks.c **** 
2544:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2545:FreeRTOS/Source/tasks.c **** 				{
2546:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2547:FreeRTOS/Source/tasks.c **** 					{
2548:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2549:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2550:FreeRTOS/Source/tasks.c **** 						#else
2551:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2552:FreeRTOS/Source/tasks.c **** 						#endif
2553:FreeRTOS/Source/tasks.c **** 					}
2554:FreeRTOS/Source/tasks.c **** 				}
2555:FreeRTOS/Source/tasks.c **** 				#else
2556:FreeRTOS/Source/tasks.c **** 				{
2557:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2558:FreeRTOS/Source/tasks.c **** 					{
2559:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
2560:FreeRTOS/Source/tasks.c **** 					}
2561:FreeRTOS/Source/tasks.c **** 				}
2562:FreeRTOS/Source/tasks.c **** 				#endif
2563:FreeRTOS/Source/tasks.c **** 			}
2564:FreeRTOS/Source/tasks.c **** 			else
2565:FreeRTOS/Source/tasks.c **** 			{
2566:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2567:FreeRTOS/Source/tasks.c **** 			}
2568:FreeRTOS/Source/tasks.c **** 		}
2569:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2570:FreeRTOS/Source/tasks.c **** 
2571:FreeRTOS/Source/tasks.c **** 		return uxTask;
2572:FreeRTOS/Source/tasks.c **** 	}
2573:FreeRTOS/Source/tasks.c **** 
2574:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2575:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2576:FreeRTOS/Source/tasks.c **** 
2577:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2578:FreeRTOS/Source/tasks.c **** 
2579:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2580:FreeRTOS/Source/tasks.c **** 	{
2581:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2582:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2583:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2584:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
2585:FreeRTOS/Source/tasks.c **** 	}
2586:FreeRTOS/Source/tasks.c **** 
2587:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2588:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2589:FreeRTOS/Source/tasks.c **** 
2590:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2591:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2592:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2593:FreeRTOS/Source/tasks.c **** 1. */
2594:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2595:FreeRTOS/Source/tasks.c **** 
2596:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2597:FreeRTOS/Source/tasks.c **** 	{
2598:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2599:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2600:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
2601:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2602:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
2603:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2604:FreeRTOS/Source/tasks.c **** 	}
2605:FreeRTOS/Source/tasks.c **** 
2606:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2607:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2608:FreeRTOS/Source/tasks.c **** 
2609:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
2610:FreeRTOS/Source/tasks.c **** {
2611:FreeRTOS/Source/tasks.c **** BaseType_t xYieldRequired = pdFALSE;
2612:FreeRTOS/Source/tasks.c **** 
2613:FreeRTOS/Source/tasks.c **** 	/* Must not be called with the scheduler suspended as the implementation
2614:FreeRTOS/Source/tasks.c **** 	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
2615:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended == 0 );
2616:FreeRTOS/Source/tasks.c **** 
2617:FreeRTOS/Source/tasks.c **** 	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
2618:FreeRTOS/Source/tasks.c **** 	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
2619:FreeRTOS/Source/tasks.c **** 	vTaskSuspendAll();
2620:FreeRTOS/Source/tasks.c **** 	xPendedTicks += xTicksToCatchUp;
2621:FreeRTOS/Source/tasks.c **** 	xYieldRequired = xTaskResumeAll();
2622:FreeRTOS/Source/tasks.c **** 
2623:FreeRTOS/Source/tasks.c **** 	return xYieldRequired;
2624:FreeRTOS/Source/tasks.c **** }
2625:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2626:FreeRTOS/Source/tasks.c **** 
2627:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2628:FreeRTOS/Source/tasks.c **** 
2629:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2630:FreeRTOS/Source/tasks.c **** 	{
2631:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2632:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2633:FreeRTOS/Source/tasks.c **** 
2634:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
2635:FreeRTOS/Source/tasks.c **** 
2636:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2637:FreeRTOS/Source/tasks.c **** 		{
2638:FreeRTOS/Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2639:FreeRTOS/Source/tasks.c **** 			it is actually in the Blocked state. */
2640:FreeRTOS/Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2641:FreeRTOS/Source/tasks.c **** 			{
2642:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
2643:FreeRTOS/Source/tasks.c **** 
2644:FreeRTOS/Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2645:FreeRTOS/Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2646:FreeRTOS/Source/tasks.c **** 				scheduler is suspended. */
2647:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2648:FreeRTOS/Source/tasks.c **** 
2649:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2650:FreeRTOS/Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2651:FreeRTOS/Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2652:FreeRTOS/Source/tasks.c **** 				is used. */
2653:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2654:FreeRTOS/Source/tasks.c **** 				{
2655:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2656:FreeRTOS/Source/tasks.c **** 					{
2657:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2658:FreeRTOS/Source/tasks.c **** 
2659:FreeRTOS/Source/tasks.c **** 						/* This lets the task know it was forcibly removed from the
2660:FreeRTOS/Source/tasks.c **** 						blocked state so it should not re-evaluate its block time and
2661:FreeRTOS/Source/tasks.c **** 						then block again. */
2662:FreeRTOS/Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2663:FreeRTOS/Source/tasks.c **** 					}
2664:FreeRTOS/Source/tasks.c **** 					else
2665:FreeRTOS/Source/tasks.c **** 					{
2666:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2667:FreeRTOS/Source/tasks.c **** 					}
2668:FreeRTOS/Source/tasks.c **** 				}
2669:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2670:FreeRTOS/Source/tasks.c **** 
2671:FreeRTOS/Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2672:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2673:FreeRTOS/Source/tasks.c **** 
2674:FreeRTOS/Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2675:FreeRTOS/Source/tasks.c **** 				switch if preemption is turned off. */
2676:FreeRTOS/Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2677:FreeRTOS/Source/tasks.c **** 				{
2678:FreeRTOS/Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2679:FreeRTOS/Source/tasks.c **** 					performed if the unblocked task has a priority that is
2680:FreeRTOS/Source/tasks.c **** 					equal to or higher than the currently executing task. */
2681:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2682:FreeRTOS/Source/tasks.c **** 					{
2683:FreeRTOS/Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2684:FreeRTOS/Source/tasks.c **** 						is unsuspended. */
2685:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2686:FreeRTOS/Source/tasks.c **** 					}
2687:FreeRTOS/Source/tasks.c **** 					else
2688:FreeRTOS/Source/tasks.c **** 					{
2689:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2690:FreeRTOS/Source/tasks.c **** 					}
2691:FreeRTOS/Source/tasks.c **** 				}
2692:FreeRTOS/Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2693:FreeRTOS/Source/tasks.c **** 			}
2694:FreeRTOS/Source/tasks.c **** 			else
2695:FreeRTOS/Source/tasks.c **** 			{
2696:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
2697:FreeRTOS/Source/tasks.c **** 			}
2698:FreeRTOS/Source/tasks.c **** 		}
2699:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2700:FreeRTOS/Source/tasks.c **** 
2701:FreeRTOS/Source/tasks.c **** 		return xReturn;
2702:FreeRTOS/Source/tasks.c **** 	}
2703:FreeRTOS/Source/tasks.c **** 
2704:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2705:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2706:FreeRTOS/Source/tasks.c **** 
2707:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2708:FreeRTOS/Source/tasks.c **** {
2709:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
2710:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
2711:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2712:FreeRTOS/Source/tasks.c **** 
2713:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2714:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2715:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
2716:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2717:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2718:FreeRTOS/Source/tasks.c **** 	{
2719:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2720:FreeRTOS/Source/tasks.c **** 		block. */
2721:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2722:FreeRTOS/Source/tasks.c **** 
2723:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2724:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
2725:FreeRTOS/Source/tasks.c **** 		xTickCount = xConstTickCount;
2726:FreeRTOS/Source/tasks.c **** 
2727:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2728:FreeRTOS/Source/tasks.c **** 		{
2729:FreeRTOS/Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2730:FreeRTOS/Source/tasks.c **** 		}
2731:FreeRTOS/Source/tasks.c **** 		else
2732:FreeRTOS/Source/tasks.c **** 		{
2733:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2734:FreeRTOS/Source/tasks.c **** 		}
2735:FreeRTOS/Source/tasks.c **** 
2736:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2737:FreeRTOS/Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2738:FreeRTOS/Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2739:FreeRTOS/Source/tasks.c **** 		look any further down the list. */
2740:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2741:FreeRTOS/Source/tasks.c **** 		{
2742:FreeRTOS/Source/tasks.c **** 			for( ;; )
2743:FreeRTOS/Source/tasks.c **** 			{
2744:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2745:FreeRTOS/Source/tasks.c **** 				{
2746:FreeRTOS/Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2747:FreeRTOS/Source/tasks.c **** 					to the maximum possible value so it is extremely
2748:FreeRTOS/Source/tasks.c **** 					unlikely that the
2749:FreeRTOS/Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2750:FreeRTOS/Source/tasks.c **** 					next time through. */
2751:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2752:FreeRTOS/Source/tasks.c **** 					break;
2753:FreeRTOS/Source/tasks.c **** 				}
2754:FreeRTOS/Source/tasks.c **** 				else
2755:FreeRTOS/Source/tasks.c **** 				{
2756:FreeRTOS/Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2757:FreeRTOS/Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2758:FreeRTOS/Source/tasks.c **** 					at which the task at the head of the delayed list must
2759:FreeRTOS/Source/tasks.c **** 					be removed from the Blocked state. */
2760:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
2761:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2762:FreeRTOS/Source/tasks.c **** 
2763:FreeRTOS/Source/tasks.c **** 					if( xConstTickCount < xItemValue )
2764:FreeRTOS/Source/tasks.c **** 					{
2765:FreeRTOS/Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2766:FreeRTOS/Source/tasks.c **** 						item value is the time at which the task at the head
2767:FreeRTOS/Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2768:FreeRTOS/Source/tasks.c **** 						state -	so record the item value in
2769:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime. */
2770:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2771:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
2772:FreeRTOS/Source/tasks.c **** 					}
2773:FreeRTOS/Source/tasks.c **** 					else
2774:FreeRTOS/Source/tasks.c **** 					{
2775:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2776:FreeRTOS/Source/tasks.c **** 					}
2777:FreeRTOS/Source/tasks.c **** 
2778:FreeRTOS/Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2779:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2780:FreeRTOS/Source/tasks.c **** 
2781:FreeRTOS/Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2782:FreeRTOS/Source/tasks.c **** 					it from the event list. */
2783:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2784:FreeRTOS/Source/tasks.c **** 					{
2785:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2786:FreeRTOS/Source/tasks.c **** 					}
2787:FreeRTOS/Source/tasks.c **** 					else
2788:FreeRTOS/Source/tasks.c **** 					{
2789:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2790:FreeRTOS/Source/tasks.c **** 					}
2791:FreeRTOS/Source/tasks.c **** 
2792:FreeRTOS/Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2793:FreeRTOS/Source/tasks.c **** 					list. */
2794:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2795:FreeRTOS/Source/tasks.c **** 
2796:FreeRTOS/Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2797:FreeRTOS/Source/tasks.c **** 					context switch if preemption is turned off. */
2798:FreeRTOS/Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2799:FreeRTOS/Source/tasks.c **** 					{
2800:FreeRTOS/Source/tasks.c **** 						/* Preemption is on, but a context switch should
2801:FreeRTOS/Source/tasks.c **** 						only be performed if the unblocked task has a
2802:FreeRTOS/Source/tasks.c **** 						priority that is equal to or higher than the
2803:FreeRTOS/Source/tasks.c **** 						currently executing task. */
2804:FreeRTOS/Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2805:FreeRTOS/Source/tasks.c **** 						{
2806:FreeRTOS/Source/tasks.c **** 							xSwitchRequired = pdTRUE;
2807:FreeRTOS/Source/tasks.c **** 						}
2808:FreeRTOS/Source/tasks.c **** 						else
2809:FreeRTOS/Source/tasks.c **** 						{
2810:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2811:FreeRTOS/Source/tasks.c **** 						}
2812:FreeRTOS/Source/tasks.c **** 					}
2813:FreeRTOS/Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2814:FreeRTOS/Source/tasks.c **** 				}
2815:FreeRTOS/Source/tasks.c **** 			}
2816:FreeRTOS/Source/tasks.c **** 		}
2817:FreeRTOS/Source/tasks.c **** 
2818:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2819:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2820:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2821:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2822:FreeRTOS/Source/tasks.c **** 		{
2823:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2824:FreeRTOS/Source/tasks.c **** 			{
2825:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2826:FreeRTOS/Source/tasks.c **** 			}
2827:FreeRTOS/Source/tasks.c **** 			else
2828:FreeRTOS/Source/tasks.c **** 			{
2829:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2830:FreeRTOS/Source/tasks.c **** 			}
2831:FreeRTOS/Source/tasks.c **** 		}
2832:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2833:FreeRTOS/Source/tasks.c **** 
2834:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2835:FreeRTOS/Source/tasks.c **** 		{
2836:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2837:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2838:FreeRTOS/Source/tasks.c **** 			if( xPendedTicks == ( TickType_t ) 0 )
2839:FreeRTOS/Source/tasks.c **** 			{
2840:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2841:FreeRTOS/Source/tasks.c **** 			}
2842:FreeRTOS/Source/tasks.c **** 			else
2843:FreeRTOS/Source/tasks.c **** 			{
2844:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2845:FreeRTOS/Source/tasks.c **** 			}
2846:FreeRTOS/Source/tasks.c **** 		}
2847:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2848:FreeRTOS/Source/tasks.c **** 
2849:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 1 )
2850:FreeRTOS/Source/tasks.c **** 		{
2851:FreeRTOS/Source/tasks.c **** 			if( xYieldPending != pdFALSE )
2852:FreeRTOS/Source/tasks.c **** 			{
2853:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2854:FreeRTOS/Source/tasks.c **** 			}
2855:FreeRTOS/Source/tasks.c **** 			else
2856:FreeRTOS/Source/tasks.c **** 			{
2857:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2858:FreeRTOS/Source/tasks.c **** 			}
2859:FreeRTOS/Source/tasks.c **** 		}
2860:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2861:FreeRTOS/Source/tasks.c **** 	}
2862:FreeRTOS/Source/tasks.c **** 	else
2863:FreeRTOS/Source/tasks.c **** 	{
2864:FreeRTOS/Source/tasks.c **** 		++xPendedTicks;
2865:FreeRTOS/Source/tasks.c **** 
2866:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2867:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2868:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2869:FreeRTOS/Source/tasks.c **** 		{
2870:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2871:FreeRTOS/Source/tasks.c **** 		}
2872:FreeRTOS/Source/tasks.c **** 		#endif
2873:FreeRTOS/Source/tasks.c **** 	}
2874:FreeRTOS/Source/tasks.c **** 
2875:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2876:FreeRTOS/Source/tasks.c **** }
2877:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2878:FreeRTOS/Source/tasks.c **** 
2879:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2880:FreeRTOS/Source/tasks.c **** 
2881:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2882:FreeRTOS/Source/tasks.c **** 	{
2883:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2884:FreeRTOS/Source/tasks.c **** 
2885:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2886:FreeRTOS/Source/tasks.c **** 		getting set. */
2887:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2888:FreeRTOS/Source/tasks.c **** 		{
2889:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2890:FreeRTOS/Source/tasks.c **** 		}
2891:FreeRTOS/Source/tasks.c **** 		else
2892:FreeRTOS/Source/tasks.c **** 		{
2893:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2894:FreeRTOS/Source/tasks.c **** 		}
2895:FreeRTOS/Source/tasks.c **** 
2896:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2897:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2898:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2899:FreeRTOS/Source/tasks.c **** 		{
2900:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2901:FreeRTOS/Source/tasks.c **** 		}
2902:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2903:FreeRTOS/Source/tasks.c **** 	}
2904:FreeRTOS/Source/tasks.c **** 
2905:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2906:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2907:FreeRTOS/Source/tasks.c **** 
2908:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2909:FreeRTOS/Source/tasks.c **** 
2910:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2911:FreeRTOS/Source/tasks.c **** 	{
2912:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2913:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2914:FreeRTOS/Source/tasks.c **** 
2915:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
2916:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2917:FreeRTOS/Source/tasks.c **** 
2918:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2919:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2920:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2921:FreeRTOS/Source/tasks.c **** 		{
2922:FreeRTOS/Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2923:FreeRTOS/Source/tasks.c **** 		}
2924:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2925:FreeRTOS/Source/tasks.c **** 
2926:FreeRTOS/Source/tasks.c **** 		return xReturn;
2927:FreeRTOS/Source/tasks.c **** 	}
2928:FreeRTOS/Source/tasks.c **** 
2929:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2930:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2931:FreeRTOS/Source/tasks.c **** 
2932:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2933:FreeRTOS/Source/tasks.c **** 
2934:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
2935:FreeRTOS/Source/tasks.c **** 	{
2936:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2937:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2938:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
2939:FreeRTOS/Source/tasks.c **** 
2940:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
2941:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2942:FreeRTOS/Source/tasks.c **** 
2943:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2944:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2945:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2946:FreeRTOS/Source/tasks.c **** 		{
2947:FreeRTOS/Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2948:FreeRTOS/Source/tasks.c **** 		}
2949:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2950:FreeRTOS/Source/tasks.c **** 
2951:FreeRTOS/Source/tasks.c **** 		return xReturn;
2952:FreeRTOS/Source/tasks.c **** 	}
2953:FreeRTOS/Source/tasks.c **** 
2954:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2955:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2956:FreeRTOS/Source/tasks.c **** 
2957:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2958:FreeRTOS/Source/tasks.c **** 
2959:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2960:FreeRTOS/Source/tasks.c **** 	{
2961:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2962:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2963:FreeRTOS/Source/tasks.c **** 
2964:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2965:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2966:FreeRTOS/Source/tasks.c **** 		{
2967:FreeRTOS/Source/tasks.c **** 			xTCB = pxCurrentTCB;
2968:FreeRTOS/Source/tasks.c **** 		}
2969:FreeRTOS/Source/tasks.c **** 		else
2970:FreeRTOS/Source/tasks.c **** 		{
2971:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2972:FreeRTOS/Source/tasks.c **** 		}
2973:FreeRTOS/Source/tasks.c **** 
2974:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2975:FreeRTOS/Source/tasks.c **** 		{
2976:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2977:FreeRTOS/Source/tasks.c **** 		}
2978:FreeRTOS/Source/tasks.c **** 		else
2979:FreeRTOS/Source/tasks.c **** 		{
2980:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2981:FreeRTOS/Source/tasks.c **** 		}
2982:FreeRTOS/Source/tasks.c **** 
2983:FreeRTOS/Source/tasks.c **** 		return xReturn;
2984:FreeRTOS/Source/tasks.c **** 	}
2985:FreeRTOS/Source/tasks.c **** 
2986:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2987:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2988:FreeRTOS/Source/tasks.c **** 
2989:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2990:FreeRTOS/Source/tasks.c **** {
2991:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2992:FreeRTOS/Source/tasks.c **** 	{
2993:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2994:FreeRTOS/Source/tasks.c **** 		switch. */
2995:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2996:FreeRTOS/Source/tasks.c **** 	}
2997:FreeRTOS/Source/tasks.c **** 	else
2998:FreeRTOS/Source/tasks.c **** 	{
2999:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
3000:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
3001:FreeRTOS/Source/tasks.c **** 
3002:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3003:FreeRTOS/Source/tasks.c **** 		{
3004:FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
3005:FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
3006:FreeRTOS/Source/tasks.c **** 			#else
3007:FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
3008:FreeRTOS/Source/tasks.c **** 			#endif
3009:FreeRTOS/Source/tasks.c **** 
3010:FreeRTOS/Source/tasks.c **** 			/* Add the amount of time the task has been running to the
3011:FreeRTOS/Source/tasks.c **** 			accumulated time so far.  The time the task started running was
3012:FreeRTOS/Source/tasks.c **** 			stored in ulTaskSwitchedInTime.  Note that there is no overflow
3013:FreeRTOS/Source/tasks.c **** 			protection here so count values are only valid until the timer
3014:FreeRTOS/Source/tasks.c **** 			overflows.  The guard against negative values is to protect
3015:FreeRTOS/Source/tasks.c **** 			against suspect run time stat counter implementations - which
3016:FreeRTOS/Source/tasks.c **** 			are provided by the application, not the kernel. */
3017:FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > ulTaskSwitchedInTime )
3018:FreeRTOS/Source/tasks.c **** 			{
3019:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
3020:FreeRTOS/Source/tasks.c **** 			}
3021:FreeRTOS/Source/tasks.c **** 			else
3022:FreeRTOS/Source/tasks.c **** 			{
3023:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3024:FreeRTOS/Source/tasks.c **** 			}
3025:FreeRTOS/Source/tasks.c **** 			ulTaskSwitchedInTime = ulTotalRunTime;
3026:FreeRTOS/Source/tasks.c **** 		}
3027:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
3028:FreeRTOS/Source/tasks.c **** 
3029:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
3030:FreeRTOS/Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
3031:FreeRTOS/Source/tasks.c **** 
3032:FreeRTOS/Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
3033:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
3034:FreeRTOS/Source/tasks.c **** 		{
3035:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
3036:FreeRTOS/Source/tasks.c **** 		}
3037:FreeRTOS/Source/tasks.c **** 		#endif
3038:FreeRTOS/Source/tasks.c **** 
3039:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
3040:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
3041:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
3042:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
3043:FreeRTOS/Source/tasks.c **** 
3044:FreeRTOS/Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
3045:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
3046:FreeRTOS/Source/tasks.c **** 		{
3047:FreeRTOS/Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
3048:FreeRTOS/Source/tasks.c **** 		}
3049:FreeRTOS/Source/tasks.c **** 		#endif
3050:FreeRTOS/Source/tasks.c **** 
3051:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3052:FreeRTOS/Source/tasks.c **** 		{
3053:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
3054:FreeRTOS/Source/tasks.c **** 			structure specific to this task.
3055:FreeRTOS/Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3056:FreeRTOS/Source/tasks.c **** 			for additional information. */
3057:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
3058:FreeRTOS/Source/tasks.c **** 		}
3059:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3060:FreeRTOS/Source/tasks.c **** 	}
3061:FreeRTOS/Source/tasks.c **** }
3062:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3063:FreeRTOS/Source/tasks.c **** 
3064:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
3065:FreeRTOS/Source/tasks.c **** {
3066:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
3067:FreeRTOS/Source/tasks.c **** 
3068:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
3069:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
3070:FreeRTOS/Source/tasks.c **** 
3071:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
3072:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
3073:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
3074:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
3075:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3076:FreeRTOS/Source/tasks.c **** 
3077:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3078:FreeRTOS/Source/tasks.c **** }
3079:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3080:FreeRTOS/Source/tasks.c **** 
3081:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
3082:FreeRTOS/Source/tasks.c **** {
3083:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
3084:FreeRTOS/Source/tasks.c **** 
3085:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3086:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
3087:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
3088:FreeRTOS/Source/tasks.c **** 
3089:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
3090:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3091:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
3092:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3093:FreeRTOS/Source/tasks.c **** 
3094:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3095:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3096:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3097:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3098:FreeRTOS/Source/tasks.c **** 	the task level). */
3099:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3100:FreeRTOS/Source/tasks.c **** 
3101:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3102:FreeRTOS/Source/tasks.c **** }
3103:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3104:FreeRTOS/Source/tasks.c **** 
3105:FreeRTOS/Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3106:FreeRTOS/Source/tasks.c **** 
3107:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3108:FreeRTOS/Source/tasks.c **** 	{
3109:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
3110:FreeRTOS/Source/tasks.c **** 
3111:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
3112:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3113:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3114:FreeRTOS/Source/tasks.c **** 		it should be called with the scheduler suspended. */
3115:FreeRTOS/Source/tasks.c **** 
3116:FreeRTOS/Source/tasks.c **** 
3117:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3118:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3119:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3120:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
3121:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3122:FreeRTOS/Source/tasks.c **** 
3123:FreeRTOS/Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3124:FreeRTOS/Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3125:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3126:FreeRTOS/Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3127:FreeRTOS/Source/tasks.c **** 		{
3128:FreeRTOS/Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3129:FreeRTOS/Source/tasks.c **** 		}
3130:FreeRTOS/Source/tasks.c **** 
3131:FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3132:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3133:FreeRTOS/Source/tasks.c **** 	}
3134:FreeRTOS/Source/tasks.c **** 
3135:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
3136:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3137:FreeRTOS/Source/tasks.c **** 
3138:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3139:FreeRTOS/Source/tasks.c **** {
3140:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3141:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3142:FreeRTOS/Source/tasks.c **** 
3143:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3144:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
3145:FreeRTOS/Source/tasks.c **** 
3146:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3147:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3148:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
3149:FreeRTOS/Source/tasks.c **** 
3150:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3151:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3152:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3153:FreeRTOS/Source/tasks.c **** 
3154:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3155:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
3156:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
3157:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3158:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3159:FreeRTOS/Source/tasks.c **** 
3160:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3161:FreeRTOS/Source/tasks.c **** 	{
3162:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3163:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3164:FreeRTOS/Source/tasks.c **** 
3165:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TICKLESS_IDLE != 0 )
3166:FreeRTOS/Source/tasks.c **** 		{
3167:FreeRTOS/Source/tasks.c **** 			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3168:FreeRTOS/Source/tasks.c **** 			might be set to the blocked task's time out time.  If the task is
3169:FreeRTOS/Source/tasks.c **** 			unblocked for a reason other than a timeout xNextTaskUnblockTime is
3170:FreeRTOS/Source/tasks.c **** 			normally left unchanged, because it is automatically reset to a new
3171:FreeRTOS/Source/tasks.c **** 			value when the tick count equals xNextTaskUnblockTime.  However if
3172:FreeRTOS/Source/tasks.c **** 			tickless idling is used it might be more important to enter sleep mode
3173:FreeRTOS/Source/tasks.c **** 			at the earliest possible time - so reset xNextTaskUnblockTime here to
3174:FreeRTOS/Source/tasks.c **** 			ensure it is updated at the earliest possible time. */
3175:FreeRTOS/Source/tasks.c **** 			prvResetNextTaskUnblockTime();
3176:FreeRTOS/Source/tasks.c **** 		}
3177:FreeRTOS/Source/tasks.c **** 		#endif
3178:FreeRTOS/Source/tasks.c **** 	}
3179:FreeRTOS/Source/tasks.c **** 	else
3180:FreeRTOS/Source/tasks.c **** 	{
3181:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3182:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
3183:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3184:FreeRTOS/Source/tasks.c **** 	}
3185:FreeRTOS/Source/tasks.c **** 
3186:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3187:FreeRTOS/Source/tasks.c **** 	{
3188:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3189:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3190:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
3191:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
3192:FreeRTOS/Source/tasks.c **** 
3193:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3194:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3195:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3196:FreeRTOS/Source/tasks.c **** 	}
3197:FreeRTOS/Source/tasks.c **** 	else
3198:FreeRTOS/Source/tasks.c **** 	{
3199:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
3200:FreeRTOS/Source/tasks.c **** 	}
3201:FreeRTOS/Source/tasks.c **** 
3202:FreeRTOS/Source/tasks.c **** 	return xReturn;
3203:FreeRTOS/Source/tasks.c **** }
3204:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3205:FreeRTOS/Source/tasks.c **** 
3206:FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3207:FreeRTOS/Source/tasks.c **** {
3208:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3209:FreeRTOS/Source/tasks.c **** 
3210:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3211:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
3212:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3213:FreeRTOS/Source/tasks.c **** 
3214:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
3215:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3216:FreeRTOS/Source/tasks.c **** 
3217:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3218:FreeRTOS/Source/tasks.c **** 	event flags. */
3219:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
3220:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3221:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3222:FreeRTOS/Source/tasks.c **** 
3223:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3224:FreeRTOS/Source/tasks.c **** 	{
3225:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3226:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3227:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3228:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3229:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3230:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3231:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3232:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3233:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3234:FreeRTOS/Source/tasks.c **** 	}
3235:FreeRTOS/Source/tasks.c **** 	#endif
3236:FreeRTOS/Source/tasks.c **** 
3237:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3238:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3239:FreeRTOS/Source/tasks.c **** 	lists. */
3240:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3241:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3242:FreeRTOS/Source/tasks.c **** 
3243:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3244:FreeRTOS/Source/tasks.c **** 	{
3245:FreeRTOS/Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3246:FreeRTOS/Source/tasks.c **** 		a context switch is required.  This function is called with the
3247:FreeRTOS/Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3248:FreeRTOS/Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3249:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3250:FreeRTOS/Source/tasks.c **** 	}
3251:FreeRTOS/Source/tasks.c **** }
3252:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3253:FreeRTOS/Source/tasks.c **** 
3254:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3255:FreeRTOS/Source/tasks.c **** {
3256:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3257:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3258:FreeRTOS/Source/tasks.c **** 	{
3259:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3260:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3261:FreeRTOS/Source/tasks.c **** 	}
3262:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3263:FreeRTOS/Source/tasks.c **** }
3264:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3265:FreeRTOS/Source/tasks.c **** 
3266:FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3267:FreeRTOS/Source/tasks.c **** {
3268:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3269:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3270:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3271:FreeRTOS/Source/tasks.c **** }
3272:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3273:FreeRTOS/Source/tasks.c **** 
3274:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3275:FreeRTOS/Source/tasks.c **** {
3276:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3277:FreeRTOS/Source/tasks.c **** 
3278:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3279:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
3280:FreeRTOS/Source/tasks.c **** 
3281:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3282:FreeRTOS/Source/tasks.c **** 	{
3283:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3284:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3285:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3286:FreeRTOS/Source/tasks.c **** 
3287:FreeRTOS/Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3288:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3289:FreeRTOS/Source/tasks.c **** 			{
3290:FreeRTOS/Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3291:FreeRTOS/Source/tasks.c **** 				but has the same result. */
3292:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3293:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3294:FreeRTOS/Source/tasks.c **** 			}
3295:FreeRTOS/Source/tasks.c **** 			else
3296:FreeRTOS/Source/tasks.c **** 		#endif
3297:FreeRTOS/Source/tasks.c **** 
3298:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3299:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3300:FreeRTOS/Source/tasks.c **** 			{
3301:FreeRTOS/Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3302:FreeRTOS/Source/tasks.c **** 				specified is the maximum block time then the task should block
3303:FreeRTOS/Source/tasks.c **** 				indefinitely, and therefore never time out. */
3304:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
3305:FreeRTOS/Source/tasks.c **** 			}
3306:FreeRTOS/Source/tasks.c **** 			else
3307:FreeRTOS/Source/tasks.c **** 		#endif
3308:FreeRTOS/Source/tasks.c **** 
3309:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3310:FreeRTOS/Source/tasks.c **** 		{
3311:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which
3312:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3313:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3314:FreeRTOS/Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3315:FreeRTOS/Source/tasks.c **** 			was called. */
3316:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3317:FreeRTOS/Source/tasks.c **** 		}
3318:FreeRTOS/Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3319:FreeRTOS/Source/tasks.c **** 		{
3320:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3321:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3322:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3323:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
3324:FreeRTOS/Source/tasks.c **** 		}
3325:FreeRTOS/Source/tasks.c **** 		else
3326:FreeRTOS/Source/tasks.c **** 		{
3327:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait = 0;
3328:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3329:FreeRTOS/Source/tasks.c **** 		}
3330:FreeRTOS/Source/tasks.c **** 	}
3331:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3332:FreeRTOS/Source/tasks.c **** 
3333:FreeRTOS/Source/tasks.c **** 	return xReturn;
3334:FreeRTOS/Source/tasks.c **** }
3335:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3336:FreeRTOS/Source/tasks.c **** 
3337:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3338:FreeRTOS/Source/tasks.c **** {
3339:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
3340:FreeRTOS/Source/tasks.c **** }
3341:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3342:FreeRTOS/Source/tasks.c **** 
3343:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3344:FreeRTOS/Source/tasks.c **** 
3345:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3346:FreeRTOS/Source/tasks.c **** 	{
3347:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3348:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
3349:FreeRTOS/Source/tasks.c **** 
3350:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3351:FreeRTOS/Source/tasks.c **** 		{
3352:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3353:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3354:FreeRTOS/Source/tasks.c **** 		}
3355:FreeRTOS/Source/tasks.c **** 		else
3356:FreeRTOS/Source/tasks.c **** 		{
3357:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
3358:FreeRTOS/Source/tasks.c **** 		}
3359:FreeRTOS/Source/tasks.c **** 
3360:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3361:FreeRTOS/Source/tasks.c **** 	}
3362:FreeRTOS/Source/tasks.c **** 
3363:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3364:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3365:FreeRTOS/Source/tasks.c **** 
3366:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3367:FreeRTOS/Source/tasks.c **** 
3368:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3369:FreeRTOS/Source/tasks.c **** 	{
3370:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
3371:FreeRTOS/Source/tasks.c **** 
3372:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3373:FreeRTOS/Source/tasks.c **** 		{
3374:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3375:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3376:FreeRTOS/Source/tasks.c **** 		}
3377:FreeRTOS/Source/tasks.c **** 	}
3378:FreeRTOS/Source/tasks.c **** 
3379:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3380:FreeRTOS/Source/tasks.c **** 
3381:FreeRTOS/Source/tasks.c **** /*
3382:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3383:FreeRTOS/Source/tasks.c ****  * The Idle task.
3384:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
3385:FreeRTOS/Source/tasks.c ****  *
3386:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3387:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3388:FreeRTOS/Source/tasks.c ****  *
3389:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3390:FreeRTOS/Source/tasks.c ****  *
3391:FreeRTOS/Source/tasks.c ****  */
3392:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3393:FreeRTOS/Source/tasks.c **** {
3394:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
3395:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
3396:FreeRTOS/Source/tasks.c **** 
3397:FreeRTOS/Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3398:FreeRTOS/Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3399:FreeRTOS/Source/tasks.c **** 
3400:FreeRTOS/Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3401:FreeRTOS/Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3402:FreeRTOS/Source/tasks.c **** 	any. */
3403:FreeRTOS/Source/tasks.c **** 	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
3404:FreeRTOS/Source/tasks.c **** 
3405:FreeRTOS/Source/tasks.c **** 	for( ;; )
3406:FreeRTOS/Source/tasks.c **** 	{
3407:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3408:FreeRTOS/Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3409:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
3410:FreeRTOS/Source/tasks.c **** 
3411:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3412:FreeRTOS/Source/tasks.c **** 		{
3413:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3414:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
3415:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3416:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
3417:FreeRTOS/Source/tasks.c **** 			taskYIELD();
3418:FreeRTOS/Source/tasks.c **** 		}
3419:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3420:FreeRTOS/Source/tasks.c **** 
3421:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3422:FreeRTOS/Source/tasks.c **** 		{
3423:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3424:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3425:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
3426:FreeRTOS/Source/tasks.c **** 			timeslice.
3427:FreeRTOS/Source/tasks.c **** 
3428:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
3429:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3430:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3431:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3432:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3433:FreeRTOS/Source/tasks.c **** 			{
3434:FreeRTOS/Source/tasks.c **** 				taskYIELD();
3435:FreeRTOS/Source/tasks.c **** 			}
3436:FreeRTOS/Source/tasks.c **** 			else
3437:FreeRTOS/Source/tasks.c **** 			{
3438:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3439:FreeRTOS/Source/tasks.c **** 			}
3440:FreeRTOS/Source/tasks.c **** 		}
3441:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3442:FreeRTOS/Source/tasks.c **** 
3443:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3444:FreeRTOS/Source/tasks.c **** 		{
3445:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3446:FreeRTOS/Source/tasks.c **** 
3447:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3448:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
3449:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
3450:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3451:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3452:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
3453:FreeRTOS/Source/tasks.c **** 		}
3454:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3455:FreeRTOS/Source/tasks.c **** 
3456:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3457:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3458:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
3459:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3460:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3461:FreeRTOS/Source/tasks.c **** 		{
3462:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3463:FreeRTOS/Source/tasks.c **** 
3464:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3465:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3466:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
3467:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3468:FreeRTOS/Source/tasks.c **** 			valid. */
3469:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3470:FreeRTOS/Source/tasks.c **** 
3471:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3472:FreeRTOS/Source/tasks.c **** 			{
3473:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
3474:FreeRTOS/Source/tasks.c **** 				{
3475:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3476:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
3477:FreeRTOS/Source/tasks.c **** 					be used. */
3478:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3479:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3480:FreeRTOS/Source/tasks.c **** 
3481:FreeRTOS/Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3482:FreeRTOS/Source/tasks.c **** 					if the application does not want
3483:FreeRTOS/Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3484:FreeRTOS/Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3485:FreeRTOS/Source/tasks.c **** 
3486:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3487:FreeRTOS/Source/tasks.c **** 					{
3488:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3489:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3490:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3491:FreeRTOS/Source/tasks.c **** 					}
3492:FreeRTOS/Source/tasks.c **** 					else
3493:FreeRTOS/Source/tasks.c **** 					{
3494:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3495:FreeRTOS/Source/tasks.c **** 					}
3496:FreeRTOS/Source/tasks.c **** 				}
3497:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
3498:FreeRTOS/Source/tasks.c **** 			}
3499:FreeRTOS/Source/tasks.c **** 			else
3500:FreeRTOS/Source/tasks.c **** 			{
3501:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3502:FreeRTOS/Source/tasks.c **** 			}
3503:FreeRTOS/Source/tasks.c **** 		}
3504:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3505:FreeRTOS/Source/tasks.c **** 	}
3506:FreeRTOS/Source/tasks.c **** }
3507:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3508:FreeRTOS/Source/tasks.c **** 
3509:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3510:FreeRTOS/Source/tasks.c **** 
3511:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3512:FreeRTOS/Source/tasks.c **** 	{
3513:FreeRTOS/Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3514:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3515:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3516:FreeRTOS/Source/tasks.c **** 
3517:FreeRTOS/Source/tasks.c **** 		/* This function must be called from a critical section. */
3518:FreeRTOS/Source/tasks.c **** 
3519:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3520:FreeRTOS/Source/tasks.c **** 		{
3521:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3522:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3523:FreeRTOS/Source/tasks.c **** 		}
3524:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3525:FreeRTOS/Source/tasks.c **** 		{
3526:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3527:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3528:FreeRTOS/Source/tasks.c **** 		}
3529:FreeRTOS/Source/tasks.c **** 		else
3530:FreeRTOS/Source/tasks.c **** 		{
3531:FreeRTOS/Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3532:FreeRTOS/Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3533:FreeRTOS/Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3534:FreeRTOS/Source/tasks.c **** 			interrupts. */
3535:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3536:FreeRTOS/Source/tasks.c **** 			{
3537:FreeRTOS/Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3538:FreeRTOS/Source/tasks.c **** 			}
3539:FreeRTOS/Source/tasks.c **** 			else
3540:FreeRTOS/Source/tasks.c **** 			{
3541:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3542:FreeRTOS/Source/tasks.c **** 			}
3543:FreeRTOS/Source/tasks.c **** 		}
3544:FreeRTOS/Source/tasks.c **** 
3545:FreeRTOS/Source/tasks.c **** 		return eReturn;
3546:FreeRTOS/Source/tasks.c **** 	}
3547:FreeRTOS/Source/tasks.c **** 
3548:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3549:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3550:FreeRTOS/Source/tasks.c **** 
3551:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3552:FreeRTOS/Source/tasks.c **** 
3553:FreeRTOS/Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3554:FreeRTOS/Source/tasks.c **** 	{
3555:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3556:FreeRTOS/Source/tasks.c **** 
3557:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3558:FreeRTOS/Source/tasks.c **** 		{
3559:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3560:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB != NULL );
3561:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3562:FreeRTOS/Source/tasks.c **** 		}
3563:FreeRTOS/Source/tasks.c **** 	}
3564:FreeRTOS/Source/tasks.c **** 
3565:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3566:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3567:FreeRTOS/Source/tasks.c **** 
3568:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3569:FreeRTOS/Source/tasks.c **** 
3570:FreeRTOS/Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3571:FreeRTOS/Source/tasks.c **** 	{
3572:FreeRTOS/Source/tasks.c **** 	void *pvReturn = NULL;
3573:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3574:FreeRTOS/Source/tasks.c **** 
3575:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3576:FreeRTOS/Source/tasks.c **** 		{
3577:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3578:FreeRTOS/Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3579:FreeRTOS/Source/tasks.c **** 		}
3580:FreeRTOS/Source/tasks.c **** 		else
3581:FreeRTOS/Source/tasks.c **** 		{
3582:FreeRTOS/Source/tasks.c **** 			pvReturn = NULL;
3583:FreeRTOS/Source/tasks.c **** 		}
3584:FreeRTOS/Source/tasks.c **** 
3585:FreeRTOS/Source/tasks.c **** 		return pvReturn;
3586:FreeRTOS/Source/tasks.c **** 	}
3587:FreeRTOS/Source/tasks.c **** 
3588:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3589:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3590:FreeRTOS/Source/tasks.c **** 
3591:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3592:FreeRTOS/Source/tasks.c **** 
3593:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3594:FreeRTOS/Source/tasks.c **** 	{
3595:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3596:FreeRTOS/Source/tasks.c **** 
3597:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3598:FreeRTOS/Source/tasks.c **** 		the calling task. */
3599:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3600:FreeRTOS/Source/tasks.c **** 
3601:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3602:FreeRTOS/Source/tasks.c **** 	}
3603:FreeRTOS/Source/tasks.c **** 
3604:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3605:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3606:FreeRTOS/Source/tasks.c **** 
3607:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3608:FreeRTOS/Source/tasks.c **** {
3609:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
3610:FreeRTOS/Source/tasks.c **** 
3611:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3612:FreeRTOS/Source/tasks.c **** 	{
3613:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3614:FreeRTOS/Source/tasks.c **** 	}
3615:FreeRTOS/Source/tasks.c **** 
3616:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3617:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3618:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3619:FreeRTOS/Source/tasks.c **** 
3620:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3621:FreeRTOS/Source/tasks.c **** 	{
3622:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3623:FreeRTOS/Source/tasks.c **** 	}
3624:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3625:FreeRTOS/Source/tasks.c **** 
3626:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3627:FreeRTOS/Source/tasks.c **** 	{
3628:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3629:FreeRTOS/Source/tasks.c **** 	}
3630:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3631:FreeRTOS/Source/tasks.c **** 
3632:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3633:FreeRTOS/Source/tasks.c **** 	using list2. */
3634:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3635:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3636:FreeRTOS/Source/tasks.c **** }
3637:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3638:FreeRTOS/Source/tasks.c **** 
3639:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3640:FreeRTOS/Source/tasks.c **** {
3641:FreeRTOS/Source/tasks.c **** 
3642:FreeRTOS/Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3643:FreeRTOS/Source/tasks.c **** 
3644:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3645:FreeRTOS/Source/tasks.c **** 	{
3646:FreeRTOS/Source/tasks.c **** 		TCB_t *pxTCB;
3647:FreeRTOS/Source/tasks.c **** 
3648:FreeRTOS/Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3649:FreeRTOS/Source/tasks.c **** 		being called too often in the idle task. */
3650:FreeRTOS/Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3651:FreeRTOS/Source/tasks.c **** 		{
3652:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
3653:FreeRTOS/Source/tasks.c **** 			{
3654:FreeRTOS/Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
3655:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3656:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
3657:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3658:FreeRTOS/Source/tasks.c **** 			}
3659:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
3660:FreeRTOS/Source/tasks.c **** 
3661:FreeRTOS/Source/tasks.c **** 			prvDeleteTCB( pxTCB );
3662:FreeRTOS/Source/tasks.c **** 		}
3663:FreeRTOS/Source/tasks.c **** 	}
3664:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3665:FreeRTOS/Source/tasks.c **** }
3666:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3667:FreeRTOS/Source/tasks.c **** 
3668:FreeRTOS/Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3669:FreeRTOS/Source/tasks.c **** 
3670:FreeRTOS/Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3671:FreeRTOS/Source/tasks.c **** 	{
3672:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3673:FreeRTOS/Source/tasks.c **** 
3674:FreeRTOS/Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3675:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3676:FreeRTOS/Source/tasks.c **** 
3677:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3678:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3679:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3680:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3681:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3682:FreeRTOS/Source/tasks.c **** 
3683:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3684:FreeRTOS/Source/tasks.c **** 		{
3685:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3686:FreeRTOS/Source/tasks.c **** 		}
3687:FreeRTOS/Source/tasks.c **** 		#else
3688:FreeRTOS/Source/tasks.c **** 		{
3689:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3690:FreeRTOS/Source/tasks.c **** 		}
3691:FreeRTOS/Source/tasks.c **** 		#endif
3692:FreeRTOS/Source/tasks.c **** 
3693:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3694:FreeRTOS/Source/tasks.c **** 		{
3695:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3696:FreeRTOS/Source/tasks.c **** 		}
3697:FreeRTOS/Source/tasks.c **** 		#else
3698:FreeRTOS/Source/tasks.c **** 		{
3699:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3700:FreeRTOS/Source/tasks.c **** 		}
3701:FreeRTOS/Source/tasks.c **** 		#endif
3702:FreeRTOS/Source/tasks.c **** 
3703:FreeRTOS/Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3704:FreeRTOS/Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3705:FreeRTOS/Source/tasks.c **** 		state is just set to whatever is passed in. */
3706:FreeRTOS/Source/tasks.c **** 		if( eState != eInvalid )
3707:FreeRTOS/Source/tasks.c **** 		{
3708:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3709:FreeRTOS/Source/tasks.c **** 			{
3710:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3711:FreeRTOS/Source/tasks.c **** 			}
3712:FreeRTOS/Source/tasks.c **** 			else
3713:FreeRTOS/Source/tasks.c **** 			{
3714:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3715:FreeRTOS/Source/tasks.c **** 
3716:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3717:FreeRTOS/Source/tasks.c **** 				{
3718:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3719:FreeRTOS/Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3720:FreeRTOS/Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3721:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3722:FreeRTOS/Source/tasks.c **** 					{
3723:FreeRTOS/Source/tasks.c **** 						vTaskSuspendAll();
3724:FreeRTOS/Source/tasks.c **** 						{
3725:FreeRTOS/Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3726:FreeRTOS/Source/tasks.c **** 							{
3727:FreeRTOS/Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3728:FreeRTOS/Source/tasks.c **** 							}
3729:FreeRTOS/Source/tasks.c **** 						}
3730:FreeRTOS/Source/tasks.c **** 						( void ) xTaskResumeAll();
3731:FreeRTOS/Source/tasks.c **** 					}
3732:FreeRTOS/Source/tasks.c **** 				}
3733:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3734:FreeRTOS/Source/tasks.c **** 			}
3735:FreeRTOS/Source/tasks.c **** 		}
3736:FreeRTOS/Source/tasks.c **** 		else
3737:FreeRTOS/Source/tasks.c **** 		{
3738:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3739:FreeRTOS/Source/tasks.c **** 		}
3740:FreeRTOS/Source/tasks.c **** 
3741:FreeRTOS/Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3742:FreeRTOS/Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3743:FreeRTOS/Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3744:FreeRTOS/Source/tasks.c **** 		{
3745:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3746:FreeRTOS/Source/tasks.c **** 			{
3747:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3748:FreeRTOS/Source/tasks.c **** 			}
3749:FreeRTOS/Source/tasks.c **** 			#else
3750:FreeRTOS/Source/tasks.c **** 			{
3751:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3752:FreeRTOS/Source/tasks.c **** 			}
3753:FreeRTOS/Source/tasks.c **** 			#endif
3754:FreeRTOS/Source/tasks.c **** 		}
3755:FreeRTOS/Source/tasks.c **** 		else
3756:FreeRTOS/Source/tasks.c **** 		{
3757:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3758:FreeRTOS/Source/tasks.c **** 		}
3759:FreeRTOS/Source/tasks.c **** 	}
3760:FreeRTOS/Source/tasks.c **** 
3761:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3762:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3763:FreeRTOS/Source/tasks.c **** 
3764:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3765:FreeRTOS/Source/tasks.c **** 
3766:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3767:FreeRTOS/Source/tasks.c **** 	{
3768:FreeRTOS/Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3769:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3770:FreeRTOS/Source/tasks.c **** 
3771:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3772:FreeRTOS/Source/tasks.c **** 		{
3773:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3774:FreeRTOS/Source/tasks.c **** 
3775:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3776:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3777:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3778:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3779:FreeRTOS/Source/tasks.c **** 			do
3780:FreeRTOS/Source/tasks.c **** 			{
3781:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3782:FreeRTOS/Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3783:FreeRTOS/Source/tasks.c **** 				uxTask++;
3784:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3785:FreeRTOS/Source/tasks.c **** 		}
3786:FreeRTOS/Source/tasks.c **** 		else
3787:FreeRTOS/Source/tasks.c **** 		{
3788:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3789:FreeRTOS/Source/tasks.c **** 		}
3790:FreeRTOS/Source/tasks.c **** 
3791:FreeRTOS/Source/tasks.c **** 		return uxTask;
3792:FreeRTOS/Source/tasks.c **** 	}
3793:FreeRTOS/Source/tasks.c **** 
3794:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3795:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3796:FreeRTOS/Source/tasks.c **** 
3797:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
3798:FreeRTOS/Source/tasks.c **** 
3799:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3800:FreeRTOS/Source/tasks.c **** 	{
3801:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3802:FreeRTOS/Source/tasks.c **** 
3803:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3804:FreeRTOS/Source/tasks.c **** 		{
3805:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3806:FreeRTOS/Source/tasks.c **** 			ulCount++;
3807:FreeRTOS/Source/tasks.c **** 		}
3808:FreeRTOS/Source/tasks.c **** 
3809:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3810:FreeRTOS/Source/tasks.c **** 
3811:FreeRTOS/Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3812:FreeRTOS/Source/tasks.c **** 	}
3813:FreeRTOS/Source/tasks.c **** 
3814:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( 
3815:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3816:FreeRTOS/Source/tasks.c **** 
3817:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
3818:FreeRTOS/Source/tasks.c **** 
3819:FreeRTOS/Source/tasks.c **** 	/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
3820:FreeRTOS/Source/tasks.c **** 	same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
3821:FreeRTOS/Source/tasks.c **** 	user to determine the return type.  It gets around the problem of the value
3822:FreeRTOS/Source/tasks.c **** 	overflowing on 8-bit types without breaking backward compatibility for
3823:FreeRTOS/Source/tasks.c **** 	applications that expect an 8-bit return type. */
3824:FreeRTOS/Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
3825:FreeRTOS/Source/tasks.c **** 	{
3826:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3827:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3828:FreeRTOS/Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxReturn;
3829:FreeRTOS/Source/tasks.c **** 
3830:FreeRTOS/Source/tasks.c **** 		/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
3831:FreeRTOS/Source/tasks.c **** 		the same except for their return type.  Using configSTACK_DEPTH_TYPE
3832:FreeRTOS/Source/tasks.c **** 		allows the user to determine the return type.  It gets around the
3833:FreeRTOS/Source/tasks.c **** 		problem of the value overflowing on 8-bit types without breaking
3834:FreeRTOS/Source/tasks.c **** 		backward compatibility for applications that expect an 8-bit return
3835:FreeRTOS/Source/tasks.c **** 		type. */
3836:FreeRTOS/Source/tasks.c **** 
3837:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3838:FreeRTOS/Source/tasks.c **** 
3839:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3840:FreeRTOS/Source/tasks.c **** 		{
3841:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3842:FreeRTOS/Source/tasks.c **** 		}
3843:FreeRTOS/Source/tasks.c **** 		#else
3844:FreeRTOS/Source/tasks.c **** 		{
3845:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3846:FreeRTOS/Source/tasks.c **** 		}
3847:FreeRTOS/Source/tasks.c **** 		#endif
3848:FreeRTOS/Source/tasks.c **** 
3849:FreeRTOS/Source/tasks.c **** 		uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
3850:FreeRTOS/Source/tasks.c **** 
3851:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3852:FreeRTOS/Source/tasks.c **** 	}
3853:FreeRTOS/Source/tasks.c **** 
3854:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
3855:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3856:FreeRTOS/Source/tasks.c **** 
3857:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3858:FreeRTOS/Source/tasks.c **** 
3859:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3860:FreeRTOS/Source/tasks.c **** 	{
3861:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3862:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3863:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3864:FreeRTOS/Source/tasks.c **** 
3865:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3866:FreeRTOS/Source/tasks.c **** 
3867:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3868:FreeRTOS/Source/tasks.c **** 		{
3869:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3870:FreeRTOS/Source/tasks.c **** 		}
3871:FreeRTOS/Source/tasks.c **** 		#else
3872:FreeRTOS/Source/tasks.c **** 		{
3873:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3874:FreeRTOS/Source/tasks.c **** 		}
3875:FreeRTOS/Source/tasks.c **** 		#endif
3876:FreeRTOS/Source/tasks.c **** 
3877:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3878:FreeRTOS/Source/tasks.c **** 
3879:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3880:FreeRTOS/Source/tasks.c **** 	}
3881:FreeRTOS/Source/tasks.c **** 
3882:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3883:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3884:FreeRTOS/Source/tasks.c **** 
3885:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3886:FreeRTOS/Source/tasks.c **** 
3887:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3888:FreeRTOS/Source/tasks.c **** 	{
3889:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3890:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3891:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3892:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3893:FreeRTOS/Source/tasks.c **** 
3894:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3895:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level.
3896:FreeRTOS/Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3897:FreeRTOS/Source/tasks.c **** 		for additional information. */
3898:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3899:FreeRTOS/Source/tasks.c **** 		{
3900:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3901:FreeRTOS/Source/tasks.c **** 		}
3902:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3903:FreeRTOS/Source/tasks.c **** 
3904:FreeRTOS/Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3905:FreeRTOS/Source/tasks.c **** 		{
3906:FreeRTOS/Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3907:FreeRTOS/Source/tasks.c **** 			the stack and TCB. */
3908:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
3909:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
3910:FreeRTOS/Source/tasks.c **** 		}
3911:FreeRTOS/Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3912:FreeRTOS/Source/tasks.c **** 		{
3913:FreeRTOS/Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3914:FreeRTOS/Source/tasks.c **** 			check what was statically allocated before trying to free the
3915:FreeRTOS/Source/tasks.c **** 			memory. */
3916:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3917:FreeRTOS/Source/tasks.c **** 			{
3918:FreeRTOS/Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3919:FreeRTOS/Source/tasks.c **** 				must be freed. */
3920:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3921:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3922:FreeRTOS/Source/tasks.c **** 			}
3923:FreeRTOS/Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3924:FreeRTOS/Source/tasks.c **** 			{
3925:FreeRTOS/Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3926:FreeRTOS/Source/tasks.c **** 				only memory that must be freed. */
3927:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3928:FreeRTOS/Source/tasks.c **** 			}
3929:FreeRTOS/Source/tasks.c **** 			else
3930:FreeRTOS/Source/tasks.c **** 			{
3931:FreeRTOS/Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3932:FreeRTOS/Source/tasks.c **** 				nothing needs to be freed. */
3933:FreeRTOS/Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3934:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3935:FreeRTOS/Source/tasks.c **** 			}
3936:FreeRTOS/Source/tasks.c **** 		}
3937:FreeRTOS/Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3938:FreeRTOS/Source/tasks.c **** 	}
3939:FreeRTOS/Source/tasks.c **** 
3940:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3941:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3942:FreeRTOS/Source/tasks.c **** 
3943:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3944:FreeRTOS/Source/tasks.c **** {
3945:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3946:FreeRTOS/Source/tasks.c **** 
3947:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
3948:FreeRTOS/Source/tasks.c **** 	{
3949:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3950:FreeRTOS/Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3951:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3952:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3953:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
3954:FreeRTOS/Source/tasks.c **** 	}
3955:FreeRTOS/Source/tasks.c **** 	else
3956:FreeRTOS/Source/tasks.c **** 	{
3957:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3958:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3959:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3960:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3961:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
3962:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
3963:FreeRTOS/Source/tasks.c **** 	}
3964:FreeRTOS/Source/tasks.c **** }
3965:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3966:FreeRTOS/Source/tasks.c **** 
3967:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3968:FreeRTOS/Source/tasks.c **** 
3969:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3970:FreeRTOS/Source/tasks.c **** 	{
3971:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3972:FreeRTOS/Source/tasks.c **** 
3973:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3974:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3975:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3976:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
3977:FreeRTOS/Source/tasks.c **** 
3978:FreeRTOS/Source/tasks.c **** 		return xReturn;
3979:FreeRTOS/Source/tasks.c **** 	}
3980:FreeRTOS/Source/tasks.c **** 
3981:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3982:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3983:FreeRTOS/Source/tasks.c **** 
3984:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3985:FreeRTOS/Source/tasks.c **** 
3986:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3987:FreeRTOS/Source/tasks.c **** 	{
3988:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3989:FreeRTOS/Source/tasks.c **** 
3990:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3991:FreeRTOS/Source/tasks.c **** 		{
3992:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3993:FreeRTOS/Source/tasks.c **** 		}
3994:FreeRTOS/Source/tasks.c **** 		else
3995:FreeRTOS/Source/tasks.c **** 		{
3996:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3997:FreeRTOS/Source/tasks.c **** 			{
3998:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3999:FreeRTOS/Source/tasks.c **** 			}
4000:FreeRTOS/Source/tasks.c **** 			else
4001:FreeRTOS/Source/tasks.c **** 			{
4002:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
4003:FreeRTOS/Source/tasks.c **** 			}
4004:FreeRTOS/Source/tasks.c **** 		}
4005:FreeRTOS/Source/tasks.c **** 
4006:FreeRTOS/Source/tasks.c **** 		return xReturn;
4007:FreeRTOS/Source/tasks.c **** 	}
4008:FreeRTOS/Source/tasks.c **** 
4009:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
4010:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4011:FreeRTOS/Source/tasks.c **** 
4012:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4013:FreeRTOS/Source/tasks.c **** 
4014:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
4015:FreeRTOS/Source/tasks.c **** 	{
4016:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
4017:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
4018:FreeRTOS/Source/tasks.c **** 
4019:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
4020:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
4021:FreeRTOS/Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
4022:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4023:FreeRTOS/Source/tasks.c **** 		{
4024:FreeRTOS/Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
4025:FreeRTOS/Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
4026:FreeRTOS/Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
4027:FreeRTOS/Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
4028:FreeRTOS/Source/tasks.c **** 			{
4029:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
4030:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
4031:FreeRTOS/Source/tasks.c **** 				not being used for anything else. */
4032:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
4033:FreeRTOS/Source/tasks.c **** 				{
4034:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
4035:FreeRTOS/Source/tasks.c **** 				}
4036:FreeRTOS/Source/tasks.c **** 				else
4037:FreeRTOS/Source/tasks.c **** 				{
4038:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4039:FreeRTOS/Source/tasks.c **** 				}
4040:FreeRTOS/Source/tasks.c **** 
4041:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
4042:FreeRTOS/Source/tasks.c **** 				to be moved into a new list. */
4043:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
4044:FreeRTOS/Source/tasks.c **** 				{
4045:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4046:FreeRTOS/Source/tasks.c **** 					{
4047:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
4048:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
4049:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
4050:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
4051:FreeRTOS/Source/tasks.c **** 					}
4052:FreeRTOS/Source/tasks.c **** 					else
4053:FreeRTOS/Source/tasks.c **** 					{
4054:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4055:FreeRTOS/Source/tasks.c **** 					}
4056:FreeRTOS/Source/tasks.c **** 
4057:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
4058:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4059:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
4060:FreeRTOS/Source/tasks.c **** 				}
4061:FreeRTOS/Source/tasks.c **** 				else
4062:FreeRTOS/Source/tasks.c **** 				{
4063:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
4064:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4065:FreeRTOS/Source/tasks.c **** 				}
4066:FreeRTOS/Source/tasks.c **** 
4067:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
4068:FreeRTOS/Source/tasks.c **** 
4069:FreeRTOS/Source/tasks.c **** 				/* Inheritance occurred. */
4070:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
4071:FreeRTOS/Source/tasks.c **** 			}
4072:FreeRTOS/Source/tasks.c **** 			else
4073:FreeRTOS/Source/tasks.c **** 			{
4074:FreeRTOS/Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
4075:FreeRTOS/Source/tasks.c **** 				{
4076:FreeRTOS/Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
4077:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
4078:FreeRTOS/Source/tasks.c **** 					current priority of the mutex holder is not lower than the
4079:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex.
4080:FreeRTOS/Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
4081:FreeRTOS/Source/tasks.c **** 					priority, but inheritance would have occurred if that had
4082:FreeRTOS/Source/tasks.c **** 					not been the case. */
4083:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
4084:FreeRTOS/Source/tasks.c **** 				}
4085:FreeRTOS/Source/tasks.c **** 				else
4086:FreeRTOS/Source/tasks.c **** 				{
4087:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4088:FreeRTOS/Source/tasks.c **** 				}
4089:FreeRTOS/Source/tasks.c **** 			}
4090:FreeRTOS/Source/tasks.c **** 		}
4091:FreeRTOS/Source/tasks.c **** 		else
4092:FreeRTOS/Source/tasks.c **** 		{
4093:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4094:FreeRTOS/Source/tasks.c **** 		}
4095:FreeRTOS/Source/tasks.c **** 
4096:FreeRTOS/Source/tasks.c **** 		return xReturn;
4097:FreeRTOS/Source/tasks.c **** 	}
4098:FreeRTOS/Source/tasks.c **** 
4099:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4100:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4101:FreeRTOS/Source/tasks.c **** 
4102:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4103:FreeRTOS/Source/tasks.c **** 
4104:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
4105:FreeRTOS/Source/tasks.c **** 	{
4106:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4107:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
4108:FreeRTOS/Source/tasks.c **** 
4109:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4110:FreeRTOS/Source/tasks.c **** 		{
4111:FreeRTOS/Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
4112:FreeRTOS/Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
4113:FreeRTOS/Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
4114:FreeRTOS/Source/tasks.c **** 			be the running state task. */
4115:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
4116:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4117:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
4118:FreeRTOS/Source/tasks.c **** 
4119:FreeRTOS/Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
4120:FreeRTOS/Source/tasks.c **** 			task? */
4121:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4122:FreeRTOS/Source/tasks.c **** 			{
4123:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
4124:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4125:FreeRTOS/Source/tasks.c **** 				{
4126:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
4127:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
4128:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
4129:FreeRTOS/Source/tasks.c **** 					holding task then it must be the running state task.  Remove
4130:FreeRTOS/Source/tasks.c **** 					the holding task from the ready/delayed list. */
4131:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4132:FreeRTOS/Source/tasks.c **** 					{
4133:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4134:FreeRTOS/Source/tasks.c **** 					}
4135:FreeRTOS/Source/tasks.c **** 					else
4136:FreeRTOS/Source/tasks.c **** 					{
4137:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4138:FreeRTOS/Source/tasks.c **** 					}
4139:FreeRTOS/Source/tasks.c **** 
4140:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
4141:FreeRTOS/Source/tasks.c **** 					new	ready list. */
4142:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4143:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
4144:FreeRTOS/Source/tasks.c **** 
4145:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
4146:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
4147:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
4148:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
4149:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4150:FreeRTOS/Source/tasks.c **** 
4151:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
4152:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
4153:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4154:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
4155:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4156:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4157:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4158:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
4159:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
4160:FreeRTOS/Source/tasks.c **** 				}
4161:FreeRTOS/Source/tasks.c **** 				else
4162:FreeRTOS/Source/tasks.c **** 				{
4163:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4164:FreeRTOS/Source/tasks.c **** 				}
4165:FreeRTOS/Source/tasks.c **** 			}
4166:FreeRTOS/Source/tasks.c **** 			else
4167:FreeRTOS/Source/tasks.c **** 			{
4168:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4169:FreeRTOS/Source/tasks.c **** 			}
4170:FreeRTOS/Source/tasks.c **** 		}
4171:FreeRTOS/Source/tasks.c **** 		else
4172:FreeRTOS/Source/tasks.c **** 		{
4173:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4174:FreeRTOS/Source/tasks.c **** 		}
4175:FreeRTOS/Source/tasks.c **** 
4176:FreeRTOS/Source/tasks.c **** 		return xReturn;
4177:FreeRTOS/Source/tasks.c **** 	}
4178:FreeRTOS/Source/tasks.c **** 
4179:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4180:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4181:FreeRTOS/Source/tasks.c **** 
4182:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4183:FreeRTOS/Source/tasks.c **** 
4184:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4185:FreeRTOS/Source/tasks.c **** 	{
4186:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4187:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4188:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4189:FreeRTOS/Source/tasks.c **** 
4190:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4191:FreeRTOS/Source/tasks.c **** 		{
4192:FreeRTOS/Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4193:FreeRTOS/Source/tasks.c **** 			one mutex. */
4194:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4195:FreeRTOS/Source/tasks.c **** 
4196:FreeRTOS/Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4197:FreeRTOS/Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4198:FreeRTOS/Source/tasks.c **** 			holding task's base priority and the priority of the highest
4199:FreeRTOS/Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4200:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4201:FreeRTOS/Source/tasks.c **** 			{
4202:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4203:FreeRTOS/Source/tasks.c **** 			}
4204:FreeRTOS/Source/tasks.c **** 			else
4205:FreeRTOS/Source/tasks.c **** 			{
4206:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4207:FreeRTOS/Source/tasks.c **** 			}
4208:FreeRTOS/Source/tasks.c **** 
4209:FreeRTOS/Source/tasks.c **** 			/* Does the priority need to change? */
4210:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4211:FreeRTOS/Source/tasks.c **** 			{
4212:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4213:FreeRTOS/Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4214:FreeRTOS/Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4215:FreeRTOS/Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4216:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4217:FreeRTOS/Source/tasks.c **** 				{
4218:FreeRTOS/Source/tasks.c **** 					/* If a task has timed out because it already holds the
4219:FreeRTOS/Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4220:FreeRTOS/Source/tasks.c **** 					its own priority. */
4221:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4222:FreeRTOS/Source/tasks.c **** 
4223:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4224:FreeRTOS/Source/tasks.c **** 					priority to facilitate determining the subject task's
4225:FreeRTOS/Source/tasks.c **** 					state. */
4226:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4227:FreeRTOS/Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4228:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4229:FreeRTOS/Source/tasks.c **** 
4230:FreeRTOS/Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4231:FreeRTOS/Source/tasks.c **** 					being used for anything else. */
4232:FreeRTOS/Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4233:FreeRTOS/Source/tasks.c **** 					{
4234:FreeRTOS/Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4235:FreeRTOS/Source/tasks.c **** 					}
4236:FreeRTOS/Source/tasks.c **** 					else
4237:FreeRTOS/Source/tasks.c **** 					{
4238:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4239:FreeRTOS/Source/tasks.c **** 					}
4240:FreeRTOS/Source/tasks.c **** 
4241:FreeRTOS/Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4242:FreeRTOS/Source/tasks.c **** 					then the task that holds the mutex could be in either the
4243:FreeRTOS/Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4244:FreeRTOS/Source/tasks.c **** 					from its current state list if it is in the Ready state as
4245:FreeRTOS/Source/tasks.c **** 					the task's priority is going to change and there is one
4246:FreeRTOS/Source/tasks.c **** 					Ready list per priority. */
4247:FreeRTOS/Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4248:FreeRTOS/Source/tasks.c **** 					{
4249:FreeRTOS/Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4250:FreeRTOS/Source/tasks.c **** 						{
4251:FreeRTOS/Source/tasks.c **** 							/* It is known that the task is in its ready list so
4252:FreeRTOS/Source/tasks.c **** 							there is no need to check again and the port level
4253:FreeRTOS/Source/tasks.c **** 							reset macro can be called directly. */
4254:FreeRTOS/Source/tasks.c **** 							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4255:FreeRTOS/Source/tasks.c **** 						}
4256:FreeRTOS/Source/tasks.c **** 						else
4257:FreeRTOS/Source/tasks.c **** 						{
4258:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4259:FreeRTOS/Source/tasks.c **** 						}
4260:FreeRTOS/Source/tasks.c **** 
4261:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4262:FreeRTOS/Source/tasks.c **** 					}
4263:FreeRTOS/Source/tasks.c **** 					else
4264:FreeRTOS/Source/tasks.c **** 					{
4265:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4266:FreeRTOS/Source/tasks.c **** 					}
4267:FreeRTOS/Source/tasks.c **** 				}
4268:FreeRTOS/Source/tasks.c **** 				else
4269:FreeRTOS/Source/tasks.c **** 				{
4270:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4271:FreeRTOS/Source/tasks.c **** 				}
4272:FreeRTOS/Source/tasks.c **** 			}
4273:FreeRTOS/Source/tasks.c **** 			else
4274:FreeRTOS/Source/tasks.c **** 			{
4275:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4276:FreeRTOS/Source/tasks.c **** 			}
4277:FreeRTOS/Source/tasks.c **** 		}
4278:FreeRTOS/Source/tasks.c **** 		else
4279:FreeRTOS/Source/tasks.c **** 		{
4280:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4281:FreeRTOS/Source/tasks.c **** 		}
4282:FreeRTOS/Source/tasks.c **** 	}
4283:FreeRTOS/Source/tasks.c **** 
4284:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4285:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4286:FreeRTOS/Source/tasks.c **** 
4287:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4288:FreeRTOS/Source/tasks.c **** 
4289:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
4290:FreeRTOS/Source/tasks.c **** 	{
4291:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4292:FreeRTOS/Source/tasks.c **** 
4293:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4294:FreeRTOS/Source/tasks.c **** 		{
4295:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4296:FreeRTOS/Source/tasks.c **** 
4297:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4298:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4299:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4300:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4301:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4302:FreeRTOS/Source/tasks.c **** 			critical section. */
4303:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4304:FreeRTOS/Source/tasks.c **** 			{
4305:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4306:FreeRTOS/Source/tasks.c **** 			}
4307:FreeRTOS/Source/tasks.c **** 		}
4308:FreeRTOS/Source/tasks.c **** 		else
4309:FreeRTOS/Source/tasks.c **** 		{
4310:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4311:FreeRTOS/Source/tasks.c **** 		}
4312:FreeRTOS/Source/tasks.c **** 	}
4313:FreeRTOS/Source/tasks.c **** 
4314:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4315:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4316:FreeRTOS/Source/tasks.c **** 
4317:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4318:FreeRTOS/Source/tasks.c **** 
4319:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
4320:FreeRTOS/Source/tasks.c **** 	{
4321:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4322:FreeRTOS/Source/tasks.c **** 		{
4323:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4324:FreeRTOS/Source/tasks.c **** 			{
4325:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4326:FreeRTOS/Source/tasks.c **** 
4327:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4328:FreeRTOS/Source/tasks.c **** 				{
4329:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
4330:FreeRTOS/Source/tasks.c **** 				}
4331:FreeRTOS/Source/tasks.c **** 				else
4332:FreeRTOS/Source/tasks.c **** 				{
4333:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4334:FreeRTOS/Source/tasks.c **** 				}
4335:FreeRTOS/Source/tasks.c **** 			}
4336:FreeRTOS/Source/tasks.c **** 			else
4337:FreeRTOS/Source/tasks.c **** 			{
4338:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4339:FreeRTOS/Source/tasks.c **** 			}
4340:FreeRTOS/Source/tasks.c **** 		}
4341:FreeRTOS/Source/tasks.c **** 		else
4342:FreeRTOS/Source/tasks.c **** 		{
4343:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4344:FreeRTOS/Source/tasks.c **** 		}
4345:FreeRTOS/Source/tasks.c **** 	}
4346:FreeRTOS/Source/tasks.c **** 
4347:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4348:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4349:FreeRTOS/Source/tasks.c **** 
4350:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4351:FreeRTOS/Source/tasks.c **** 
4352:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4353:FreeRTOS/Source/tasks.c **** 	{
4354:FreeRTOS/Source/tasks.c **** 	size_t x;
4355:FreeRTOS/Source/tasks.c **** 
4356:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
4357:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4358:FreeRTOS/Source/tasks.c **** 
4359:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4360:FreeRTOS/Source/tasks.c **** 		printed out. */
4361:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4362:FreeRTOS/Source/tasks.c **** 		{
4363:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4364:FreeRTOS/Source/tasks.c **** 		}
4365:FreeRTOS/Source/tasks.c **** 
4366:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
4367:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4368:FreeRTOS/Source/tasks.c **** 
4369:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
4370:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
4371:FreeRTOS/Source/tasks.c **** 	}
4372:FreeRTOS/Source/tasks.c **** 
4373:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4374:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4375:FreeRTOS/Source/tasks.c **** 
4376:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4377:FreeRTOS/Source/tasks.c **** 
4378:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4379:FreeRTOS/Source/tasks.c **** 	{
4380:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4381:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4382:FreeRTOS/Source/tasks.c **** 	char cStatus;
4383:FreeRTOS/Source/tasks.c **** 
4384:FreeRTOS/Source/tasks.c **** 		/*
4385:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4386:FreeRTOS/Source/tasks.c **** 		 *
4387:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4388:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4389:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4390:FreeRTOS/Source/tasks.c **** 		 *
4391:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4392:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4393:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
4394:FreeRTOS/Source/tasks.c **** 		 *
4395:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4396:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4397:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4398:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4399:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4400:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4401:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
4402:FreeRTOS/Source/tasks.c **** 		 *
4403:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4404:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4405:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
4406:FreeRTOS/Source/tasks.c **** 		 */
4407:FreeRTOS/Source/tasks.c **** 
4408:FreeRTOS/Source/tasks.c **** 
4409:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4410:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4411:FreeRTOS/Source/tasks.c **** 
4412:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4413:FreeRTOS/Source/tasks.c **** 		function is executing. */
4414:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4415:FreeRTOS/Source/tasks.c **** 
4416:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4417:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4418:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4419:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4420:FreeRTOS/Source/tasks.c **** 
4421:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4422:FreeRTOS/Source/tasks.c **** 		{
4423:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4424:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4425:FreeRTOS/Source/tasks.c **** 
4426:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4427:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4428:FreeRTOS/Source/tasks.c **** 			{
4429:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4430:FreeRTOS/Source/tasks.c **** 				{
4431:FreeRTOS/Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4432:FreeRTOS/Source/tasks.c **** 										break;
4433:FreeRTOS/Source/tasks.c **** 
4434:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4435:FreeRTOS/Source/tasks.c **** 										break;
4436:FreeRTOS/Source/tasks.c **** 
4437:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4438:FreeRTOS/Source/tasks.c **** 										break;
4439:FreeRTOS/Source/tasks.c **** 
4440:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4441:FreeRTOS/Source/tasks.c **** 										break;
4442:FreeRTOS/Source/tasks.c **** 
4443:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4444:FreeRTOS/Source/tasks.c **** 										break;
4445:FreeRTOS/Source/tasks.c **** 
4446:FreeRTOS/Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4447:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
4448:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
4449:FreeRTOS/Source/tasks.c **** 										cStatus = ( char ) 0x00;
4450:FreeRTOS/Source/tasks.c **** 										break;
4451:FreeRTOS/Source/tasks.c **** 				}
4452:FreeRTOS/Source/tasks.c **** 
4453:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4454:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
4455:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4456:FreeRTOS/Source/tasks.c **** 
4457:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
4458:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4459:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4460:FreeRTOS/Source/tasks.c **** 			}
4461:FreeRTOS/Source/tasks.c **** 
4462:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4463:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4464:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4465:FreeRTOS/Source/tasks.c **** 		}
4466:FreeRTOS/Source/tasks.c **** 		else
4467:FreeRTOS/Source/tasks.c **** 		{
4468:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4469:FreeRTOS/Source/tasks.c **** 		}
4470:FreeRTOS/Source/tasks.c **** 	}
4471:FreeRTOS/Source/tasks.c **** 
4472:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4473:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4474:FreeRTOS/Source/tasks.c **** 
4475:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4476:FreeRTOS/Source/tasks.c **** 
4477:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4478:FreeRTOS/Source/tasks.c **** 	{
4479:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4480:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4481:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4482:FreeRTOS/Source/tasks.c **** 
4483:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4484:FreeRTOS/Source/tasks.c **** 		{
4485:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4486:FreeRTOS/Source/tasks.c **** 		}
4487:FreeRTOS/Source/tasks.c **** 		#endif
4488:FreeRTOS/Source/tasks.c **** 
4489:FreeRTOS/Source/tasks.c **** 		/*
4490:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4491:FreeRTOS/Source/tasks.c **** 		 *
4492:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4493:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4494:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4495:FreeRTOS/Source/tasks.c **** 		 *
4496:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4497:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4498:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4499:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
4500:FreeRTOS/Source/tasks.c **** 		 *
4501:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4502:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4503:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4504:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4505:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4506:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4507:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
4508:FreeRTOS/Source/tasks.c **** 		 *
4509:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4510:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4511:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4512:FreeRTOS/Source/tasks.c **** 		 */
4513:FreeRTOS/Source/tasks.c **** 
4514:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4515:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4516:FreeRTOS/Source/tasks.c **** 
4517:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4518:FreeRTOS/Source/tasks.c **** 		function is executing. */
4519:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4520:FreeRTOS/Source/tasks.c **** 
4521:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4522:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4523:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4524:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4525:FreeRTOS/Source/tasks.c **** 
4526:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4527:FreeRTOS/Source/tasks.c **** 		{
4528:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4529:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4530:FreeRTOS/Source/tasks.c **** 
4531:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
4532:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
4533:FreeRTOS/Source/tasks.c **** 
4534:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
4535:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0UL )
4536:FreeRTOS/Source/tasks.c **** 			{
4537:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4538:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4539:FreeRTOS/Source/tasks.c **** 				{
4540:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4541:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4542:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4543:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4544:FreeRTOS/Source/tasks.c **** 
4545:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
4546:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
4547:FreeRTOS/Source/tasks.c **** 					easily. */
4548:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4549:FreeRTOS/Source/tasks.c **** 
4550:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4551:FreeRTOS/Source/tasks.c **** 					{
4552:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4553:FreeRTOS/Source/tasks.c **** 						{
4554:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4555:FreeRTOS/Source/tasks.c **** 						}
4556:FreeRTOS/Source/tasks.c **** 						#else
4557:FreeRTOS/Source/tasks.c **** 						{
4558:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4559:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4560:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4561:FreeRTOS/Source/tasks.c **** 						}
4562:FreeRTOS/Source/tasks.c **** 						#endif
4563:FreeRTOS/Source/tasks.c **** 					}
4564:FreeRTOS/Source/tasks.c **** 					else
4565:FreeRTOS/Source/tasks.c **** 					{
4566:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
4567:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
4568:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4569:FreeRTOS/Source/tasks.c **** 						{
4570:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4571:FreeRTOS/Source/tasks.c **** 						}
4572:FreeRTOS/Source/tasks.c **** 						#else
4573:FreeRTOS/Source/tasks.c **** 						{
4574:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4575:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4576:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4577:FreeRTOS/Source/tasks.c **** 						}
4578:FreeRTOS/Source/tasks.c **** 						#endif
4579:FreeRTOS/Source/tasks.c **** 					}
4580:FreeRTOS/Source/tasks.c **** 
4581:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4582:FreeRTOS/Source/tasks.c **** 				}
4583:FreeRTOS/Source/tasks.c **** 			}
4584:FreeRTOS/Source/tasks.c **** 			else
4585:FreeRTOS/Source/tasks.c **** 			{
4586:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4587:FreeRTOS/Source/tasks.c **** 			}
4588:FreeRTOS/Source/tasks.c **** 
4589:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4590:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4591:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4592:FreeRTOS/Source/tasks.c **** 		}
4593:FreeRTOS/Source/tasks.c **** 		else
4594:FreeRTOS/Source/tasks.c **** 		{
4595:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4596:FreeRTOS/Source/tasks.c **** 		}
4597:FreeRTOS/Source/tasks.c **** 	}
4598:FreeRTOS/Source/tasks.c **** 
4599:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4600:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4601:FreeRTOS/Source/tasks.c **** 
4602:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4603:FreeRTOS/Source/tasks.c **** {
4604:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
4605:FreeRTOS/Source/tasks.c **** 
4606:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4607:FreeRTOS/Source/tasks.c **** 
4608:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4609:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
4610:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4611:FreeRTOS/Source/tasks.c **** 
4612:FreeRTOS/Source/tasks.c **** 	return uxReturn;
4613:FreeRTOS/Source/tasks.c **** }
4614:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4615:FreeRTOS/Source/tasks.c **** 
4616:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4617:FreeRTOS/Source/tasks.c **** 
4618:FreeRTOS/Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4619:FreeRTOS/Source/tasks.c **** 	{
4620:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4621:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4622:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4623:FreeRTOS/Source/tasks.c **** 		{
4624:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4625:FreeRTOS/Source/tasks.c **** 		}
4626:FreeRTOS/Source/tasks.c **** 
4627:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
4628:FreeRTOS/Source/tasks.c **** 	}
4629:FreeRTOS/Source/tasks.c **** 
4630:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4631:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4632:FreeRTOS/Source/tasks.c **** 
4633:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4634:FreeRTOS/Source/tasks.c **** 
4635:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4636:FreeRTOS/Source/tasks.c **** 	{
4637:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
4638:FreeRTOS/Source/tasks.c **** 
4639:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4640:FreeRTOS/Source/tasks.c **** 		{
4641:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4642:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4643:FreeRTOS/Source/tasks.c **** 			{
4644:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4645:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4646:FreeRTOS/Source/tasks.c **** 
4647:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4648:FreeRTOS/Source/tasks.c **** 				{
4649:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4650:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4651:FreeRTOS/Source/tasks.c **** 
4652:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4653:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4654:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4655:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4656:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4657:FreeRTOS/Source/tasks.c **** 				}
4658:FreeRTOS/Source/tasks.c **** 				else
4659:FreeRTOS/Source/tasks.c **** 				{
4660:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4661:FreeRTOS/Source/tasks.c **** 				}
4662:FreeRTOS/Source/tasks.c **** 			}
4663:FreeRTOS/Source/tasks.c **** 			else
4664:FreeRTOS/Source/tasks.c **** 			{
4665:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4666:FreeRTOS/Source/tasks.c **** 			}
4667:FreeRTOS/Source/tasks.c **** 		}
4668:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4669:FreeRTOS/Source/tasks.c **** 
4670:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4671:FreeRTOS/Source/tasks.c **** 		{
4672:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4673:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4674:FreeRTOS/Source/tasks.c **** 
4675:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
4676:FreeRTOS/Source/tasks.c **** 			{
4677:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4678:FreeRTOS/Source/tasks.c **** 				{
4679:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4680:FreeRTOS/Source/tasks.c **** 				}
4681:FreeRTOS/Source/tasks.c **** 				else
4682:FreeRTOS/Source/tasks.c **** 				{
4683:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4684:FreeRTOS/Source/tasks.c **** 				}
4685:FreeRTOS/Source/tasks.c **** 			}
4686:FreeRTOS/Source/tasks.c **** 			else
4687:FreeRTOS/Source/tasks.c **** 			{
4688:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4689:FreeRTOS/Source/tasks.c **** 			}
4690:FreeRTOS/Source/tasks.c **** 
4691:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4692:FreeRTOS/Source/tasks.c **** 		}
4693:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4694:FreeRTOS/Source/tasks.c **** 
4695:FreeRTOS/Source/tasks.c **** 		return ulReturn;
4696:FreeRTOS/Source/tasks.c **** 	}
4697:FreeRTOS/Source/tasks.c **** 
4698:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4699:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4700:FreeRTOS/Source/tasks.c **** 
4701:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4702:FreeRTOS/Source/tasks.c **** 
4703:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4704:FreeRTOS/Source/tasks.c **** 	{
4705:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4706:FreeRTOS/Source/tasks.c **** 
4707:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4708:FreeRTOS/Source/tasks.c **** 		{
4709:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4710:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4711:FreeRTOS/Source/tasks.c **** 			{
4712:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4713:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4714:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
4715:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4716:FreeRTOS/Source/tasks.c **** 
4717:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4718:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4719:FreeRTOS/Source/tasks.c **** 
4720:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4721:FreeRTOS/Source/tasks.c **** 				{
4722:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4723:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4724:FreeRTOS/Source/tasks.c **** 
4725:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4726:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4727:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4728:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4729:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4730:FreeRTOS/Source/tasks.c **** 				}
4731:FreeRTOS/Source/tasks.c **** 				else
4732:FreeRTOS/Source/tasks.c **** 				{
4733:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4734:FreeRTOS/Source/tasks.c **** 				}
4735:FreeRTOS/Source/tasks.c **** 			}
4736:FreeRTOS/Source/tasks.c **** 			else
4737:FreeRTOS/Source/tasks.c **** 			{
4738:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4739:FreeRTOS/Source/tasks.c **** 			}
4740:FreeRTOS/Source/tasks.c **** 		}
4741:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4742:FreeRTOS/Source/tasks.c **** 
4743:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4744:FreeRTOS/Source/tasks.c **** 		{
4745:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4746:FreeRTOS/Source/tasks.c **** 
4747:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
4748:FreeRTOS/Source/tasks.c **** 			{
4749:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4750:FreeRTOS/Source/tasks.c **** 				have changed. */
4751:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4752:FreeRTOS/Source/tasks.c **** 			}
4753:FreeRTOS/Source/tasks.c **** 
4754:FreeRTOS/Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4755:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4756:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4757:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4758:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4759:FreeRTOS/Source/tasks.c **** 			{
4760:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4761:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
4762:FreeRTOS/Source/tasks.c **** 			}
4763:FreeRTOS/Source/tasks.c **** 			else
4764:FreeRTOS/Source/tasks.c **** 			{
4765:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4766:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4767:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4768:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
4769:FreeRTOS/Source/tasks.c **** 			}
4770:FreeRTOS/Source/tasks.c **** 
4771:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4772:FreeRTOS/Source/tasks.c **** 		}
4773:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4774:FreeRTOS/Source/tasks.c **** 
4775:FreeRTOS/Source/tasks.c **** 		return xReturn;
4776:FreeRTOS/Source/tasks.c **** 	}
4777:FreeRTOS/Source/tasks.c **** 
4778:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4779:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4780:FreeRTOS/Source/tasks.c **** 
4781:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4782:FreeRTOS/Source/tasks.c **** 
4783:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4784:FreeRTOS/Source/tasks.c **** 	{
4785:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4786:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4787:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4788:FreeRTOS/Source/tasks.c **** 
4789:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4790:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4791:FreeRTOS/Source/tasks.c **** 
4792:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4793:FreeRTOS/Source/tasks.c **** 		{
4794:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4795:FreeRTOS/Source/tasks.c **** 			{
4796:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4797:FreeRTOS/Source/tasks.c **** 			}
4798:FreeRTOS/Source/tasks.c **** 
4799:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4800:FreeRTOS/Source/tasks.c **** 
4801:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4802:FreeRTOS/Source/tasks.c **** 
4803:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4804:FreeRTOS/Source/tasks.c **** 			{
4805:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4806:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4807:FreeRTOS/Source/tasks.c **** 					break;
4808:FreeRTOS/Source/tasks.c **** 
4809:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4810:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4811:FreeRTOS/Source/tasks.c **** 					break;
4812:FreeRTOS/Source/tasks.c **** 
4813:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4814:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4815:FreeRTOS/Source/tasks.c **** 					break;
4816:FreeRTOS/Source/tasks.c **** 
4817:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4818:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4819:FreeRTOS/Source/tasks.c **** 					{
4820:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4821:FreeRTOS/Source/tasks.c **** 					}
4822:FreeRTOS/Source/tasks.c **** 					else
4823:FreeRTOS/Source/tasks.c **** 					{
4824:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4825:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4826:FreeRTOS/Source/tasks.c **** 					}
4827:FreeRTOS/Source/tasks.c **** 					break;
4828:FreeRTOS/Source/tasks.c **** 
4829:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4830:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4831:FreeRTOS/Source/tasks.c **** 					updated. */
4832:FreeRTOS/Source/tasks.c **** 					break;
4833:FreeRTOS/Source/tasks.c **** 
4834:FreeRTOS/Source/tasks.c **** 				default:
4835:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4836:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4837:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4838:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4839:FreeRTOS/Source/tasks.c **** 
4840:FreeRTOS/Source/tasks.c **** 					break;
4841:FreeRTOS/Source/tasks.c **** 			}
4842:FreeRTOS/Source/tasks.c **** 
4843:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY();
4844:FreeRTOS/Source/tasks.c **** 
4845:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4846:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4847:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4848:FreeRTOS/Source/tasks.c **** 			{
4849:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4850:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4851:FreeRTOS/Source/tasks.c **** 
4852:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4853:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4854:FreeRTOS/Source/tasks.c **** 
4855:FreeRTOS/Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4856:FreeRTOS/Source/tasks.c **** 				{
4857:FreeRTOS/Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4858:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4859:FreeRTOS/Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4860:FreeRTOS/Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4861:FreeRTOS/Source/tasks.c **** 					because it will automatically get reset to a new value when
4862:FreeRTOS/Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4863:FreeRTOS/Source/tasks.c **** 					tickless idling is used it might be more important to enter
4864:FreeRTOS/Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4865:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4866:FreeRTOS/Source/tasks.c **** 					earliest possible time. */
4867:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4868:FreeRTOS/Source/tasks.c **** 				}
4869:FreeRTOS/Source/tasks.c **** 				#endif
4870:FreeRTOS/Source/tasks.c **** 
4871:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4872:FreeRTOS/Source/tasks.c **** 				{
4873:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4874:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4875:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4876:FreeRTOS/Source/tasks.c **** 				}
4877:FreeRTOS/Source/tasks.c **** 				else
4878:FreeRTOS/Source/tasks.c **** 				{
4879:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4880:FreeRTOS/Source/tasks.c **** 				}
4881:FreeRTOS/Source/tasks.c **** 			}
4882:FreeRTOS/Source/tasks.c **** 			else
4883:FreeRTOS/Source/tasks.c **** 			{
4884:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4885:FreeRTOS/Source/tasks.c **** 			}
4886:FreeRTOS/Source/tasks.c **** 		}
4887:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4888:FreeRTOS/Source/tasks.c **** 
4889:FreeRTOS/Source/tasks.c **** 		return xReturn;
4890:FreeRTOS/Source/tasks.c **** 	}
4891:FreeRTOS/Source/tasks.c **** 
4892:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4893:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4894:FreeRTOS/Source/tasks.c **** 
4895:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4896:FreeRTOS/Source/tasks.c **** 
4897:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4898:FreeRTOS/Source/tasks.c **** 	{
4899:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4900:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4901:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4902:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4903:FreeRTOS/Source/tasks.c **** 
4904:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4905:FreeRTOS/Source/tasks.c **** 
4906:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4907:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4908:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4909:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4910:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4911:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4912:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4913:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4914:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4915:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4916:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4917:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4918:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4919:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4920:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4921:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4922:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4923:FreeRTOS/Source/tasks.c **** 
4924:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4925:FreeRTOS/Source/tasks.c **** 
4926:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4927:FreeRTOS/Source/tasks.c **** 		{
4928:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4929:FreeRTOS/Source/tasks.c **** 			{
4930:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4931:FreeRTOS/Source/tasks.c **** 			}
4932:FreeRTOS/Source/tasks.c **** 
4933:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4934:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4935:FreeRTOS/Source/tasks.c **** 
4936:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4937:FreeRTOS/Source/tasks.c **** 			{
4938:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4939:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4940:FreeRTOS/Source/tasks.c **** 					break;
4941:FreeRTOS/Source/tasks.c **** 
4942:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4943:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4944:FreeRTOS/Source/tasks.c **** 					break;
4945:FreeRTOS/Source/tasks.c **** 
4946:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4947:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4948:FreeRTOS/Source/tasks.c **** 					break;
4949:FreeRTOS/Source/tasks.c **** 
4950:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4951:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4952:FreeRTOS/Source/tasks.c **** 					{
4953:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4954:FreeRTOS/Source/tasks.c **** 					}
4955:FreeRTOS/Source/tasks.c **** 					else
4956:FreeRTOS/Source/tasks.c **** 					{
4957:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4958:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4959:FreeRTOS/Source/tasks.c **** 					}
4960:FreeRTOS/Source/tasks.c **** 					break;
4961:FreeRTOS/Source/tasks.c **** 
4962:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4963:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4964:FreeRTOS/Source/tasks.c **** 					updated. */
4965:FreeRTOS/Source/tasks.c **** 					break;
4966:FreeRTOS/Source/tasks.c **** 
4967:FreeRTOS/Source/tasks.c **** 				default:
4968:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4969:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4970:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4971:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4972:FreeRTOS/Source/tasks.c **** 					break;
4973:FreeRTOS/Source/tasks.c **** 			}
4974:FreeRTOS/Source/tasks.c **** 
4975:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4976:FreeRTOS/Source/tasks.c **** 
4977:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4978:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4979:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4980:FreeRTOS/Source/tasks.c **** 			{
4981:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4982:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4983:FreeRTOS/Source/tasks.c **** 
4984:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4985:FreeRTOS/Source/tasks.c **** 				{
4986:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4987:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4988:FreeRTOS/Source/tasks.c **** 				}
4989:FreeRTOS/Source/tasks.c **** 				else
4990:FreeRTOS/Source/tasks.c **** 				{
4991:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4992:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4993:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4994:FreeRTOS/Source/tasks.c **** 				}
4995:FreeRTOS/Source/tasks.c **** 
4996:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4997:FreeRTOS/Source/tasks.c **** 				{
4998:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4999:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
5000:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
5001:FreeRTOS/Source/tasks.c **** 					{
5002:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
5003:FreeRTOS/Source/tasks.c **** 					}
5004:FreeRTOS/Source/tasks.c **** 
5005:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5006:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
5007:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
5008:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
5009:FreeRTOS/Source/tasks.c **** 				}
5010:FreeRTOS/Source/tasks.c **** 				else
5011:FreeRTOS/Source/tasks.c **** 				{
5012:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5013:FreeRTOS/Source/tasks.c **** 				}
5014:FreeRTOS/Source/tasks.c **** 			}
5015:FreeRTOS/Source/tasks.c **** 		}
5016:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5017:FreeRTOS/Source/tasks.c **** 
5018:FreeRTOS/Source/tasks.c **** 		return xReturn;
5019:FreeRTOS/Source/tasks.c **** 	}
5020:FreeRTOS/Source/tasks.c **** 
5021:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5022:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5023:FreeRTOS/Source/tasks.c **** 
5024:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5025:FreeRTOS/Source/tasks.c **** 
5026:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
5027:FreeRTOS/Source/tasks.c **** 	{
5028:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
5029:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
5030:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
5031:FreeRTOS/Source/tasks.c **** 
5032:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
5033:FreeRTOS/Source/tasks.c **** 
5034:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
5035:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
5036:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
5037:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
5038:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5039:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
5040:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5041:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
5042:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
5043:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
5044:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
5045:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
5046:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
5047:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
5048:FreeRTOS/Source/tasks.c **** 		provided on the following link:
5049:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
5050:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
5051:FreeRTOS/Source/tasks.c **** 
5052:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
5053:FreeRTOS/Source/tasks.c **** 
5054:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
5055:FreeRTOS/Source/tasks.c **** 		{
5056:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
5057:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
5058:FreeRTOS/Source/tasks.c **** 
5059:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
5060:FreeRTOS/Source/tasks.c **** 			semaphore. */
5061:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
5062:FreeRTOS/Source/tasks.c **** 
5063:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
5064:FreeRTOS/Source/tasks.c **** 
5065:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
5066:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
5067:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
5068:FreeRTOS/Source/tasks.c **** 			{
5069:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
5070:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5071:FreeRTOS/Source/tasks.c **** 
5072:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
5073:FreeRTOS/Source/tasks.c **** 				{
5074:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
5075:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
5076:FreeRTOS/Source/tasks.c **** 				}
5077:FreeRTOS/Source/tasks.c **** 				else
5078:FreeRTOS/Source/tasks.c **** 				{
5079:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
5080:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
5081:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
5082:FreeRTOS/Source/tasks.c **** 				}
5083:FreeRTOS/Source/tasks.c **** 
5084:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
5085:FreeRTOS/Source/tasks.c **** 				{
5086:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
5087:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
5088:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
5089:FreeRTOS/Source/tasks.c **** 					{
5090:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
5091:FreeRTOS/Source/tasks.c **** 					}
5092:FreeRTOS/Source/tasks.c **** 
5093:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5094:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
5095:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
5096:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
5097:FreeRTOS/Source/tasks.c **** 				}
5098:FreeRTOS/Source/tasks.c **** 				else
5099:FreeRTOS/Source/tasks.c **** 				{
5100:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5101:FreeRTOS/Source/tasks.c **** 				}
5102:FreeRTOS/Source/tasks.c **** 			}
5103:FreeRTOS/Source/tasks.c **** 		}
5104:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5105:FreeRTOS/Source/tasks.c **** 	}
5106:FreeRTOS/Source/tasks.c **** 
5107:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5108:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5109:FreeRTOS/Source/tasks.c **** 
5110:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5111:FreeRTOS/Source/tasks.c **** 
5112:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
5113:FreeRTOS/Source/tasks.c **** 	{
5114:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
5115:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
5116:FreeRTOS/Source/tasks.c **** 
5117:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5118:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
5119:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
5120:FreeRTOS/Source/tasks.c **** 
5121:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
5122:FreeRTOS/Source/tasks.c **** 		{
5123:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
5124:FreeRTOS/Source/tasks.c **** 			{
5125:FreeRTOS/Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
5126:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
5127:FreeRTOS/Source/tasks.c **** 			}
5128:FreeRTOS/Source/tasks.c **** 			else
5129:FreeRTOS/Source/tasks.c **** 			{
5130:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
5131:FreeRTOS/Source/tasks.c **** 			}
5132:FreeRTOS/Source/tasks.c **** 		}
5133:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
5134:FreeRTOS/Source/tasks.c **** 
5135:FreeRTOS/Source/tasks.c **** 		return xReturn;
5136:FreeRTOS/Source/tasks.c **** 	}
5137:FreeRTOS/Source/tasks.c **** 
5138:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5139:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5140:FreeRTOS/Source/tasks.c **** 
5141:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5142:FreeRTOS/Source/tasks.c **** 
5143:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
5144:FreeRTOS/Source/tasks.c **** 	{
5145:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
5146:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
5147:FreeRTOS/Source/tasks.c **** 
5148:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5149:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
5150:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
5151:FreeRTOS/Source/tasks.c **** 
5152:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
5153:FreeRTOS/Source/tasks.c **** 		{
5154:FreeRTOS/Source/tasks.c **** 			/* Return the notification as it was before the bits were cleared,
5155:FreeRTOS/Source/tasks.c **** 			then clear the bit mask. */
5156:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
5157:FreeRTOS/Source/tasks.c **** 			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
5158:FreeRTOS/Source/tasks.c **** 		}
5159:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
5160:FreeRTOS/Source/tasks.c **** 
5161:FreeRTOS/Source/tasks.c **** 		return ulReturn;
5162:FreeRTOS/Source/tasks.c **** 	}
5163:FreeRTOS/Source/tasks.c **** 
5164:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5165:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5166:FreeRTOS/Source/tasks.c **** 
5167:FreeRTOS/Source/tasks.c **** #if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
5168:FreeRTOS/Source/tasks.c **** 
5169:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskGetIdleRunTimeCounter( void )
5170:FreeRTOS/Source/tasks.c **** 	{
5171:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle->ulRunTimeCounter;
5172:FreeRTOS/Source/tasks.c **** 	}
5173:FreeRTOS/Source/tasks.c **** 
5174:FreeRTOS/Source/tasks.c **** #endif
5175:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5176:FreeRTOS/Source/tasks.c **** 
5177:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
5178:FreeRTOS/Source/tasks.c **** {
  26               	.LM0:
  27               	.LFBB1:
  28 0000 FF92      		push r15
  29 0002 0F93      		push r16
  30 0004 1F93      		push r17
  31 0006 CF93      		push r28
  32 0008 DF93      		push r29
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 5 */
  36               	.L__stack_usage = 5
  37 000a EC01      		movw r28,r24
  38 000c F62E      		mov r15,r22
5179:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
5180:FreeRTOS/Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
  40               	.LM1:
  41 000e 0091 0000 		lds r16,xTickCount
  42 0012 1091 0000 		lds r17,xTickCount+1
5181:FreeRTOS/Source/tasks.c **** 
5182:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
5183:FreeRTOS/Source/tasks.c **** 	{
5184:FreeRTOS/Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
5185:FreeRTOS/Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
5186:FreeRTOS/Source/tasks.c **** 		when the task leaves the Blocked state. */
5187:FreeRTOS/Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
5188:FreeRTOS/Source/tasks.c **** 	}
5189:FreeRTOS/Source/tasks.c **** 	#endif
5190:FreeRTOS/Source/tasks.c **** 
5191:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5192:FreeRTOS/Source/tasks.c **** 	as the same list item is used for both lists. */
5193:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  44               	.LM2:
  45 0016 8091 0000 		lds r24,pxCurrentTCB
  46 001a 9091 0000 		lds r25,pxCurrentTCB+1
  48               	.LM3:
  49 001e 0296      		adiw r24,2
  50 0020 0E94 0000 		call uxListRemove
5194:FreeRTOS/Source/tasks.c **** 	{
5195:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5196:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5197:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
5198:FreeRTOS/Source/tasks.c **** 	}
5199:FreeRTOS/Source/tasks.c **** 	else
5200:FreeRTOS/Source/tasks.c **** 	{
5201:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5202:FreeRTOS/Source/tasks.c **** 	}
5203:FreeRTOS/Source/tasks.c **** 
5204:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5205:FreeRTOS/Source/tasks.c **** 	{
5206:FreeRTOS/Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  52               	.LM4:
  53 0024 CF3F      		cpi r28,-1
  54 0026 DC07      		cpc r29,r28
  55 0028 01F4      		brne .L2
  57               	.LM5:
  58 002a FF20      		tst r15
  59 002c 01F0      		breq .L2
5207:FreeRTOS/Source/tasks.c **** 		{
5208:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5209:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5210:FreeRTOS/Source/tasks.c **** 			indefinitely. */
5211:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  61               	.LM6:
  62 002e 6091 0000 		lds r22,pxCurrentTCB
  63 0032 7091 0000 		lds r23,pxCurrentTCB+1
  65               	.LM7:
  66 0036 6E5F      		subi r22,-2
  67 0038 7F4F      		sbci r23,-1
  68 003a 80E0      		ldi r24,lo8(xSuspendedTaskList)
  69 003c 90E0      		ldi r25,hi8(xSuspendedTaskList)
  70               	/* epilogue start */
5212:FreeRTOS/Source/tasks.c **** 		}
5213:FreeRTOS/Source/tasks.c **** 		else
5214:FreeRTOS/Source/tasks.c **** 		{
5215:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5216:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5217:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
5218:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5219:FreeRTOS/Source/tasks.c **** 
5220:FreeRTOS/Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5221:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5222:FreeRTOS/Source/tasks.c **** 
5223:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5224:FreeRTOS/Source/tasks.c **** 			{
5225:FreeRTOS/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5226:FreeRTOS/Source/tasks.c **** 				list. */
5227:FreeRTOS/Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5228:FreeRTOS/Source/tasks.c **** 			}
5229:FreeRTOS/Source/tasks.c **** 			else
5230:FreeRTOS/Source/tasks.c **** 			{
5231:FreeRTOS/Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5232:FreeRTOS/Source/tasks.c **** 				is used. */
5233:FreeRTOS/Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5234:FreeRTOS/Source/tasks.c **** 
5235:FreeRTOS/Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5236:FreeRTOS/Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5237:FreeRTOS/Source/tasks.c **** 				needs to be updated too. */
5238:FreeRTOS/Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5239:FreeRTOS/Source/tasks.c **** 				{
5240:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5241:FreeRTOS/Source/tasks.c **** 				}
5242:FreeRTOS/Source/tasks.c **** 				else
5243:FreeRTOS/Source/tasks.c **** 				{
5244:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5245:FreeRTOS/Source/tasks.c **** 				}
5246:FreeRTOS/Source/tasks.c **** 			}
5247:FreeRTOS/Source/tasks.c **** 		}
5248:FreeRTOS/Source/tasks.c **** 	}
5249:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5250:FreeRTOS/Source/tasks.c **** 	{
5251:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5252:FreeRTOS/Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5253:FreeRTOS/Source/tasks.c **** 		will manage it correctly. */
5254:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
5255:FreeRTOS/Source/tasks.c **** 
5256:FreeRTOS/Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5257:FreeRTOS/Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5258:FreeRTOS/Source/tasks.c **** 
5259:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5260:FreeRTOS/Source/tasks.c **** 		{
5261:FreeRTOS/Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5262:FreeRTOS/Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5263:FreeRTOS/Source/tasks.c **** 		}
5264:FreeRTOS/Source/tasks.c **** 		else
5265:FreeRTOS/Source/tasks.c **** 		{
5266:FreeRTOS/Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5267:FreeRTOS/Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5268:FreeRTOS/Source/tasks.c **** 
5269:FreeRTOS/Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5270:FreeRTOS/Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5271:FreeRTOS/Source/tasks.c **** 			too. */
5272:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5273:FreeRTOS/Source/tasks.c **** 			{
5274:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5275:FreeRTOS/Source/tasks.c **** 			}
5276:FreeRTOS/Source/tasks.c **** 			else
5277:FreeRTOS/Source/tasks.c **** 			{
5278:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5279:FreeRTOS/Source/tasks.c **** 			}
5280:FreeRTOS/Source/tasks.c **** 		}
5281:FreeRTOS/Source/tasks.c **** 
5282:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5283:FreeRTOS/Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5284:FreeRTOS/Source/tasks.c **** 	}
5285:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5286:FreeRTOS/Source/tasks.c **** }
  72               	.LM8:
  73 003e DF91      		pop r29
  74 0040 CF91      		pop r28
  75 0042 1F91      		pop r17
  76 0044 0F91      		pop r16
  77 0046 FF90      		pop r15
5211:FreeRTOS/Source/tasks.c **** 		}
  79               	.LM9:
  80 0048 0C94 0000 		jmp vListInsertEnd
  81               	.L2:
5218:FreeRTOS/Source/tasks.c **** 
  83               	.LM10:
  84 004c C00F      		add r28,r16
  85 004e D11F      		adc r29,r17
5221:FreeRTOS/Source/tasks.c **** 
  87               	.LM11:
  88 0050 E091 0000 		lds r30,pxCurrentTCB
  89 0054 F091 0000 		lds r31,pxCurrentTCB+1
  90 0058 D383      		std Z+3,r29
  91 005a C283      		std Z+2,r28
5227:FreeRTOS/Source/tasks.c **** 			}
  93               	.LM12:
  94 005c 6091 0000 		lds r22,pxCurrentTCB
  95 0060 7091 0000 		lds r23,pxCurrentTCB+1
5223:FreeRTOS/Source/tasks.c **** 			{
  97               	.LM13:
  98 0064 C017      		cp r28,r16
  99 0066 D107      		cpc r29,r17
 100 0068 00F4      		brsh .L3
5227:FreeRTOS/Source/tasks.c **** 			}
 102               	.LM14:
 103 006a 8091 0000 		lds r24,pxOverflowDelayedTaskList
 104 006e 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 105 0072 6E5F      		subi r22,-2
 106 0074 7F4F      		sbci r23,-1
 107               	/* epilogue start */
 109               	.LM15:
 110 0076 DF91      		pop r29
 111 0078 CF91      		pop r28
 112 007a 1F91      		pop r17
 113 007c 0F91      		pop r16
 114 007e FF90      		pop r15
5227:FreeRTOS/Source/tasks.c **** 			}
 116               	.LM16:
 117 0080 0C94 0000 		jmp vListInsert
 118               	.L3:
5233:FreeRTOS/Source/tasks.c **** 
 120               	.LM17:
 121 0084 8091 0000 		lds r24,pxDelayedTaskList
 122 0088 9091 0000 		lds r25,pxDelayedTaskList+1
 123 008c 6E5F      		subi r22,-2
 124 008e 7F4F      		sbci r23,-1
 125 0090 0E94 0000 		call vListInsert
5238:FreeRTOS/Source/tasks.c **** 				{
 127               	.LM18:
 128 0094 8091 0000 		lds r24,xNextTaskUnblockTime
 129 0098 9091 0000 		lds r25,xNextTaskUnblockTime+1
5238:FreeRTOS/Source/tasks.c **** 				{
 131               	.LM19:
 132 009c C817      		cp r28,r24
 133 009e D907      		cpc r29,r25
 134 00a0 00F4      		brsh .L1
5240:FreeRTOS/Source/tasks.c **** 				}
 136               	.LM20:
 137 00a2 D093 0000 		sts xNextTaskUnblockTime+1,r29
 138 00a6 C093 0000 		sts xNextTaskUnblockTime,r28
 139               	.L1:
 140               	/* epilogue start */
 142               	.LM21:
 143 00aa DF91      		pop r29
 144 00ac CF91      		pop r28
 145 00ae 1F91      		pop r17
 146 00b0 0F91      		pop r16
 147 00b2 FF90      		pop r15
 148 00b4 0895      		ret
 154               	.Lscope1:
 158               	prvResetNextTaskUnblockTime:
3944:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 160               	.LM22:
 161               	.LFBB2:
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
3947:FreeRTOS/Source/tasks.c **** 	{
 167               	.LM23:
 168 00b6 E091 0000 		lds r30,pxDelayedTaskList
 169 00ba F091 0000 		lds r31,pxDelayedTaskList+1
 170 00be 8081      		ld r24,Z
3947:FreeRTOS/Source/tasks.c **** 	{
 172               	.LM24:
 173 00c0 8111      		cpse r24,__zero_reg__
 174 00c2 00C0      		rjmp .L9
3953:FreeRTOS/Source/tasks.c **** 	}
 176               	.LM25:
 177 00c4 8FEF      		ldi r24,lo8(-1)
 178 00c6 9FEF      		ldi r25,lo8(-1)
 179               	.L11:
 180               	.LBB8:
 181               	.LBB9:
3962:FreeRTOS/Source/tasks.c **** 	}
 183               	.LM26:
 184 00c8 9093 0000 		sts xNextTaskUnblockTime+1,r25
 185 00cc 8093 0000 		sts xNextTaskUnblockTime,r24
 186               	/* epilogue start */
 187               	.LBE9:
 188               	.LBE8:
3964:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 190               	.LM27:
 191 00d0 0895      		ret
 192               	.L9:
 193               	.LBB11:
 194               	.LBB10:
3961:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 196               	.LM28:
 197 00d2 E091 0000 		lds r30,pxDelayedTaskList
 198 00d6 F091 0000 		lds r31,pxDelayedTaskList+1
3961:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 200               	.LM29:
 201 00da 0580      		ldd __tmp_reg__,Z+5
 202 00dc F681      		ldd r31,Z+6
 203 00de E02D      		mov r30,__tmp_reg__
3962:FreeRTOS/Source/tasks.c **** 	}
 205               	.LM30:
 206 00e0 0680      		ldd __tmp_reg__,Z+6
 207 00e2 F781      		ldd r31,Z+7
 208 00e4 E02D      		mov r30,__tmp_reg__
 209 00e6 8281      		ldd r24,Z+2
 210 00e8 9381      		ldd r25,Z+3
 211 00ea 00C0      		rjmp .L11
 212               	.LBE10:
 213               	.LBE11:
 215               	.Lscope2:
 220               	prvIdleTask:
3393:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 222               	.LM31:
 223               	.LFBB3:
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
 228               	.L13:
 229               	.LBB18:
 230               	.LBB19:
3650:FreeRTOS/Source/tasks.c **** 		{
 232               	.LM32:
 233 00ec 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
3650:FreeRTOS/Source/tasks.c **** 		{
 235               	.LM33:
 236 00f0 8111      		cpse r24,__zero_reg__
 237 00f2 00C0      		rjmp .L14
 238               	.LBE19:
 239               	.LBE18:
3432:FreeRTOS/Source/tasks.c **** 			{
 241               	.LM34:
 242 00f4 8091 0000 		lds r24,pxReadyTasksLists
3432:FreeRTOS/Source/tasks.c **** 			{
 244               	.LM35:
 245 00f8 8230      		cpi r24,lo8(2)
 246 00fa 00F0      		brlo .L15
3434:FreeRTOS/Source/tasks.c **** 			}
 248               	.LM36:
 249 00fc 0E94 0000 		call vPortYield
 250               	.L15:
 251               	.LBB23:
3452:FreeRTOS/Source/tasks.c **** 		}
 253               	.LM37:
 254 0100 0E94 0000 		call vApplicationIdleHook
 255               	.LBE23:
 256               	.LBB24:
 257               	.LBB22:
3650:FreeRTOS/Source/tasks.c **** 		{
 259               	.LM38:
 260 0104 00C0      		rjmp .L13
 261               	.L14:
3652:FreeRTOS/Source/tasks.c **** 			{
 263               	.LM39:
 264               	/* #APP */
 265               	 ;  3652 "FreeRTOS/Source/tasks.c" 1
 266 0106 0FB6      		in		__tmp_reg__, __SREG__
 267               	 ;  0 "" 2
 268               	 ;  3652 "FreeRTOS/Source/tasks.c" 1
 269 0108 F894      		cli
 270               	 ;  0 "" 2
 271               	 ;  3652 "FreeRTOS/Source/tasks.c" 1
 272 010a 0F92      		push	__tmp_reg__
 273               	 ;  0 "" 2
3654:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 275               	.LM40:
 276               	/* #NOAPP */
 277 010c E091 0000 		lds r30,xTasksWaitingTermination+5
 278 0110 F091 0000 		lds r31,xTasksWaitingTermination+5+1
 279 0114 C681      		ldd r28,Z+6
 280 0116 D781      		ldd r29,Z+7
3655:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 282               	.LM41:
 283 0118 CE01      		movw r24,r28
 284 011a 0296      		adiw r24,2
 285 011c 0E94 0000 		call uxListRemove
3656:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 287               	.LM42:
 288 0120 8091 0000 		lds r24,uxCurrentNumberOfTasks
 289 0124 8150      		subi r24,lo8(-(-1))
 290 0126 8093 0000 		sts uxCurrentNumberOfTasks,r24
3657:FreeRTOS/Source/tasks.c **** 			}
 292               	.LM43:
 293 012a 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 294 012e 8150      		subi r24,lo8(-(-1))
 295 0130 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
3659:FreeRTOS/Source/tasks.c **** 
 297               	.LM44:
 298               	/* #APP */
 299               	 ;  3659 "FreeRTOS/Source/tasks.c" 1
 300 0134 0F90      		pop		__tmp_reg__
 301               	 ;  0 "" 2
 302               	 ;  3659 "FreeRTOS/Source/tasks.c" 1
 303 0136 0FBE      		out		__SREG__, __tmp_reg__
 304               	 ;  0 "" 2
 305               	/* #NOAPP */
 306               	.LBB20:
 307               	.LBB21:
3908:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 309               	.LM45:
 310 0138 8F89      		ldd r24,Y+23
 311 013a 988D      		ldd r25,Y+24
 312 013c 0E94 0000 		call vPortFree
3909:FreeRTOS/Source/tasks.c **** 		}
 314               	.LM46:
 315 0140 CE01      		movw r24,r28
 316 0142 0E94 0000 		call vPortFree
3938:FreeRTOS/Source/tasks.c **** 
 318               	.LM47:
 319 0146 00C0      		rjmp .L13
 320               	.LBE21:
 321               	.LBE20:
 322               	.LBE22:
 323               	.LBE24:
 341               	.Lscope3:
 353               	.global	xTaskCreate
 355               	xTaskCreate:
 739:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 357               	.LM48:
 358               	.LFBB4:
 359 0148 2F92      		push r2
 360 014a 3F92      		push r3
 361 014c 4F92      		push r4
 362 014e 5F92      		push r5
 363 0150 6F92      		push r6
 364 0152 7F92      		push r7
 365 0154 8F92      		push r8
 366 0156 9F92      		push r9
 367 0158 AF92      		push r10
 368 015a BF92      		push r11
 369 015c CF92      		push r12
 370 015e DF92      		push r13
 371 0160 EF92      		push r14
 372 0162 FF92      		push r15
 373 0164 0F93      		push r16
 374 0166 CF93      		push r28
 375 0168 DF93      		push r29
 376               	/* prologue: function */
 377               	/* frame size = 0 */
 378               	/* stack size = 17 */
 379               	.L__stack_usage = 17
 380 016a 6C01      		movw r12,r24
 381 016c 3B01      		movw r6,r22
 382 016e 5A01      		movw r10,r20
 383 0170 1901      		movw r2,r18
 384 0172 2701      		movw r4,r14
 385               	.LBB32:
 773:FreeRTOS/Source/tasks.c **** 
 387               	.LM49:
 388 0174 CA01      		movw r24,r20
 389 0176 0E94 0000 		call pvPortMalloc
 390 017a 4C01      		movw r8,r24
 775:FreeRTOS/Source/tasks.c **** 			{
 392               	.LM50:
 393 017c 892B      		or r24,r25
 394 017e 01F0      		breq .L32
 778:FreeRTOS/Source/tasks.c **** 
 396               	.LM51:
 397 0180 88E2      		ldi r24,lo8(40)
 398 0182 90E0      		ldi r25,0
 399 0184 0E94 0000 		call pvPortMalloc
 400 0188 EC01      		movw r28,r24
 780:FreeRTOS/Source/tasks.c **** 				{
 402               	.LM52:
 403 018a 0097      		sbiw r24,0
 404 018c 01F0      		breq .L19
 783:FreeRTOS/Source/tasks.c **** 				}
 406               	.LM53:
 407 018e 988E      		std Y+24,r9
 408 0190 8F8A      		std Y+23,r8
 409               	.LBE32:
 410               	.LBB33:
 411               	.LBB34:
 892:FreeRTOS/Source/tasks.c **** 	{
 413               	.LM54:
 414 0192 6114      		cp r6,__zero_reg__
 415 0194 7104      		cpc r7,__zero_reg__
 416 0196 01F4      		brne .L20
 919:FreeRTOS/Source/tasks.c **** 	}
 418               	.LM55:
 419 0198 198E      		std Y+25,__zero_reg__
 420 019a 00C0      		rjmp .L24
 421               	.L19:
 422               	.LBE34:
 423               	.LBE33:
 424               	.LBB36:
 789:FreeRTOS/Source/tasks.c **** 				}
 426               	.LM56:
 427 019c C401      		movw r24,r8
 428 019e 0E94 0000 		call vPortFree
 429               	.L32:
 430               	.LBE36:
 815:FreeRTOS/Source/tasks.c **** 		}
 432               	.LM57:
 433 01a2 8FEF      		ldi r24,lo8(-1)
 434               	.L17:
 435               	/* epilogue start */
 819:FreeRTOS/Source/tasks.c **** 
 437               	.LM58:
 438 01a4 DF91      		pop r29
 439 01a6 CF91      		pop r28
 440 01a8 0F91      		pop r16
 441 01aa FF90      		pop r15
 442 01ac EF90      		pop r14
 443 01ae DF90      		pop r13
 444 01b0 CF90      		pop r12
 445 01b2 BF90      		pop r11
 446 01b4 AF90      		pop r10
 447 01b6 9F90      		pop r9
 448 01b8 8F90      		pop r8
 449 01ba 7F90      		pop r7
 450 01bc 6F90      		pop r6
 451 01be 5F90      		pop r5
 452 01c0 4F90      		pop r4
 453 01c2 3F90      		pop r3
 454 01c4 2F90      		pop r2
 455 01c6 0895      		ret
 456               	.L20:
 457 01c8 F301      		movw r30,r6
 458 01ca AC01      		movw r20,r24
 459 01cc 475E      		subi r20,-25
 460 01ce 5F4F      		sbci r21,-1
 461 01d0 C301      		movw r24,r6
 462 01d2 0896      		adiw r24,8
 463               	.L23:
 464               	.LBB37:
 465               	.LBB35:
 896:FreeRTOS/Source/tasks.c **** 
 467               	.LM59:
 468 01d4 2191      		ld r18,Z+
 896:FreeRTOS/Source/tasks.c **** 
 470               	.LM60:
 471 01d6 DA01      		movw r26,r20
 472 01d8 2D93      		st X+,r18
 473 01da AD01      		movw r20,r26
 901:FreeRTOS/Source/tasks.c **** 			{
 475               	.LM61:
 476 01dc 9F01      		movw r18,r30
 477 01de 2150      		subi r18,1
 478 01e0 3109      		sbc r19,__zero_reg__
 901:FreeRTOS/Source/tasks.c **** 			{
 480               	.LM62:
 481 01e2 D901      		movw r26,r18
 482 01e4 2C91      		ld r18,X
 483 01e6 2223      		tst r18
 484 01e8 01F0      		breq .L22
 894:FreeRTOS/Source/tasks.c **** 		{
 486               	.LM63:
 487 01ea 8E17      		cp r24,r30
 488 01ec 9F07      		cpc r25,r31
 489 01ee 01F4      		brne .L23
 490               	.L22:
 913:FreeRTOS/Source/tasks.c **** 	}
 492               	.LM64:
 493 01f0 18A2      		std Y+32,__zero_reg__
 494               	.L24:
 495 01f2 0430      		cpi r16,lo8(4)
 496 01f4 00F0      		brlo .L25
 497 01f6 03E0      		ldi r16,lo8(3)
 498               	.L25:
 933:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 500               	.LM65:
 501 01f8 0E8B      		std Y+22,r16
 936:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 503               	.LM66:
 504 01fa 09A3      		std Y+33,r16
 937:FreeRTOS/Source/tasks.c **** 	}
 506               	.LM67:
 507 01fc 1AA2      		std Y+34,__zero_reg__
 941:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 509               	.LM68:
 510 01fe 7E01      		movw r14,r28
 511 0200 B2E0      		ldi r27,2
 512 0202 EB0E      		add r14,r27
 513 0204 F11C      		adc r15,__zero_reg__
 514 0206 C701      		movw r24,r14
 515 0208 0E94 0000 		call vListInitialiseItem
 942:FreeRTOS/Source/tasks.c **** 
 517               	.LM69:
 518 020c CE01      		movw r24,r28
 519 020e 0C96      		adiw r24,12
 520 0210 0E94 0000 		call vListInitialiseItem
 946:FreeRTOS/Source/tasks.c **** 
 522               	.LM70:
 523 0214 D987      		std Y+9,r29
 524 0216 C887      		std Y+8,r28
 949:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 526               	.LM71:
 527 0218 84E0      		ldi r24,lo8(4)
 528 021a 90E0      		ldi r25,0
 529 021c 801B      		sub r24,r16
 530 021e 9109      		sbc r25,__zero_reg__
 531 0220 9D87      		std Y+13,r25
 532 0222 8C87      		std Y+12,r24
 950:FreeRTOS/Source/tasks.c **** 
 534               	.LM72:
 535 0224 DB8B      		std Y+19,r29
 536 0226 CA8B      		std Y+18,r28
 992:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 538               	.LM73:
 539 0228 1BA2      		std Y+35,__zero_reg__
 540 022a 1CA2      		std Y+36,__zero_reg__
 541 022c 1DA2      		std Y+37,__zero_reg__
 542 022e 1EA2      		std Y+38,__zero_reg__
 993:FreeRTOS/Source/tasks.c **** 	}
 544               	.LM74:
 545 0230 1FA2      		std Y+39,__zero_reg__
 864:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 547               	.LM75:
 548 0232 C501      		movw r24,r10
 549 0234 0197      		sbiw r24,1
1058:FreeRTOS/Source/tasks.c **** 		}
 551               	.LM76:
 552 0236 A101      		movw r20,r2
 553 0238 B601      		movw r22,r12
 554 023a 880D      		add r24,r8
 555 023c 991D      		adc r25,r9
 556 023e 0E94 0000 		call pxPortInitialiseStack
1058:FreeRTOS/Source/tasks.c **** 		}
 558               	.LM77:
 559 0242 9983      		std Y+1,r25
 560 0244 8883      		st Y,r24
1064:FreeRTOS/Source/tasks.c **** 	{
 562               	.LM78:
 563 0246 4114      		cp r4,__zero_reg__
 564 0248 5104      		cpc r5,__zero_reg__
 565 024a 01F0      		breq .L26
1068:FreeRTOS/Source/tasks.c **** 	}
 567               	.LM79:
 568 024c F201      		movw r30,r4
 569 024e D183      		std Z+1,r29
 570 0250 C083      		st Z,r28
 571               	.L26:
 572               	.LBE35:
 573               	.LBE37:
 574               	.LBB38:
 575               	.LBB39:
1081:FreeRTOS/Source/tasks.c **** 	{
 577               	.LM80:
 578               	/* #APP */
 579               	 ;  1081 "FreeRTOS/Source/tasks.c" 1
 580 0252 0FB6      		in		__tmp_reg__, __SREG__
 581               	 ;  0 "" 2
 582               	 ;  1081 "FreeRTOS/Source/tasks.c" 1
 583 0254 F894      		cli
 584               	 ;  0 "" 2
 585               	 ;  1081 "FreeRTOS/Source/tasks.c" 1
 586 0256 0F92      		push	__tmp_reg__
 587               	 ;  0 "" 2
1083:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 589               	.LM81:
 590               	/* #NOAPP */
 591 0258 8091 0000 		lds r24,uxCurrentNumberOfTasks
 592 025c 8F5F      		subi r24,lo8(-(1))
 593 025e 8093 0000 		sts uxCurrentNumberOfTasks,r24
1084:FreeRTOS/Source/tasks.c **** 		{
 595               	.LM82:
 596 0262 8091 0000 		lds r24,pxCurrentTCB
 597 0266 9091 0000 		lds r25,pxCurrentTCB+1
1084:FreeRTOS/Source/tasks.c **** 		{
 599               	.LM83:
 600 026a 892B      		or r24,r25
 601 026c 01F0      		breq .+2
 602 026e 00C0      		rjmp .L27
1088:FreeRTOS/Source/tasks.c **** 
 604               	.LM84:
 605 0270 D093 0000 		sts pxCurrentTCB+1,r29
 606 0274 C093 0000 		sts pxCurrentTCB,r28
1090:FreeRTOS/Source/tasks.c **** 			{
 608               	.LM85:
 609 0278 8091 0000 		lds r24,uxCurrentNumberOfTasks
1090:FreeRTOS/Source/tasks.c **** 			{
 611               	.LM86:
 612 027c 8130      		cpi r24,lo8(1)
 613 027e 01F4      		brne .L29
 614               	.LBB40:
 615               	.LBB41:
3613:FreeRTOS/Source/tasks.c **** 	}
 617               	.LM87:
 618 0280 80E0      		ldi r24,lo8(pxReadyTasksLists)
 619 0282 90E0      		ldi r25,hi8(pxReadyTasksLists)
 620 0284 0E94 0000 		call vListInitialise
 621 0288 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 622 028a 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 623 028c 0E94 0000 		call vListInitialise
 624 0290 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 625 0292 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 626 0294 0E94 0000 		call vListInitialise
 627 0298 80E0      		ldi r24,lo8(pxReadyTasksLists+27)
 628 029a 90E0      		ldi r25,hi8(pxReadyTasksLists+27)
 629 029c 0E94 0000 		call vListInitialise
3616:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 631               	.LM88:
 632 02a0 80E0      		ldi r24,lo8(xDelayedTaskList1)
 633 02a2 90E0      		ldi r25,hi8(xDelayedTaskList1)
 634 02a4 0E94 0000 		call vListInitialise
3617:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 636               	.LM89:
 637 02a8 80E0      		ldi r24,lo8(xDelayedTaskList2)
 638 02aa 90E0      		ldi r25,hi8(xDelayedTaskList2)
 639 02ac 0E94 0000 		call vListInitialise
3618:FreeRTOS/Source/tasks.c **** 
 641               	.LM90:
 642 02b0 80E0      		ldi r24,lo8(xPendingReadyList)
 643 02b2 90E0      		ldi r25,hi8(xPendingReadyList)
 644 02b4 0E94 0000 		call vListInitialise
3622:FreeRTOS/Source/tasks.c **** 	}
 646               	.LM91:
 647 02b8 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 648 02ba 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 649 02bc 0E94 0000 		call vListInitialise
3628:FreeRTOS/Source/tasks.c **** 	}
 651               	.LM92:
 652 02c0 80E0      		ldi r24,lo8(xSuspendedTaskList)
 653 02c2 90E0      		ldi r25,hi8(xSuspendedTaskList)
 654 02c4 0E94 0000 		call vListInitialise
3634:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 656               	.LM93:
 657 02c8 80E0      		ldi r24,lo8(xDelayedTaskList1)
 658 02ca 90E0      		ldi r25,hi8(xDelayedTaskList1)
 659 02cc 9093 0000 		sts pxDelayedTaskList+1,r25
 660 02d0 8093 0000 		sts pxDelayedTaskList,r24
3635:FreeRTOS/Source/tasks.c **** }
 662               	.LM94:
 663 02d4 80E0      		ldi r24,lo8(xDelayedTaskList2)
 664 02d6 90E0      		ldi r25,hi8(xDelayedTaskList2)
 665 02d8 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 666 02dc 8093 0000 		sts pxOverflowDelayedTaskList,r24
 667               	.L29:
 668               	.LBE41:
 669               	.LBE40:
1124:FreeRTOS/Source/tasks.c **** 
 671               	.LM95:
 672 02e0 8091 0000 		lds r24,uxTaskNumber
 673 02e4 8F5F      		subi r24,lo8(-(1))
 674 02e6 8093 0000 		sts uxTaskNumber,r24
1134:FreeRTOS/Source/tasks.c **** 
 676               	.LM96:
 677 02ea 8E89      		ldd r24,Y+22
 678 02ec 9091 0000 		lds r25,uxTopReadyPriority
 679 02f0 9817      		cp r25,r24
 680 02f2 00F4      		brsh .L31
 681 02f4 8093 0000 		sts uxTopReadyPriority,r24
 682               	.L31:
 683 02f8 F9E0      		ldi r31,lo8(9)
 684 02fa 8F9F      		mul r24,r31
 685 02fc C001      		movw r24,r0
 686 02fe 1124      		clr __zero_reg__
 687 0300 B701      		movw r22,r14
 688 0302 8050      		subi r24,lo8(-(pxReadyTasksLists))
 689 0304 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 690 0306 0E94 0000 		call vListInsertEnd
1138:FreeRTOS/Source/tasks.c **** 
 692               	.LM97:
 693               	/* #APP */
 694               	 ;  1138 "FreeRTOS/Source/tasks.c" 1
 695 030a 0F90      		pop		__tmp_reg__
 696               	 ;  0 "" 2
 697               	 ;  1138 "FreeRTOS/Source/tasks.c" 1
 698 030c 0FBE      		out		__SREG__, __tmp_reg__
 699               	 ;  0 "" 2
1140:FreeRTOS/Source/tasks.c **** 	{
 701               	.LM98:
 702               	/* #NOAPP */
 703 030e 8091 0000 		lds r24,xSchedulerRunning
1140:FreeRTOS/Source/tasks.c **** 	{
 705               	.LM99:
 706 0312 8823      		tst r24
 707 0314 01F0      		breq .L34
1144:FreeRTOS/Source/tasks.c **** 		{
 709               	.LM100:
 710 0316 E091 0000 		lds r30,pxCurrentTCB
 711 031a F091 0000 		lds r31,pxCurrentTCB+1
1144:FreeRTOS/Source/tasks.c **** 		{
 713               	.LM101:
 714 031e 9689      		ldd r25,Z+22
 715 0320 8E89      		ldd r24,Y+22
 716 0322 9817      		cp r25,r24
 717 0324 00F4      		brsh .L34
1146:FreeRTOS/Source/tasks.c **** 		}
 719               	.LM102:
 720 0326 0E94 0000 		call vPortYield
 721               	.L34:
 722               	.LBE39:
 723               	.LBE38:
 811:FreeRTOS/Source/tasks.c **** 		}
 725               	.LM103:
 726 032a 81E0      		ldi r24,lo8(1)
 818:FreeRTOS/Source/tasks.c **** 	}
 728               	.LM104:
 729 032c 00C0      		rjmp .L17
 730               	.L27:
 731               	.LBB43:
 732               	.LBB42:
1107:FreeRTOS/Source/tasks.c **** 			{
 734               	.LM105:
 735 032e 8091 0000 		lds r24,xSchedulerRunning
1107:FreeRTOS/Source/tasks.c **** 			{
 737               	.LM106:
 738 0332 8111      		cpse r24,__zero_reg__
 739 0334 00C0      		rjmp .L29
1109:FreeRTOS/Source/tasks.c **** 				{
 741               	.LM107:
 742 0336 E091 0000 		lds r30,pxCurrentTCB
 743 033a F091 0000 		lds r31,pxCurrentTCB+1
1109:FreeRTOS/Source/tasks.c **** 				{
 745               	.LM108:
 746 033e 9689      		ldd r25,Z+22
 747 0340 8E89      		ldd r24,Y+22
 748 0342 8917      		cp r24,r25
 749 0344 00F0      		brlo .L29
1111:FreeRTOS/Source/tasks.c **** 				}
 751               	.LM109:
 752 0346 D093 0000 		sts pxCurrentTCB+1,r29
 753 034a C093 0000 		sts pxCurrentTCB,r28
 754 034e 00C0      		rjmp .L29
 755               	.LBE42:
 756               	.LBE43:
 774               	.Lscope4:
 778               	.global	vTaskDelete
 780               	vTaskDelete:
1163:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 782               	.LM110:
 783               	.LFBB5:
 784 0350 0F93      		push r16
 785 0352 1F93      		push r17
 786 0354 CF93      		push r28
 787 0356 DF93      		push r29
 788               	/* prologue: function */
 789               	/* frame size = 0 */
 790               	/* stack size = 4 */
 791               	.L__stack_usage = 4
 792 0358 8C01      		movw r16,r24
1166:FreeRTOS/Source/tasks.c **** 		{
 794               	.LM111:
 795               	/* #APP */
 796               	 ;  1166 "FreeRTOS/Source/tasks.c" 1
 797 035a 0FB6      		in		__tmp_reg__, __SREG__
 798               	 ;  0 "" 2
 799               	 ;  1166 "FreeRTOS/Source/tasks.c" 1
 800 035c F894      		cli
 801               	 ;  0 "" 2
 802               	 ;  1166 "FreeRTOS/Source/tasks.c" 1
 803 035e 0F92      		push	__tmp_reg__
 804               	 ;  0 "" 2
1170:FreeRTOS/Source/tasks.c **** 
 806               	.LM112:
 807               	/* #NOAPP */
 808 0360 892B      		or r24,r25
 809 0362 01F4      		brne .L44
1170:FreeRTOS/Source/tasks.c **** 
 811               	.LM113:
 812 0364 0091 0000 		lds r16,pxCurrentTCB
 813 0368 1091 0000 		lds r17,pxCurrentTCB+1
 814               	.L44:
1173:FreeRTOS/Source/tasks.c **** 			{
 816               	.LM114:
 817 036c E801      		movw r28,r16
 818 036e 2296      		adiw r28,2
 819 0370 CE01      		movw r24,r28
 820 0372 0E94 0000 		call uxListRemove
1183:FreeRTOS/Source/tasks.c **** 			{
 822               	.LM115:
 823 0376 F801      		movw r30,r16
 824 0378 8489      		ldd r24,Z+20
 825 037a 9589      		ldd r25,Z+21
 826 037c 892B      		or r24,r25
 827 037e 01F0      		breq .L45
1185:FreeRTOS/Source/tasks.c **** 			}
 829               	.LM116:
 830 0380 C801      		movw r24,r16
 831 0382 0C96      		adiw r24,12
 832 0384 0E94 0000 		call uxListRemove
 833               	.L45:
1196:FreeRTOS/Source/tasks.c **** 
 835               	.LM117:
 836 0388 8091 0000 		lds r24,uxTaskNumber
 837 038c 8F5F      		subi r24,lo8(-(1))
 838 038e 8093 0000 		sts uxTaskNumber,r24
1198:FreeRTOS/Source/tasks.c **** 			{
 840               	.LM118:
 841 0392 8091 0000 		lds r24,pxCurrentTCB
 842 0396 9091 0000 		lds r25,pxCurrentTCB+1
1198:FreeRTOS/Source/tasks.c **** 			{
 844               	.LM119:
 845 039a 8017      		cp r24,r16
 846 039c 9107      		cpc r25,r17
 847 039e 01F4      		brne .L46
1205:FreeRTOS/Source/tasks.c **** 
 849               	.LM120:
 850 03a0 BE01      		movw r22,r28
 851 03a2 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 852 03a4 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 853 03a6 0E94 0000 		call vListInsertEnd
1210:FreeRTOS/Source/tasks.c **** 
 855               	.LM121:
 856 03aa 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 857 03ae 8F5F      		subi r24,lo8(-(1))
 858 03b0 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
 859               	.L47:
1234:FreeRTOS/Source/tasks.c **** 
 861               	.LM122:
 862               	/* #APP */
 863               	 ;  1234 "FreeRTOS/Source/tasks.c" 1
 864 03b4 0F90      		pop		__tmp_reg__
 865               	 ;  0 "" 2
 866               	 ;  1234 "FreeRTOS/Source/tasks.c" 1
 867 03b6 0FBE      		out		__SREG__, __tmp_reg__
 868               	 ;  0 "" 2
1238:FreeRTOS/Source/tasks.c **** 		{
 870               	.LM123:
 871               	/* #NOAPP */
 872 03b8 8091 0000 		lds r24,xSchedulerRunning
1238:FreeRTOS/Source/tasks.c **** 		{
 874               	.LM124:
 875 03bc 8823      		tst r24
 876 03be 01F0      		breq .L43
1240:FreeRTOS/Source/tasks.c **** 			{
 878               	.LM125:
 879 03c0 8091 0000 		lds r24,pxCurrentTCB
 880 03c4 9091 0000 		lds r25,pxCurrentTCB+1
1240:FreeRTOS/Source/tasks.c **** 			{
 882               	.LM126:
 883 03c8 8017      		cp r24,r16
 884 03ca 9107      		cpc r25,r17
 885 03cc 01F4      		brne .L43
1243:FreeRTOS/Source/tasks.c **** 			}
 887               	.LM127:
 888 03ce 0E94 0000 		call vPortYield
 889               	.L43:
 890               	/* epilogue start */
1250:FreeRTOS/Source/tasks.c **** 
 892               	.LM128:
 893 03d2 DF91      		pop r29
 894 03d4 CF91      		pop r28
 895 03d6 1F91      		pop r17
 896 03d8 0F91      		pop r16
 897 03da 0895      		ret
 898               	.L46:
1225:FreeRTOS/Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
 900               	.LM129:
 901 03dc 8091 0000 		lds r24,uxCurrentNumberOfTasks
 902 03e0 8150      		subi r24,lo8(-(-1))
 903 03e2 8093 0000 		sts uxCurrentNumberOfTasks,r24
 904               	.LBB46:
 905               	.LBB47:
3908:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 907               	.LM130:
 908 03e6 F801      		movw r30,r16
 909 03e8 8789      		ldd r24,Z+23
 910 03ea 908D      		ldd r25,Z+24
 911 03ec 0E94 0000 		call vPortFree
3909:FreeRTOS/Source/tasks.c **** 		}
 913               	.LM131:
 914 03f0 C801      		movw r24,r16
 915 03f2 0E94 0000 		call vPortFree
 916               	.LBE47:
 917               	.LBE46:
1231:FreeRTOS/Source/tasks.c **** 			}
 919               	.LM132:
 920 03f6 0E94 0000 		call prvResetNextTaskUnblockTime
 921 03fa 00C0      		rjmp .L47
 923               	.Lscope5:
 927               	.global	vTaskResume
 929               	vTaskResume:
1852:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 931               	.LM133:
 932               	.LFBB6:
 933 03fc 0F93      		push r16
 934 03fe 1F93      		push r17
 935 0400 CF93      		push r28
 936 0402 DF93      		push r29
 937               	/* prologue: function */
 938               	/* frame size = 0 */
 939               	/* stack size = 4 */
 940               	.L__stack_usage = 4
 941 0404 8C01      		movw r16,r24
1860:FreeRTOS/Source/tasks.c **** 		{
 943               	.LM134:
 944 0406 8091 0000 		lds r24,pxCurrentTCB
 945 040a 9091 0000 		lds r25,pxCurrentTCB+1
1860:FreeRTOS/Source/tasks.c **** 		{
 947               	.LM135:
 948 040e 8017      		cp r24,r16
 949 0410 9107      		cpc r25,r17
 950 0412 01F4      		brne .+2
 951 0414 00C0      		rjmp .L55
1860:FreeRTOS/Source/tasks.c **** 		{
 953               	.LM136:
 954 0416 0115      		cp r16,__zero_reg__
 955 0418 1105      		cpc r17,__zero_reg__
 956 041a 01F0      		breq .L55
1862:FreeRTOS/Source/tasks.c **** 			{
 958               	.LM137:
 959               	/* #APP */
 960               	 ;  1862 "FreeRTOS/Source/tasks.c" 1
 961 041c 0FB6      		in		__tmp_reg__, __SREG__
 962               	 ;  0 "" 2
 963               	 ;  1862 "FreeRTOS/Source/tasks.c" 1
 964 041e F894      		cli
 965               	 ;  0 "" 2
 966               	 ;  1862 "FreeRTOS/Source/tasks.c" 1
 967 0420 0F92      		push	__tmp_reg__
 968               	 ;  0 "" 2
 969               	/* #NOAPP */
 970               	.LBB52:
 971               	.LBB53:
1817:FreeRTOS/Source/tasks.c **** 		{
 973               	.LM138:
 974 0422 D801      		movw r26,r16
 975 0424 1A96      		adiw r26,10
 976 0426 8D91      		ld r24,X+
 977 0428 9C91      		ld r25,X
 978 042a 8050      		subi r24,lo8(xSuspendedTaskList)
 979 042c 9040      		sbci r25,hi8(xSuspendedTaskList)
 980 042e 01F4      		brne .L58
 981               	.LBB54:
 982               	.LBB55:
1820:FreeRTOS/Source/tasks.c **** 			{
 984               	.LM139:
 985 0430 F801      		movw r30,r16
 986 0432 8489      		ldd r24,Z+20
 987 0434 9589      		ldd r25,Z+21
1820:FreeRTOS/Source/tasks.c **** 			{
 989               	.LM140:
 990 0436 F0E0      		ldi r31,hi8(xPendingReadyList)
 991 0438 8030      		cpi r24,lo8(xPendingReadyList)
 992 043a 9F07      		cpc r25,r31
 993 043c 01F0      		breq .L58
1824:FreeRTOS/Source/tasks.c **** 				{
 995               	.LM141:
 996 043e 892B      		or r24,r25
 997 0440 01F4      		brne .L58
 998               	.LBE55:
 999               	.LBE54:
 1000               	.LBE53:
 1001               	.LBE52:
1870:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1003               	.LM142:
 1004 0442 E801      		movw r28,r16
 1005 0444 2296      		adiw r28,2
 1006 0446 CE01      		movw r24,r28
 1007 0448 0E94 0000 		call uxListRemove
1871:FreeRTOS/Source/tasks.c **** 
 1009               	.LM143:
 1010 044c D801      		movw r26,r16
 1011 044e 5696      		adiw r26,22
 1012 0450 8C91      		ld r24,X
 1013 0452 9091 0000 		lds r25,uxTopReadyPriority
 1014 0456 9817      		cp r25,r24
 1015 0458 00F4      		brsh .L60
1871:FreeRTOS/Source/tasks.c **** 
 1017               	.LM144:
 1018 045a 8093 0000 		sts uxTopReadyPriority,r24
 1019               	.L60:
1871:FreeRTOS/Source/tasks.c **** 
 1021               	.LM145:
 1022 045e B9E0      		ldi r27,lo8(9)
 1023 0460 8B9F      		mul r24,r27
 1024 0462 C001      		movw r24,r0
 1025 0464 1124      		clr __zero_reg__
 1026 0466 BE01      		movw r22,r28
 1027 0468 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1028 046a 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1029 046c 0E94 0000 		call vListInsertEnd
1874:FreeRTOS/Source/tasks.c **** 					{
 1031               	.LM146:
 1032 0470 E091 0000 		lds r30,pxCurrentTCB
 1033 0474 F091 0000 		lds r31,pxCurrentTCB+1
1874:FreeRTOS/Source/tasks.c **** 					{
 1035               	.LM147:
 1036 0478 D801      		movw r26,r16
 1037 047a 5696      		adiw r26,22
 1038 047c 9C91      		ld r25,X
 1039 047e 8689      		ldd r24,Z+22
 1040 0480 9817      		cp r25,r24
 1041 0482 00F0      		brlo .L58
1879:FreeRTOS/Source/tasks.c **** 					}
 1043               	.LM148:
 1044 0484 0E94 0000 		call vPortYield
 1045               	.L58:
1891:FreeRTOS/Source/tasks.c **** 		}
 1047               	.LM149:
 1048               	/* #APP */
 1049               	 ;  1891 "FreeRTOS/Source/tasks.c" 1
 1050 0488 0F90      		pop		__tmp_reg__
 1051               	 ;  0 "" 2
 1052               	 ;  1891 "FreeRTOS/Source/tasks.c" 1
 1053 048a 0FBE      		out		__SREG__, __tmp_reg__
 1054               	 ;  0 "" 2
 1055               	/* #NOAPP */
 1056               	.L55:
 1057               	/* epilogue start */
1897:FreeRTOS/Source/tasks.c **** 
 1059               	.LM150:
 1060 048c DF91      		pop r29
 1061 048e CF91      		pop r28
 1062 0490 1F91      		pop r17
 1063 0492 0F91      		pop r16
 1064 0494 0895      		ret
 1066               	.Lscope6:
 1070               	.global	xTaskResumeFromISR
 1072               	xTaskResumeFromISR:
1906:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1074               	.LM151:
 1075               	.LFBB7:
 1076 0496 EF92      		push r14
 1077 0498 FF92      		push r15
 1078 049a 1F93      		push r17
 1079 049c CF93      		push r28
 1080 049e DF93      		push r29
 1081               	/* prologue: function */
 1082               	/* frame size = 0 */
 1083               	/* stack size = 5 */
 1084               	.L__stack_usage = 5
 1085 04a0 7C01      		movw r14,r24
 1086               	.LBB60:
 1087               	.LBB61:
1817:FreeRTOS/Source/tasks.c **** 		{
 1089               	.LM152:
 1090 04a2 DC01      		movw r26,r24
 1091 04a4 1A96      		adiw r26,10
 1092 04a6 8D91      		ld r24,X+
 1093 04a8 9C91      		ld r25,X
 1094 04aa 8050      		subi r24,lo8(xSuspendedTaskList)
 1095 04ac 9040      		sbci r25,hi8(xSuspendedTaskList)
 1096 04ae 01F4      		brne .L74
 1097               	.LBB62:
 1098               	.LBB63:
1820:FreeRTOS/Source/tasks.c **** 			{
 1100               	.LM153:
 1101 04b0 F701      		movw r30,r14
 1102 04b2 8489      		ldd r24,Z+20
 1103 04b4 9589      		ldd r25,Z+21
1820:FreeRTOS/Source/tasks.c **** 			{
 1105               	.LM154:
 1106 04b6 F0E0      		ldi r31,hi8(xPendingReadyList)
 1107 04b8 8030      		cpi r24,lo8(xPendingReadyList)
 1108 04ba 9F07      		cpc r25,r31
 1109 04bc 01F0      		breq .L74
1824:FreeRTOS/Source/tasks.c **** 				{
 1111               	.LM155:
 1112 04be 892B      		or r24,r25
 1113 04c0 01F4      		brne .L74
 1114               	.LBE63:
 1115               	.LBE62:
 1116               	.LBE61:
 1117               	.LBE60:
1938:FreeRTOS/Source/tasks.c **** 				{
 1119               	.LM156:
 1120 04c2 8091 0000 		lds r24,uxSchedulerSuspended
1938:FreeRTOS/Source/tasks.c **** 				{
 1122               	.LM157:
 1123 04c6 8111      		cpse r24,__zero_reg__
 1124 04c8 00C0      		rjmp .L69
1942:FreeRTOS/Source/tasks.c **** 					{
 1126               	.LM158:
 1127 04ca E091 0000 		lds r30,pxCurrentTCB
 1128 04ce F091 0000 		lds r31,pxCurrentTCB+1
1942:FreeRTOS/Source/tasks.c **** 					{
 1130               	.LM159:
 1131 04d2 11E0      		ldi r17,lo8(1)
 1132 04d4 D701      		movw r26,r14
 1133 04d6 5696      		adiw r26,22
 1134 04d8 9C91      		ld r25,X
 1135 04da 8689      		ldd r24,Z+22
 1136 04dc 9817      		cp r25,r24
 1137 04de 00F4      		brsh .L70
 1138 04e0 10E0      		ldi r17,0
 1139               	.L70:
1951:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1141               	.LM160:
 1142 04e2 E701      		movw r28,r14
 1143 04e4 2296      		adiw r28,2
 1144 04e6 CE01      		movw r24,r28
 1145 04e8 0E94 0000 		call uxListRemove
1952:FreeRTOS/Source/tasks.c **** 				}
 1147               	.LM161:
 1148 04ec F701      		movw r30,r14
 1149 04ee 8689      		ldd r24,Z+22
 1150 04f0 9091 0000 		lds r25,uxTopReadyPriority
 1151 04f4 9817      		cp r25,r24
 1152 04f6 00F4      		brsh .L71
1952:FreeRTOS/Source/tasks.c **** 				}
 1154               	.LM162:
 1155 04f8 8093 0000 		sts uxTopReadyPriority,r24
 1156               	.L71:
1952:FreeRTOS/Source/tasks.c **** 				}
 1158               	.LM163:
 1159 04fc F9E0      		ldi r31,lo8(9)
 1160 04fe 8F9F      		mul r24,r31
 1161 0500 C001      		movw r24,r0
 1162 0502 1124      		clr __zero_reg__
 1163 0504 BE01      		movw r22,r28
 1164 0506 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1165 0508 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1166 050a 0E94 0000 		call vListInsertEnd
 1167               	.L67:
1970:FreeRTOS/Source/tasks.c **** 
 1169               	.LM164:
 1170 050e 812F      		mov r24,r17
 1171               	/* epilogue start */
 1172 0510 DF91      		pop r29
 1173 0512 CF91      		pop r28
 1174 0514 1F91      		pop r17
 1175 0516 FF90      		pop r15
 1176 0518 EF90      		pop r14
 1177 051a 0895      		ret
 1178               	.L69:
1959:FreeRTOS/Source/tasks.c **** 				}
 1180               	.LM165:
 1181 051c B701      		movw r22,r14
 1182 051e 645F      		subi r22,-12
 1183 0520 7F4F      		sbci r23,-1
 1184 0522 80E0      		ldi r24,lo8(xPendingReadyList)
 1185 0524 90E0      		ldi r25,hi8(xPendingReadyList)
 1186 0526 0E94 0000 		call vListInsertEnd
 1187               	.L74:
1907:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1189               	.LM166:
 1190 052a 10E0      		ldi r17,0
1969:FreeRTOS/Source/tasks.c **** 	}
 1192               	.LM167:
 1193 052c 00C0      		rjmp .L67
 1198               	.Lscope7:
 1200               		.section	.rodata.str1.1,"aMS",@progbits,1
 1201               	.LC0:
 1202 0000 4944 4C45 		.string	"IDLE"
 1202      00
 1203               		.text
 1206               	.global	vTaskStartScheduler
 1208               	vTaskStartScheduler:
1976:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 1210               	.LM168:
 1211               	.LFBB8:
 1212 052e EF92      		push r14
 1213 0530 FF92      		push r15
 1214 0532 0F93      		push r16
 1215               	/* prologue: function */
 1216               	/* frame size = 0 */
 1217               	/* stack size = 3 */
 1218               	.L__stack_usage = 3
2009:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
 1220               	.LM169:
 1221 0534 80E0      		ldi r24,lo8(xIdleTaskHandle)
 1222 0536 E82E      		mov r14,r24
 1223 0538 80E0      		ldi r24,hi8(xIdleTaskHandle)
 1224 053a F82E      		mov r15,r24
 1225 053c 00E0      		ldi r16,0
 1226 053e 30E0      		ldi r19,0
 1227 0540 20E0      		ldi r18,0
 1228 0542 45E5      		ldi r20,lo8(85)
 1229 0544 50E0      		ldi r21,0
 1230 0546 60E0      		ldi r22,lo8(.LC0)
 1231 0548 70E0      		ldi r23,hi8(.LC0)
 1232 054a 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1233 054c 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1234 054e 0E94 0000 		call xTaskCreate
2031:FreeRTOS/Source/tasks.c **** 	{
 1236               	.LM170:
 1237 0552 8130      		cpi r24,lo8(1)
 1238 0554 01F4      		brne .L75
2047:FreeRTOS/Source/tasks.c **** 
 1240               	.LM171:
 1241               	/* #APP */
 1242               	 ;  2047 "FreeRTOS/Source/tasks.c" 1
 1243 0556 F894      		cli
 1244               	 ;  0 "" 2
2059:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1246               	.LM172:
 1247               	/* #NOAPP */
 1248 0558 2FEF      		ldi r18,lo8(-1)
 1249 055a 3FEF      		ldi r19,lo8(-1)
 1250 055c 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1251 0560 2093 0000 		sts xNextTaskUnblockTime,r18
2060:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1253               	.LM173:
 1254 0564 8093 0000 		sts xSchedulerRunning,r24
2061:FreeRTOS/Source/tasks.c **** 
 1256               	.LM174:
 1257 0568 1092 0000 		sts xTickCount+1,__zero_reg__
 1258 056c 1092 0000 		sts xTickCount,__zero_reg__
 1259               	/* epilogue start */
2096:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1261               	.LM175:
 1262 0570 0F91      		pop r16
 1263 0572 FF90      		pop r15
 1264 0574 EF90      		pop r14
2075:FreeRTOS/Source/tasks.c **** 		{
 1266               	.LM176:
 1267 0576 0C94 0000 		jmp xPortStartScheduler
 1268               	.L75:
 1269               	/* epilogue start */
2096:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1271               	.LM177:
 1272 057a 0F91      		pop r16
 1273 057c FF90      		pop r15
 1274 057e EF90      		pop r14
 1275 0580 0895      		ret
 1280               	.Lscope8:
 1283               	.global	vTaskEndScheduler
 1285               	vTaskEndScheduler:
2100:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1287               	.LM178:
 1288               	.LFBB9:
 1289               	/* prologue: function */
 1290               	/* frame size = 0 */
 1291               	/* stack size = 0 */
 1292               	.L__stack_usage = 0
2104:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1294               	.LM179:
 1295               	/* #APP */
 1296               	 ;  2104 "FreeRTOS/Source/tasks.c" 1
 1297 0582 F894      		cli
 1298               	 ;  0 "" 2
2105:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1300               	.LM180:
 1301               	/* #NOAPP */
 1302 0584 1092 0000 		sts xSchedulerRunning,__zero_reg__
2106:FreeRTOS/Source/tasks.c **** }
 1304               	.LM181:
 1305 0588 0C94 0000 		jmp vPortEndScheduler
 1307               	.Lscope9:
 1310               	.global	vTaskSuspendAll
 1312               	vTaskSuspendAll:
2111:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1314               	.LM182:
 1315               	.LFBB10:
 1316               	/* prologue: function */
 1317               	/* frame size = 0 */
 1318               	/* stack size = 0 */
 1319               	.L__stack_usage = 0
2123:FreeRTOS/Source/tasks.c **** 
 1321               	.LM183:
 1322 058c 8091 0000 		lds r24,uxSchedulerSuspended
 1323 0590 8F5F      		subi r24,lo8(-(1))
 1324 0592 8093 0000 		sts uxSchedulerSuspended,r24
 1325               	/* epilogue start */
2128:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
 1327               	.LM184:
 1328 0596 0895      		ret
 1330               	.Lscope10:
 1333               	.global	xTaskGetTickCount
 1335               	xTaskGetTickCount:
2305:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
 1337               	.LM185:
 1338               	.LFBB11:
 1339               	/* prologue: function */
 1340               	/* frame size = 0 */
 1341               	/* stack size = 0 */
 1342               	.L__stack_usage = 0
2309:FreeRTOS/Source/tasks.c **** 	{
 1344               	.LM186:
 1345               	/* #APP */
 1346               	 ;  2309 "FreeRTOS/Source/tasks.c" 1
 1347 0598 0FB6      		in		__tmp_reg__, __SREG__
 1348               	 ;  0 "" 2
 1349               	 ;  2309 "FreeRTOS/Source/tasks.c" 1
 1350 059a F894      		cli
 1351               	 ;  0 "" 2
 1352               	 ;  2309 "FreeRTOS/Source/tasks.c" 1
 1353 059c 0F92      		push	__tmp_reg__
 1354               	 ;  0 "" 2
2311:FreeRTOS/Source/tasks.c **** 	}
 1356               	.LM187:
 1357               	/* #NOAPP */
 1358 059e 8091 0000 		lds r24,xTickCount
 1359 05a2 9091 0000 		lds r25,xTickCount+1
2313:FreeRTOS/Source/tasks.c **** 
 1361               	.LM188:
 1362               	/* #APP */
 1363               	 ;  2313 "FreeRTOS/Source/tasks.c" 1
 1364 05a6 0F90      		pop		__tmp_reg__
 1365               	 ;  0 "" 2
 1366               	 ;  2313 "FreeRTOS/Source/tasks.c" 1
 1367 05a8 0FBE      		out		__SREG__, __tmp_reg__
 1368               	 ;  0 "" 2
 1369               	/* #NOAPP */
 1370               	/* epilogue start */
2316:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1372               	.LM189:
 1373 05aa 0895      		ret
 1378               	.Lscope11:
 1381               	.global	xTaskGetTickCountFromISR
 1383               	xTaskGetTickCountFromISR:
2320:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
 1385               	.LM190:
 1386               	.LFBB12:
 1387               	/* prologue: function */
 1388               	/* frame size = 0 */
 1389               	/* stack size = 0 */
 1390               	.L__stack_usage = 0
2342:FreeRTOS/Source/tasks.c **** 	}
 1392               	.LM191:
 1393 05ac 8091 0000 		lds r24,xTickCount
 1394 05b0 9091 0000 		lds r25,xTickCount+1
 1395               	/* epilogue start */
2347:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1397               	.LM192:
 1398 05b4 0895      		ret
 1403               	.Lscope12:
 1406               	.global	uxTaskGetNumberOfTasks
 1408               	uxTaskGetNumberOfTasks:
2351:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1410               	.LM193:
 1411               	.LFBB13:
 1412               	/* prologue: function */
 1413               	/* frame size = 0 */
 1414               	/* stack size = 0 */
 1415               	.L__stack_usage = 0
2354:FreeRTOS/Source/tasks.c **** }
 1417               	.LM194:
 1418 05b6 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1419               	/* epilogue start */
2355:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1421               	.LM195:
 1422 05ba 0895      		ret
 1424               	.Lscope13:
 1428               	.global	pcTaskGetName
 1430               	pcTaskGetName:
2359:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 1432               	.LM196:
 1433               	.LFBB14:
 1434               	/* prologue: function */
 1435               	/* frame size = 0 */
 1436               	/* stack size = 0 */
 1437               	.L__stack_usage = 0
2364:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1439               	.LM197:
 1440 05bc 0097      		sbiw r24,0
 1441 05be 01F4      		brne .L83
2364:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1443               	.LM198:
 1444 05c0 8091 0000 		lds r24,pxCurrentTCB
 1445 05c4 9091 0000 		lds r25,pxCurrentTCB+1
 1446               	.L83:
2367:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1448               	.LM199:
 1449 05c8 4996      		adiw r24,25
 1450               	/* epilogue start */
 1451 05ca 0895      		ret
 1453               	.Lscope14:
 1456               	.global	xTaskIncrementTick
 1458               	xTaskIncrementTick:
2708:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1460               	.LM200:
 1461               	.LFBB15:
 1462 05cc CF92      		push r12
 1463 05ce DF92      		push r13
 1464 05d0 EF92      		push r14
 1465 05d2 FF92      		push r15
 1466 05d4 0F93      		push r16
 1467 05d6 1F93      		push r17
 1468 05d8 CF93      		push r28
 1469 05da DF93      		push r29
 1470               	/* prologue: function */
 1471               	/* frame size = 0 */
 1472               	/* stack size = 8 */
 1473               	.L__stack_usage = 8
2717:FreeRTOS/Source/tasks.c **** 	{
 1475               	.LM201:
 1476 05dc 8091 0000 		lds r24,uxSchedulerSuspended
2717:FreeRTOS/Source/tasks.c **** 	{
 1478               	.LM202:
 1479 05e0 8111      		cpse r24,__zero_reg__
 1480 05e2 00C0      		rjmp .L85
 1481               	.LBB68:
 1482               	.LBB69:
 1483               	.LBB70:
2721:FreeRTOS/Source/tasks.c **** 
 1485               	.LM203:
 1486 05e4 E090 0000 		lds r14,xTickCount
 1487 05e8 F090 0000 		lds r15,xTickCount+1
2721:FreeRTOS/Source/tasks.c **** 
 1489               	.LM204:
 1490 05ec 8FEF      		ldi r24,-1
 1491 05ee E81A      		sub r14,r24
 1492 05f0 F80A      		sbc r15,r24
2725:FreeRTOS/Source/tasks.c **** 
 1494               	.LM205:
 1495 05f2 F092 0000 		sts xTickCount+1,r15
 1496 05f6 E092 0000 		sts xTickCount,r14
2727:FreeRTOS/Source/tasks.c **** 		{
 1498               	.LM206:
 1499 05fa E114      		cp r14,__zero_reg__
 1500 05fc F104      		cpc r15,__zero_reg__
 1501 05fe 01F4      		brne .L86
 1502               	.LBB71:
2729:FreeRTOS/Source/tasks.c **** 		}
 1504               	.LM207:
 1505 0600 8091 0000 		lds r24,pxDelayedTaskList
 1506 0604 9091 0000 		lds r25,pxDelayedTaskList+1
 1507 0608 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1508 060c 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1509 0610 3093 0000 		sts pxDelayedTaskList+1,r19
 1510 0614 2093 0000 		sts pxDelayedTaskList,r18
 1511 0618 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1512 061c 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1513 0620 8091 0000 		lds r24,xNumOfOverflows
 1514 0624 8F5F      		subi r24,lo8(-(1))
 1515 0626 8093 0000 		sts xNumOfOverflows,r24
 1516 062a 0E94 0000 		call prvResetNextTaskUnblockTime
 1517               	.L86:
 1518               	.LBE71:
2740:FreeRTOS/Source/tasks.c **** 		{
 1520               	.LM208:
 1521 062e 8091 0000 		lds r24,xNextTaskUnblockTime
 1522 0632 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1523               	.LBE70:
2711:FreeRTOS/Source/tasks.c **** 
 1525               	.LM209:
 1526 0636 10E0      		ldi r17,0
 1527               	.LBB72:
2740:FreeRTOS/Source/tasks.c **** 		{
 1529               	.LM210:
 1530 0638 E816      		cp r14,r24
 1531 063a F906      		cpc r15,r25
 1532 063c 00F4      		brsh .L96
 1533               	.L88:
2823:FreeRTOS/Source/tasks.c **** 			{
 1535               	.LM211:
 1536 063e E091 0000 		lds r30,pxCurrentTCB
 1537 0642 F091 0000 		lds r31,pxCurrentTCB+1
 1538 0646 E689      		ldd r30,Z+22
 1539 0648 B9E0      		ldi r27,lo8(9)
 1540 064a EB9F      		mul r30,r27
 1541 064c F001      		movw r30,r0
 1542 064e 1124      		clr __zero_reg__
 1543 0650 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1544 0652 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1545 0654 8081      		ld r24,Z
2823:FreeRTOS/Source/tasks.c **** 			{
 1547               	.LM212:
 1548 0656 8230      		cpi r24,lo8(2)
 1549 0658 00F0      		brlo .L94
2825:FreeRTOS/Source/tasks.c **** 			}
 1551               	.LM213:
 1552 065a 11E0      		ldi r17,lo8(1)
 1553               	.L94:
2851:FreeRTOS/Source/tasks.c **** 			{
 1555               	.LM214:
 1556 065c 8091 0000 		lds r24,xYieldPending
2851:FreeRTOS/Source/tasks.c **** 			{
 1558               	.LM215:
 1559 0660 8111      		cpse r24,__zero_reg__
2853:FreeRTOS/Source/tasks.c **** 			}
 1561               	.LM216:
 1562 0662 11E0      		ldi r17,lo8(1)
 1563               	.L84:
 1564               	.LBE72:
 1565               	.LBE69:
 1566               	.LBE68:
2876:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1568               	.LM217:
 1569 0664 812F      		mov r24,r17
 1570               	/* epilogue start */
 1571 0666 DF91      		pop r29
 1572 0668 CF91      		pop r28
 1573 066a 1F91      		pop r17
 1574 066c 0F91      		pop r16
 1575 066e FF90      		pop r15
 1576 0670 EF90      		pop r14
 1577 0672 DF90      		pop r13
 1578 0674 CF90      		pop r12
 1579 0676 0895      		ret
 1580               	.L96:
 1581               	.LBB75:
 1582               	.LBB74:
 1583               	.LBB73:
2794:FreeRTOS/Source/tasks.c **** 
 1585               	.LM218:
 1586 0678 09E0      		ldi r16,lo8(9)
 1587               	.L87:
2744:FreeRTOS/Source/tasks.c **** 				{
 1589               	.LM219:
 1590 067a E091 0000 		lds r30,pxDelayedTaskList
 1591 067e F091 0000 		lds r31,pxDelayedTaskList+1
 1592 0682 8081      		ld r24,Z
2744:FreeRTOS/Source/tasks.c **** 				{
 1594               	.LM220:
 1595 0684 8111      		cpse r24,__zero_reg__
 1596 0686 00C0      		rjmp .L89
2751:FreeRTOS/Source/tasks.c **** 					break;
 1598               	.LM221:
 1599 0688 8FEF      		ldi r24,lo8(-1)
 1600 068a 9FEF      		ldi r25,lo8(-1)
 1601               	.L103:
2770:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 1603               	.LM222:
 1604 068c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1605 0690 8093 0000 		sts xNextTaskUnblockTime,r24
2771:FreeRTOS/Source/tasks.c **** 					}
 1607               	.LM223:
 1608 0694 00C0      		rjmp .L88
 1609               	.L89:
2760:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1611               	.LM224:
 1612 0696 E091 0000 		lds r30,pxDelayedTaskList
 1613 069a F091 0000 		lds r31,pxDelayedTaskList+1
2760:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1615               	.LM225:
 1616 069e 0580      		ldd __tmp_reg__,Z+5
 1617 06a0 F681      		ldd r31,Z+6
 1618 06a2 E02D      		mov r30,__tmp_reg__
 1619 06a4 C680      		ldd r12,Z+6
 1620 06a6 D780      		ldd r13,Z+7
2761:FreeRTOS/Source/tasks.c **** 
 1622               	.LM226:
 1623 06a8 D601      		movw r26,r12
 1624 06aa 1296      		adiw r26,2
 1625 06ac 8D91      		ld r24,X+
 1626 06ae 9C91      		ld r25,X
2763:FreeRTOS/Source/tasks.c **** 					{
 1628               	.LM227:
 1629 06b0 E816      		cp r14,r24
 1630 06b2 F906      		cpc r15,r25
 1631 06b4 00F0      		brlo .L103
2779:FreeRTOS/Source/tasks.c **** 
 1633               	.LM228:
 1634 06b6 E601      		movw r28,r12
 1635 06b8 2296      		adiw r28,2
 1636 06ba CE01      		movw r24,r28
 1637 06bc 0E94 0000 		call uxListRemove
2783:FreeRTOS/Source/tasks.c **** 					{
 1639               	.LM229:
 1640 06c0 F601      		movw r30,r12
 1641 06c2 8489      		ldd r24,Z+20
 1642 06c4 9589      		ldd r25,Z+21
 1643 06c6 892B      		or r24,r25
 1644 06c8 01F0      		breq .L91
2785:FreeRTOS/Source/tasks.c **** 					}
 1646               	.LM230:
 1647 06ca C601      		movw r24,r12
 1648 06cc 0C96      		adiw r24,12
 1649 06ce 0E94 0000 		call uxListRemove
 1650               	.L91:
2794:FreeRTOS/Source/tasks.c **** 
 1652               	.LM231:
 1653 06d2 D601      		movw r26,r12
 1654 06d4 5696      		adiw r26,22
 1655 06d6 8C91      		ld r24,X
 1656 06d8 9091 0000 		lds r25,uxTopReadyPriority
 1657 06dc 9817      		cp r25,r24
 1658 06de 00F4      		brsh .L92
 1659 06e0 8093 0000 		sts uxTopReadyPriority,r24
 1660               	.L92:
 1661 06e4 809F      		mul r24,r16
 1662 06e6 C001      		movw r24,r0
 1663 06e8 1124      		clr __zero_reg__
 1664 06ea BE01      		movw r22,r28
 1665 06ec 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1666 06ee 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1667 06f0 0E94 0000 		call vListInsertEnd
2804:FreeRTOS/Source/tasks.c **** 						{
 1669               	.LM232:
 1670 06f4 E091 0000 		lds r30,pxCurrentTCB
 1671 06f8 F091 0000 		lds r31,pxCurrentTCB+1
2804:FreeRTOS/Source/tasks.c **** 						{
 1673               	.LM233:
 1674 06fc D601      		movw r26,r12
 1675 06fe 5696      		adiw r26,22
 1676 0700 9C91      		ld r25,X
 1677 0702 8689      		ldd r24,Z+22
 1678 0704 9817      		cp r25,r24
 1679 0706 00F4      		brsh .+2
 1680 0708 00C0      		rjmp .L87
2806:FreeRTOS/Source/tasks.c **** 						}
 1682               	.LM234:
 1683 070a 11E0      		ldi r17,lo8(1)
 1684 070c 00C0      		rjmp .L87
 1685               	.L85:
 1686               	.LBE73:
 1687               	.LBE74:
 1688               	.LBE75:
2864:FreeRTOS/Source/tasks.c **** 
 1690               	.LM235:
 1691 070e 8091 0000 		lds r24,xPendedTicks
 1692 0712 9091 0000 		lds r25,xPendedTicks+1
 1693 0716 0196      		adiw r24,1
 1694 0718 9093 0000 		sts xPendedTicks+1,r25
 1695 071c 8093 0000 		sts xPendedTicks,r24
2711:FreeRTOS/Source/tasks.c **** 
 1697               	.LM236:
 1698 0720 10E0      		ldi r17,0
2875:FreeRTOS/Source/tasks.c **** }
 1700               	.LM237:
 1701 0722 00C0      		rjmp .L84
 1727               	.Lscope15:
 1730               	.global	xTaskResumeAll
 1732               	xTaskResumeAll:
2195:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
 1734               	.LM238:
 1735               	.LFBB16:
 1736 0724 EF92      		push r14
 1737 0726 FF92      		push r15
 1738 0728 0F93      		push r16
 1739 072a 1F93      		push r17
 1740 072c CF93      		push r28
 1741 072e DF93      		push r29
 1742               	/* prologue: function */
 1743               	/* frame size = 0 */
 1744               	/* stack size = 6 */
 1745               	.L__stack_usage = 6
2208:FreeRTOS/Source/tasks.c **** 	{
 1747               	.LM239:
 1748               	/* #APP */
 1749               	 ;  2208 "FreeRTOS/Source/tasks.c" 1
 1750 0730 0FB6      		in		__tmp_reg__, __SREG__
 1751               	 ;  0 "" 2
 1752               	 ;  2208 "FreeRTOS/Source/tasks.c" 1
 1753 0732 F894      		cli
 1754               	 ;  0 "" 2
 1755               	 ;  2208 "FreeRTOS/Source/tasks.c" 1
 1756 0734 0F92      		push	__tmp_reg__
 1757               	 ;  0 "" 2
2210:FreeRTOS/Source/tasks.c **** 
 1759               	.LM240:
 1760               	/* #NOAPP */
 1761 0736 8091 0000 		lds r24,uxSchedulerSuspended
 1762 073a 8150      		subi r24,lo8(-(-1))
 1763 073c 8093 0000 		sts uxSchedulerSuspended,r24
2212:FreeRTOS/Source/tasks.c **** 		{
 1765               	.LM241:
 1766 0740 8091 0000 		lds r24,uxSchedulerSuspended
2212:FreeRTOS/Source/tasks.c **** 		{
 1768               	.LM242:
 1769 0744 8823      		tst r24
 1770 0746 01F0      		breq .L105
 1771               	.L108:
2197:FreeRTOS/Source/tasks.c **** 
 1773               	.LM243:
 1774 0748 80E0      		ldi r24,0
 1775               	.L106:
2298:FreeRTOS/Source/tasks.c **** 
 1777               	.LM244:
 1778               	/* #APP */
 1779               	 ;  2298 "FreeRTOS/Source/tasks.c" 1
 1780 074a 0F90      		pop		__tmp_reg__
 1781               	 ;  0 "" 2
 1782               	 ;  2298 "FreeRTOS/Source/tasks.c" 1
 1783 074c 0FBE      		out		__SREG__, __tmp_reg__
 1784               	 ;  0 "" 2
 1785               	/* #NOAPP */
 1786               	/* epilogue start */
2301:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1788               	.LM245:
 1789 074e DF91      		pop r29
 1790 0750 CF91      		pop r28
 1791 0752 1F91      		pop r17
 1792 0754 0F91      		pop r16
 1793 0756 FF90      		pop r15
 1794 0758 EF90      		pop r14
 1795 075a 0895      		ret
 1796               	.L105:
2214:FreeRTOS/Source/tasks.c **** 			{
 1798               	.LM246:
 1799 075c 8091 0000 		lds r24,uxCurrentNumberOfTasks
2214:FreeRTOS/Source/tasks.c **** 			{
 1801               	.LM247:
 1802 0760 8823      		tst r24
 1803 0762 01F0      		breq .L108
2196:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1805               	.LM248:
 1806 0764 10E0      		ldi r17,0
 1807 0766 00E0      		ldi r16,0
2223:FreeRTOS/Source/tasks.c **** 
 1809               	.LM249:
 1810 0768 89E0      		ldi r24,lo8(9)
 1811 076a F82E      		mov r15,r24
2229:FreeRTOS/Source/tasks.c **** 					}
 1813               	.LM250:
 1814 076c EE24      		clr r14
 1815 076e E394      		inc r14
 1816 0770 00C0      		rjmp .L107
 1817               	.L111:
2220:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1819               	.LM251:
 1820 0772 E091 0000 		lds r30,xPendingReadyList+5
 1821 0776 F091 0000 		lds r31,xPendingReadyList+5+1
 1822 077a 0681      		ldd r16,Z+6
 1823 077c 1781      		ldd r17,Z+7
2221:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1825               	.LM252:
 1826 077e C801      		movw r24,r16
 1827 0780 0C96      		adiw r24,12
 1828 0782 0E94 0000 		call uxListRemove
2222:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1830               	.LM253:
 1831 0786 E801      		movw r28,r16
 1832 0788 2296      		adiw r28,2
 1833 078a CE01      		movw r24,r28
 1834 078c 0E94 0000 		call uxListRemove
2223:FreeRTOS/Source/tasks.c **** 
 1836               	.LM254:
 1837 0790 D801      		movw r26,r16
 1838 0792 5696      		adiw r26,22
 1839 0794 8C91      		ld r24,X
 1840 0796 9091 0000 		lds r25,uxTopReadyPriority
 1841 079a 9817      		cp r25,r24
 1842 079c 00F4      		brsh .L109
2223:FreeRTOS/Source/tasks.c **** 
 1844               	.LM255:
 1845 079e 8093 0000 		sts uxTopReadyPriority,r24
 1846               	.L109:
2223:FreeRTOS/Source/tasks.c **** 
 1848               	.LM256:
 1849 07a2 8F9D      		mul r24,r15
 1850 07a4 C001      		movw r24,r0
 1851 07a6 1124      		clr __zero_reg__
 1852 07a8 BE01      		movw r22,r28
 1853 07aa 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1854 07ac 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1855 07ae 0E94 0000 		call vListInsertEnd
2227:FreeRTOS/Source/tasks.c **** 					{
 1857               	.LM257:
 1858 07b2 E091 0000 		lds r30,pxCurrentTCB
 1859 07b6 F091 0000 		lds r31,pxCurrentTCB+1
2227:FreeRTOS/Source/tasks.c **** 					{
 1861               	.LM258:
 1862 07ba D801      		movw r26,r16
 1863 07bc 5696      		adiw r26,22
 1864 07be 9C91      		ld r25,X
 1865 07c0 8689      		ldd r24,Z+22
 1866 07c2 9817      		cp r25,r24
 1867 07c4 00F0      		brlo .L107
2229:FreeRTOS/Source/tasks.c **** 					}
 1869               	.LM259:
 1870 07c6 E092 0000 		sts xYieldPending,r14
 1871               	.L107:
2218:FreeRTOS/Source/tasks.c **** 				{
 1873               	.LM260:
 1874 07ca 8091 0000 		lds r24,xPendingReadyList
2218:FreeRTOS/Source/tasks.c **** 				{
 1876               	.LM261:
 1877 07ce 8111      		cpse r24,__zero_reg__
 1878 07d0 00C0      		rjmp .L111
2237:FreeRTOS/Source/tasks.c **** 				{
 1880               	.LM262:
 1881 07d2 012B      		or r16,r17
 1882 07d4 01F0      		breq .L112
2245:FreeRTOS/Source/tasks.c **** 				}
 1884               	.LM263:
 1885 07d6 0E94 0000 		call prvResetNextTaskUnblockTime
 1886               	.L112:
 1887               	.LBB76:
2253:FreeRTOS/Source/tasks.c **** 
 1889               	.LM264:
 1890 07da C091 0000 		lds r28,xPendedTicks
 1891 07de D091 0000 		lds r29,xPendedTicks+1
2255:FreeRTOS/Source/tasks.c **** 					{
 1893               	.LM265:
 1894 07e2 2097      		sbiw r28,0
 1895 07e4 01F0      		breq .L113
2261:FreeRTOS/Source/tasks.c **** 							}
 1897               	.LM266:
 1898 07e6 11E0      		ldi r17,lo8(1)
 1899               	.L115:
2259:FreeRTOS/Source/tasks.c **** 							{
 1901               	.LM267:
 1902 07e8 0E94 0000 		call xTaskIncrementTick
2259:FreeRTOS/Source/tasks.c **** 							{
 1904               	.LM268:
 1905 07ec 8111      		cpse r24,__zero_reg__
2261:FreeRTOS/Source/tasks.c **** 							}
 1907               	.LM269:
 1908 07ee 1093 0000 		sts xYieldPending,r17
 1909               	.L114:
2267:FreeRTOS/Source/tasks.c **** 						} while( xPendedCounts > ( TickType_t ) 0U );
 1911               	.LM270:
 1912 07f2 2197      		sbiw r28,1
2268:FreeRTOS/Source/tasks.c **** 
 1914               	.LM271:
 1915 07f4 01F4      		brne .L115
2270:FreeRTOS/Source/tasks.c **** 					}
 1917               	.LM272:
 1918 07f6 1092 0000 		sts xPendedTicks+1,__zero_reg__
 1919 07fa 1092 0000 		sts xPendedTicks,__zero_reg__
 1920               	.L113:
 1921               	.LBE76:
2278:FreeRTOS/Source/tasks.c **** 				{
 1923               	.LM273:
 1924 07fe 8091 0000 		lds r24,xYieldPending
2278:FreeRTOS/Source/tasks.c **** 				{
 1926               	.LM274:
 1927 0802 8823      		tst r24
 1928 0804 01F4      		brne .+2
 1929 0806 00C0      		rjmp .L108
2285:FreeRTOS/Source/tasks.c **** 				}
 1931               	.LM275:
 1932 0808 0E94 0000 		call vPortYield
2282:FreeRTOS/Source/tasks.c **** 					}
 1934               	.LM276:
 1935 080c 81E0      		ldi r24,lo8(1)
 1936 080e 00C0      		rjmp .L106
 1945               	.Lscope16:
 1950               	.global	vTaskDelayUntil
 1952               	vTaskDelayUntil:
1258:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 1954               	.LM277:
 1955               	.LFBB17:
 1956 0810 0F93      		push r16
 1957 0812 1F93      		push r17
 1958 0814 CF93      		push r28
 1959 0816 DF93      		push r29
 1960               	/* prologue: function */
 1961               	/* frame size = 0 */
 1962               	/* stack size = 4 */
 1963               	.L__stack_usage = 4
 1964 0818 EC01      		movw r28,r24
 1965 081a 8B01      		movw r16,r22
1266:FreeRTOS/Source/tasks.c **** 		{
 1967               	.LM278:
 1968 081c 0E94 0000 		call vTaskSuspendAll
 1969               	.LBB77:
1270:FreeRTOS/Source/tasks.c **** 
 1971               	.LM279:
 1972 0820 2091 0000 		lds r18,xTickCount
 1973 0824 3091 0000 		lds r19,xTickCount+1
1273:FreeRTOS/Source/tasks.c **** 
 1975               	.LM280:
 1976 0828 4881      		ld r20,Y
 1977 082a 5981      		ldd r21,Y+1
1273:FreeRTOS/Source/tasks.c **** 
 1979               	.LM281:
 1980 082c CA01      		movw r24,r20
 1981 082e 800F      		add r24,r16
 1982 0830 911F      		adc r25,r17
1307:FreeRTOS/Source/tasks.c **** 
 1984               	.LM282:
 1985 0832 9983      		std Y+1,r25
 1986 0834 8883      		st Y,r24
1275:FreeRTOS/Source/tasks.c **** 			{
 1988               	.LM283:
 1989 0836 2417      		cp r18,r20
 1990 0838 3507      		cpc r19,r21
 1991 083a 00F4      		brsh .L131
1282:FreeRTOS/Source/tasks.c **** 				{
 1993               	.LM284:
 1994 083c 8417      		cp r24,r20
 1995 083e 9507      		cpc r25,r21
 1996 0840 00F0      		brlo .L139
 1997               	.L133:
 1998               	.LBE77:
1322:FreeRTOS/Source/tasks.c **** 
 2000               	.LM285:
 2001 0842 0E94 0000 		call xTaskResumeAll
1326:FreeRTOS/Source/tasks.c **** 		{
 2003               	.LM286:
 2004 0846 8111      		cpse r24,__zero_reg__
 2005 0848 00C0      		rjmp .L130
1328:FreeRTOS/Source/tasks.c **** 		}
 2007               	.LM287:
 2008 084a 0E94 0000 		call vPortYield
 2009               	.L130:
 2010               	/* epilogue start */
1334:FreeRTOS/Source/tasks.c **** 
 2012               	.LM288:
 2013 084e DF91      		pop r29
 2014 0850 CF91      		pop r28
 2015 0852 1F91      		pop r17
 2016 0854 0F91      		pop r16
 2017 0856 0895      		ret
 2018               	.L131:
 2019               	.LBB78:
1296:FreeRTOS/Source/tasks.c **** 				{
 2021               	.LM289:
 2022 0858 8417      		cp r24,r20
 2023 085a 9507      		cpc r25,r21
 2024 085c 00F0      		brlo .L135
 2025               	.L139:
1296:FreeRTOS/Source/tasks.c **** 				{
 2027               	.LM290:
 2028 085e 2817      		cp r18,r24
 2029 0860 3907      		cpc r19,r25
 2030 0862 00F4      		brsh .L133
 2031               	.L135:
1315:FreeRTOS/Source/tasks.c **** 			}
 2033               	.LM291:
 2034 0864 60E0      		ldi r22,0
 2035 0866 821B      		sub r24,r18
 2036 0868 930B      		sbc r25,r19
 2037 086a 0E94 0000 		call prvAddCurrentTaskToDelayedList
 2038 086e 00C0      		rjmp .L133
 2039               	.LBE78:
 2050               	.Lscope17:
 2054               	.global	vTaskDelay
 2056               	vTaskDelay:
1342:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 2058               	.LM292:
 2059               	.LFBB18:
 2060 0870 CF93      		push r28
 2061 0872 DF93      		push r29
 2062               	/* prologue: function */
 2063               	/* frame size = 0 */
 2064               	/* stack size = 2 */
 2065               	.L__stack_usage = 2
 2066 0874 EC01      		movw r28,r24
1346:FreeRTOS/Source/tasks.c **** 		{
 2068               	.LM293:
 2069 0876 892B      		or r24,r25
 2070 0878 01F4      		brne .L141
 2071               	.L143:
1373:FreeRTOS/Source/tasks.c **** 		}
 2073               	.LM294:
 2074 087a 0E94 0000 		call vPortYield
 2075               	.L140:
 2076               	/* epilogue start */
1379:FreeRTOS/Source/tasks.c **** 
 2078               	.LM295:
 2079 087e DF91      		pop r29
 2080 0880 CF91      		pop r28
 2081 0882 0895      		ret
 2082               	.L141:
1349:FreeRTOS/Source/tasks.c **** 			{
 2084               	.LM296:
 2085 0884 0E94 0000 		call vTaskSuspendAll
1360:FreeRTOS/Source/tasks.c **** 			}
 2087               	.LM297:
 2088 0888 60E0      		ldi r22,0
 2089 088a CE01      		movw r24,r28
 2090 088c 0E94 0000 		call prvAddCurrentTaskToDelayedList
1362:FreeRTOS/Source/tasks.c **** 		}
 2092               	.LM298:
 2093 0890 0E94 0000 		call xTaskResumeAll
1371:FreeRTOS/Source/tasks.c **** 		{
 2095               	.LM299:
 2096 0894 8823      		tst r24
 2097 0896 01F0      		breq .L143
 2098 0898 00C0      		rjmp .L140
 2100               	.Lscope18:
 2104               	.global	xTaskCatchUpTicks
 2106               	xTaskCatchUpTicks:
2610:FreeRTOS/Source/tasks.c **** BaseType_t xYieldRequired = pdFALSE;
 2108               	.LM300:
 2109               	.LFBB19:
 2110 089a CF93      		push r28
 2111 089c DF93      		push r29
 2112               	/* prologue: function */
 2113               	/* frame size = 0 */
 2114               	/* stack size = 2 */
 2115               	.L__stack_usage = 2
 2116 089e EC01      		movw r28,r24
2619:FreeRTOS/Source/tasks.c **** 	xPendedTicks += xTicksToCatchUp;
 2118               	.LM301:
 2119 08a0 0E94 0000 		call vTaskSuspendAll
2620:FreeRTOS/Source/tasks.c **** 	xYieldRequired = xTaskResumeAll();
 2121               	.LM302:
 2122 08a4 8091 0000 		lds r24,xPendedTicks
 2123 08a8 9091 0000 		lds r25,xPendedTicks+1
 2124 08ac 8C0F      		add r24,r28
 2125 08ae 9D1F      		adc r25,r29
 2126 08b0 9093 0000 		sts xPendedTicks+1,r25
 2127 08b4 8093 0000 		sts xPendedTicks,r24
 2128               	/* epilogue start */
2624:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
 2130               	.LM303:
 2131 08b8 DF91      		pop r29
 2132 08ba CF91      		pop r28
2621:FreeRTOS/Source/tasks.c **** 
 2134               	.LM304:
 2135 08bc 0C94 0000 		jmp xTaskResumeAll
 2137               	.Lscope19:
 2140               	.global	vTaskSwitchContext
 2142               	vTaskSwitchContext:
2990:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2144               	.LM305:
 2145               	.LFBB20:
 2146               	/* prologue: function */
 2147               	/* frame size = 0 */
 2148               	/* stack size = 0 */
 2149               	.L__stack_usage = 0
2991:FreeRTOS/Source/tasks.c **** 	{
 2151               	.LM306:
 2152 08c0 8091 0000 		lds r24,uxSchedulerSuspended
2991:FreeRTOS/Source/tasks.c **** 	{
 2154               	.LM307:
 2155 08c4 8823      		tst r24
 2156 08c6 01F0      		breq .L149
2995:FreeRTOS/Source/tasks.c **** 	}
 2158               	.LM308:
 2159 08c8 81E0      		ldi r24,lo8(1)
 2160 08ca 8093 0000 		sts xYieldPending,r24
 2161 08ce 0895      		ret
 2162               	.L149:
 2163               	.LBB83:
 2164               	.LBB84:
2999:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2166               	.LM309:
 2167 08d0 1092 0000 		sts xYieldPending,__zero_reg__
 2168               	.LBB85:
3041:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2170               	.LM310:
 2171 08d4 8091 0000 		lds r24,uxTopReadyPriority
 2172 08d8 29E0      		ldi r18,lo8(9)
 2173               	.L151:
 2174 08da 482F      		mov r20,r24
 2175 08dc 50E0      		ldi r21,0
 2176 08de 289F      		mul r18,r24
 2177 08e0 F001      		movw r30,r0
 2178 08e2 1124      		clr __zero_reg__
 2179 08e4 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2180 08e6 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2181 08e8 9081      		ld r25,Z
 2182 08ea 9923      		tst r25
 2183 08ec 01F0      		breq .L152
 2184               	.LBB86:
 2185 08ee A181      		ldd r26,Z+1
 2186 08f0 B281      		ldd r27,Z+2
 2187 08f2 1296      		adiw r26,2
 2188 08f4 0D90      		ld __tmp_reg__,X+
 2189 08f6 BC91      		ld r27,X
 2190 08f8 A02D      		mov r26,__tmp_reg__
 2191 08fa B283      		std Z+2,r27
 2192 08fc A183      		std Z+1,r26
 2193 08fe 829F      		mul r24,r18
 2194 0900 9001      		movw r18,r0
 2195 0902 1124      		clr __zero_reg__
 2196 0904 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 2197 0906 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 2198 0908 A217      		cp r26,r18
 2199 090a B307      		cpc r27,r19
 2200 090c 01F4      		brne .L153
 2201 090e 1296      		adiw r26,2
 2202 0910 2D91      		ld r18,X+
 2203 0912 3C91      		ld r19,X
 2204 0914 3283      		std Z+2,r19
 2205 0916 2183      		std Z+1,r18
 2206               	.L153:
 2207 0918 99E0      		ldi r25,lo8(9)
 2208 091a 949F      		mul r25,r20
 2209 091c F001      		movw r30,r0
 2210 091e 959F      		mul r25,r21
 2211 0920 F00D      		add r31,r0
 2212 0922 1124      		clr __zero_reg__
 2213 0924 E050      		subi r30,lo8(-(pxReadyTasksLists))
 2214 0926 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2215 0928 0180      		ldd __tmp_reg__,Z+1
 2216 092a F281      		ldd r31,Z+2
 2217 092c E02D      		mov r30,__tmp_reg__
 2218 092e 2681      		ldd r18,Z+6
 2219 0930 3781      		ldd r19,Z+7
 2220 0932 3093 0000 		sts pxCurrentTCB+1,r19
 2221 0936 2093 0000 		sts pxCurrentTCB,r18
 2222               	.LBE86:
 2223 093a 8093 0000 		sts uxTopReadyPriority,r24
 2224               	/* epilogue start */
 2225               	.LBE85:
 2226               	.LBE84:
 2227               	.LBE83:
3061:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2229               	.LM311:
 2230 093e 0895      		ret
 2231               	.L152:
 2232               	.LBB89:
 2233               	.LBB88:
 2234               	.LBB87:
3041:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2236               	.LM312:
 2237 0940 8150      		subi r24,lo8(-(-1))
 2238 0942 00C0      		rjmp .L151
 2239               	.LBE87:
 2240               	.LBE88:
 2241               	.LBE89:
 2249               	.Lscope20:
 2253               	.global	vTaskSuspend
 2255               	vTaskSuspend:
1705:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 2257               	.LM313:
 2258               	.LFBB21:
 2259 0944 0F93      		push r16
 2260 0946 1F93      		push r17
 2261 0948 CF93      		push r28
 2262 094a DF93      		push r29
 2263               	/* prologue: function */
 2264               	/* frame size = 0 */
 2265               	/* stack size = 4 */
 2266               	.L__stack_usage = 4
 2267 094c 8C01      		movw r16,r24
1708:FreeRTOS/Source/tasks.c **** 		{
 2269               	.LM314:
 2270               	/* #APP */
 2271               	 ;  1708 "FreeRTOS/Source/tasks.c" 1
 2272 094e 0FB6      		in		__tmp_reg__, __SREG__
 2273               	 ;  0 "" 2
 2274               	 ;  1708 "FreeRTOS/Source/tasks.c" 1
 2275 0950 F894      		cli
 2276               	 ;  0 "" 2
 2277               	 ;  1708 "FreeRTOS/Source/tasks.c" 1
 2278 0952 0F92      		push	__tmp_reg__
 2279               	 ;  0 "" 2
1712:FreeRTOS/Source/tasks.c **** 
 2281               	.LM315:
 2282               	/* #NOAPP */
 2283 0954 892B      		or r24,r25
 2284 0956 01F4      		brne .L155
1712:FreeRTOS/Source/tasks.c **** 
 2286               	.LM316:
 2287 0958 0091 0000 		lds r16,pxCurrentTCB
 2288 095c 1091 0000 		lds r17,pxCurrentTCB+1
 2289               	.L155:
1718:FreeRTOS/Source/tasks.c **** 			{
 2291               	.LM317:
 2292 0960 E801      		movw r28,r16
 2293 0962 2296      		adiw r28,2
 2294 0964 CE01      		movw r24,r28
 2295 0966 0E94 0000 		call uxListRemove
1728:FreeRTOS/Source/tasks.c **** 			{
 2297               	.LM318:
 2298 096a F801      		movw r30,r16
 2299 096c 8489      		ldd r24,Z+20
 2300 096e 9589      		ldd r25,Z+21
 2301 0970 892B      		or r24,r25
 2302 0972 01F0      		breq .L156
1730:FreeRTOS/Source/tasks.c **** 			}
 2304               	.LM319:
 2305 0974 C801      		movw r24,r16
 2306 0976 0C96      		adiw r24,12
 2307 0978 0E94 0000 		call uxListRemove
 2308               	.L156:
1737:FreeRTOS/Source/tasks.c **** 
 2310               	.LM320:
 2311 097c BE01      		movw r22,r28
 2312 097e 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2313 0980 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2314 0982 0E94 0000 		call vListInsertEnd
1741:FreeRTOS/Source/tasks.c **** 				{
 2316               	.LM321:
 2317 0986 F801      		movw r30,r16
 2318 0988 87A1      		ldd r24,Z+39
1741:FreeRTOS/Source/tasks.c **** 				{
 2320               	.LM322:
 2321 098a 8130      		cpi r24,lo8(1)
 2322 098c 01F4      		brne .L157
1745:FreeRTOS/Source/tasks.c **** 				}
 2324               	.LM323:
 2325 098e 17A2      		std Z+39,__zero_reg__
 2326               	.L157:
1750:FreeRTOS/Source/tasks.c **** 
 2328               	.LM324:
 2329               	/* #APP */
 2330               	 ;  1750 "FreeRTOS/Source/tasks.c" 1
 2331 0990 0F90      		pop		__tmp_reg__
 2332               	 ;  0 "" 2
 2333               	 ;  1750 "FreeRTOS/Source/tasks.c" 1
 2334 0992 0FBE      		out		__SREG__, __tmp_reg__
 2335               	 ;  0 "" 2
1752:FreeRTOS/Source/tasks.c **** 		{
 2337               	.LM325:
 2338               	/* #NOAPP */
 2339 0994 8091 0000 		lds r24,xSchedulerRunning
1752:FreeRTOS/Source/tasks.c **** 		{
 2341               	.LM326:
 2342 0998 8823      		tst r24
 2343 099a 01F0      		breq .L158
1756:FreeRTOS/Source/tasks.c **** 			{
 2345               	.LM327:
 2346               	/* #APP */
 2347               	 ;  1756 "FreeRTOS/Source/tasks.c" 1
 2348 099c 0FB6      		in		__tmp_reg__, __SREG__
 2349               	 ;  0 "" 2
 2350               	 ;  1756 "FreeRTOS/Source/tasks.c" 1
 2351 099e F894      		cli
 2352               	 ;  0 "" 2
 2353               	 ;  1756 "FreeRTOS/Source/tasks.c" 1
 2354 09a0 0F92      		push	__tmp_reg__
 2355               	 ;  0 "" 2
1758:FreeRTOS/Source/tasks.c **** 			}
 2357               	.LM328:
 2358               	/* #NOAPP */
 2359 09a2 0E94 0000 		call prvResetNextTaskUnblockTime
1760:FreeRTOS/Source/tasks.c **** 		}
 2361               	.LM329:
 2362               	/* #APP */
 2363               	 ;  1760 "FreeRTOS/Source/tasks.c" 1
 2364 09a6 0F90      		pop		__tmp_reg__
 2365               	 ;  0 "" 2
 2366               	 ;  1760 "FreeRTOS/Source/tasks.c" 1
 2367 09a8 0FBE      		out		__SREG__, __tmp_reg__
 2368               	 ;  0 "" 2
 2369               	/* #NOAPP */
 2370               	.L158:
1767:FreeRTOS/Source/tasks.c **** 		{
 2372               	.LM330:
 2373 09aa 8091 0000 		lds r24,pxCurrentTCB
 2374 09ae 9091 0000 		lds r25,pxCurrentTCB+1
1767:FreeRTOS/Source/tasks.c **** 		{
 2376               	.LM331:
 2377 09b2 8017      		cp r24,r16
 2378 09b4 9107      		cpc r25,r17
 2379 09b6 01F4      		brne .L154
1769:FreeRTOS/Source/tasks.c **** 			{
 2381               	.LM332:
 2382 09b8 8091 0000 		lds r24,xSchedulerRunning
1769:FreeRTOS/Source/tasks.c **** 			{
 2384               	.LM333:
 2385 09bc 8823      		tst r24
 2386 09be 01F0      		breq .L160
1773:FreeRTOS/Source/tasks.c **** 			}
 2388               	.LM334:
 2389 09c0 0E94 0000 		call vPortYield
 2390               	.L154:
 2391               	/* epilogue start */
1798:FreeRTOS/Source/tasks.c **** 
 2393               	.LM335:
 2394 09c4 DF91      		pop r29
 2395 09c6 CF91      		pop r28
 2396 09c8 1F91      		pop r17
 2397 09ca 0F91      		pop r16
 2398 09cc 0895      		ret
 2399               	.L160:
1780:FreeRTOS/Source/tasks.c **** 				{
 2401               	.LM336:
 2402 09ce 9091 0000 		lds r25,xSuspendedTaskList
1780:FreeRTOS/Source/tasks.c **** 				{
 2404               	.LM337:
 2405 09d2 8091 0000 		lds r24,uxCurrentNumberOfTasks
1780:FreeRTOS/Source/tasks.c **** 				{
 2407               	.LM338:
 2408 09d6 9813      		cpse r25,r24
 2409 09d8 00C0      		rjmp .L161
1786:FreeRTOS/Source/tasks.c **** 				}
 2411               	.LM339:
 2412 09da 1092 0000 		sts pxCurrentTCB+1,__zero_reg__
 2413 09de 1092 0000 		sts pxCurrentTCB,__zero_reg__
 2414 09e2 00C0      		rjmp .L154
 2415               	.L161:
 2416               	/* epilogue start */
1798:FreeRTOS/Source/tasks.c **** 
 2418               	.LM340:
 2419 09e4 DF91      		pop r29
 2420 09e6 CF91      		pop r28
 2421 09e8 1F91      		pop r17
 2422 09ea 0F91      		pop r16
1790:FreeRTOS/Source/tasks.c **** 				}
 2424               	.LM341:
 2425 09ec 0C94 0000 		jmp vTaskSwitchContext
 2427               	.Lscope21:
 2432               	.global	vTaskPlaceOnEventList
 2434               	vTaskPlaceOnEventList:
3065:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2436               	.LM342:
 2437               	.LFBB22:
 2438 09f0 CF93      		push r28
 2439 09f2 DF93      		push r29
 2440               	/* prologue: function */
 2441               	/* frame size = 0 */
 2442               	/* stack size = 2 */
 2443               	.L__stack_usage = 2
 2444 09f4 EB01      		movw r28,r22
3075:FreeRTOS/Source/tasks.c **** 
 2446               	.LM343:
 2447 09f6 6091 0000 		lds r22,pxCurrentTCB
 2448 09fa 7091 0000 		lds r23,pxCurrentTCB+1
3075:FreeRTOS/Source/tasks.c **** 
 2450               	.LM344:
 2451 09fe 645F      		subi r22,-12
 2452 0a00 7F4F      		sbci r23,-1
 2453 0a02 0E94 0000 		call vListInsert
3077:FreeRTOS/Source/tasks.c **** }
 2455               	.LM345:
 2456 0a06 61E0      		ldi r22,lo8(1)
 2457 0a08 CE01      		movw r24,r28
 2458               	/* epilogue start */
3078:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2460               	.LM346:
 2461 0a0a DF91      		pop r29
 2462 0a0c CF91      		pop r28
3077:FreeRTOS/Source/tasks.c **** }
 2464               	.LM347:
 2465 0a0e 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2467               	.Lscope22:
 2473               	.global	vTaskPlaceOnUnorderedEventList
 2475               	vTaskPlaceOnUnorderedEventList:
3082:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2477               	.LM348:
 2478               	.LFBB23:
 2479 0a12 CF93      		push r28
 2480 0a14 DF93      		push r29
 2481               	/* prologue: function */
 2482               	/* frame size = 0 */
 2483               	/* stack size = 2 */
 2484               	.L__stack_usage = 2
 2485 0a16 EA01      		movw r28,r20
3092:FreeRTOS/Source/tasks.c **** 
 2487               	.LM349:
 2488 0a18 E091 0000 		lds r30,pxCurrentTCB
 2489 0a1c F091 0000 		lds r31,pxCurrentTCB+1
 2490 0a20 7068      		ori r23,128
 2491 0a22 7587      		std Z+13,r23
 2492 0a24 6487      		std Z+12,r22
3099:FreeRTOS/Source/tasks.c **** 
 2494               	.LM350:
 2495 0a26 6091 0000 		lds r22,pxCurrentTCB
 2496 0a2a 7091 0000 		lds r23,pxCurrentTCB+1
3099:FreeRTOS/Source/tasks.c **** 
 2498               	.LM351:
 2499 0a2e 645F      		subi r22,-12
 2500 0a30 7F4F      		sbci r23,-1
 2501 0a32 0E94 0000 		call vListInsertEnd
3101:FreeRTOS/Source/tasks.c **** }
 2503               	.LM352:
 2504 0a36 61E0      		ldi r22,lo8(1)
 2505 0a38 CE01      		movw r24,r28
 2506               	/* epilogue start */
3102:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2508               	.LM353:
 2509 0a3a DF91      		pop r29
 2510 0a3c CF91      		pop r28
3101:FreeRTOS/Source/tasks.c **** }
 2512               	.LM354:
 2513 0a3e 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2515               	.Lscope23:
 2519               	.global	xTaskRemoveFromEventList
 2521               	xTaskRemoveFromEventList:
3139:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2523               	.LM355:
 2524               	.LFBB24:
 2525 0a42 0F93      		push r16
 2526 0a44 1F93      		push r17
 2527 0a46 CF93      		push r28
 2528 0a48 DF93      		push r29
 2529               	/* prologue: function */
 2530               	/* frame size = 0 */
 2531               	/* stack size = 4 */
 2532               	.L__stack_usage = 4
3156:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2534               	.LM356:
 2535 0a4a DC01      		movw r26,r24
 2536 0a4c 1596      		adiw r26,5
 2537 0a4e ED91      		ld r30,X+
 2538 0a50 FC91      		ld r31,X
 2539 0a52 0681      		ldd r16,Z+6
 2540 0a54 1781      		ldd r17,Z+7
3158:FreeRTOS/Source/tasks.c **** 
 2542               	.LM357:
 2543 0a56 E801      		movw r28,r16
 2544 0a58 2C96      		adiw r28,12
 2545 0a5a CE01      		movw r24,r28
 2546 0a5c 0E94 0000 		call uxListRemove
3160:FreeRTOS/Source/tasks.c **** 	{
 2548               	.LM358:
 2549 0a60 8091 0000 		lds r24,uxSchedulerSuspended
3160:FreeRTOS/Source/tasks.c **** 	{
 2551               	.LM359:
 2552 0a64 8111      		cpse r24,__zero_reg__
 2553 0a66 00C0      		rjmp .L171
3162:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2555               	.LM360:
 2556 0a68 2A97      		sbiw r28,10
 2557 0a6a CE01      		movw r24,r28
 2558 0a6c 0E94 0000 		call uxListRemove
3163:FreeRTOS/Source/tasks.c **** 
 2560               	.LM361:
 2561 0a70 F801      		movw r30,r16
 2562 0a72 8689      		ldd r24,Z+22
 2563 0a74 9091 0000 		lds r25,uxTopReadyPriority
 2564 0a78 9817      		cp r25,r24
 2565 0a7a 00F4      		brsh .L172
3163:FreeRTOS/Source/tasks.c **** 
 2567               	.LM362:
 2568 0a7c 8093 0000 		sts uxTopReadyPriority,r24
 2569               	.L172:
3163:FreeRTOS/Source/tasks.c **** 
 2571               	.LM363:
 2572 0a80 F9E0      		ldi r31,lo8(9)
 2573 0a82 8F9F      		mul r24,r31
 2574 0a84 C001      		movw r24,r0
 2575 0a86 1124      		clr __zero_reg__
 2576 0a88 BE01      		movw r22,r28
 2577 0a8a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2578 0a8c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2579               	.L176:
3183:FreeRTOS/Source/tasks.c **** 	}
 2581               	.LM364:
 2582 0a8e 0E94 0000 		call vListInsertEnd
3186:FreeRTOS/Source/tasks.c **** 	{
 2584               	.LM365:
 2585 0a92 E091 0000 		lds r30,pxCurrentTCB
 2586 0a96 F091 0000 		lds r31,pxCurrentTCB+1
3186:FreeRTOS/Source/tasks.c **** 	{
 2588               	.LM366:
 2589 0a9a D801      		movw r26,r16
 2590 0a9c 5696      		adiw r26,22
 2591 0a9e 9C91      		ld r25,X
 2592 0aa0 8689      		ldd r24,Z+22
 2593 0aa2 8917      		cp r24,r25
 2594 0aa4 00F4      		brsh .L175
3195:FreeRTOS/Source/tasks.c **** 	}
 2596               	.LM367:
 2597 0aa6 81E0      		ldi r24,lo8(1)
 2598 0aa8 8093 0000 		sts xYieldPending,r24
 2599               	.L170:
 2600               	/* epilogue start */
3203:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2602               	.LM368:
 2603 0aac DF91      		pop r29
 2604 0aae CF91      		pop r28
 2605 0ab0 1F91      		pop r17
 2606 0ab2 0F91      		pop r16
 2607 0ab4 0895      		ret
 2608               	.L171:
3183:FreeRTOS/Source/tasks.c **** 	}
 2610               	.LM369:
 2611 0ab6 BE01      		movw r22,r28
 2612 0ab8 80E0      		ldi r24,lo8(xPendingReadyList)
 2613 0aba 90E0      		ldi r25,hi8(xPendingReadyList)
 2614 0abc 00C0      		rjmp .L176
 2615               	.L175:
3199:FreeRTOS/Source/tasks.c **** 	}
 2617               	.LM370:
 2618 0abe 80E0      		ldi r24,0
3202:FreeRTOS/Source/tasks.c **** }
 2620               	.LM371:
 2621 0ac0 00C0      		rjmp .L170
 2627               	.Lscope24:
 2632               	.global	vTaskRemoveFromUnorderedEventList
 2634               	vTaskRemoveFromUnorderedEventList:
3207:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2636               	.LM372:
 2637               	.LFBB25:
 2638 0ac2 0F93      		push r16
 2639 0ac4 1F93      		push r17
 2640 0ac6 CF93      		push r28
 2641 0ac8 DF93      		push r29
 2642               	/* prologue: function */
 2643               	/* frame size = 0 */
 2644               	/* stack size = 4 */
 2645               	.L__stack_usage = 4
3215:FreeRTOS/Source/tasks.c **** 
 2647               	.LM373:
 2648 0aca 7068      		ori r23,128
 2649 0acc DC01      		movw r26,r24
 2650 0ace 1196      		adiw r26,1
 2651 0ad0 7C93      		st X,r23
 2652 0ad2 6E93      		st -X,r22
3219:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2654               	.LM374:
 2655 0ad4 1696      		adiw r26,6
 2656 0ad6 0D91      		ld r16,X+
 2657 0ad8 1C91      		ld r17,X
3221:FreeRTOS/Source/tasks.c **** 
 2659               	.LM375:
 2660 0ada 0E94 0000 		call uxListRemove
3240:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2662               	.LM376:
 2663 0ade E801      		movw r28,r16
 2664 0ae0 2296      		adiw r28,2
 2665 0ae2 CE01      		movw r24,r28
 2666 0ae4 0E94 0000 		call uxListRemove
3241:FreeRTOS/Source/tasks.c **** 
 2668               	.LM377:
 2669 0ae8 F801      		movw r30,r16
 2670 0aea 8689      		ldd r24,Z+22
 2671 0aec 9091 0000 		lds r25,uxTopReadyPriority
 2672 0af0 9817      		cp r25,r24
 2673 0af2 00F4      		brsh .L178
3241:FreeRTOS/Source/tasks.c **** 
 2675               	.LM378:
 2676 0af4 8093 0000 		sts uxTopReadyPriority,r24
 2677               	.L178:
3241:FreeRTOS/Source/tasks.c **** 
 2679               	.LM379:
 2680 0af8 F9E0      		ldi r31,lo8(9)
 2681 0afa 8F9F      		mul r24,r31
 2682 0afc C001      		movw r24,r0
 2683 0afe 1124      		clr __zero_reg__
 2684 0b00 BE01      		movw r22,r28
 2685 0b02 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2686 0b04 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2687 0b06 0E94 0000 		call vListInsertEnd
3243:FreeRTOS/Source/tasks.c **** 	{
 2689               	.LM380:
 2690 0b0a E091 0000 		lds r30,pxCurrentTCB
 2691 0b0e F091 0000 		lds r31,pxCurrentTCB+1
3243:FreeRTOS/Source/tasks.c **** 	{
 2693               	.LM381:
 2694 0b12 D801      		movw r26,r16
 2695 0b14 5696      		adiw r26,22
 2696 0b16 9C91      		ld r25,X
 2697 0b18 8689      		ldd r24,Z+22
 2698 0b1a 8917      		cp r24,r25
 2699 0b1c 00F4      		brsh .L177
3249:FreeRTOS/Source/tasks.c **** 	}
 2701               	.LM382:
 2702 0b1e 81E0      		ldi r24,lo8(1)
 2703 0b20 8093 0000 		sts xYieldPending,r24
 2704               	.L177:
 2705               	/* epilogue start */
3251:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2707               	.LM383:
 2708 0b24 DF91      		pop r29
 2709 0b26 CF91      		pop r28
 2710 0b28 1F91      		pop r17
 2711 0b2a 0F91      		pop r16
 2712 0b2c 0895      		ret
 2717               	.Lscope25:
 2722               	.global	vTaskSetTimeOutState
 2724               	vTaskSetTimeOutState:
3255:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2726               	.LM384:
 2727               	.LFBB26:
 2728               	/* prologue: function */
 2729               	/* frame size = 0 */
 2730               	/* stack size = 0 */
 2731               	.L__stack_usage = 0
 2732 0b2e FC01      		movw r30,r24
3257:FreeRTOS/Source/tasks.c **** 	{
 2734               	.LM385:
 2735               	/* #APP */
 2736               	 ;  3257 "FreeRTOS/Source/tasks.c" 1
 2737 0b30 0FB6      		in		__tmp_reg__, __SREG__
 2738               	 ;  0 "" 2
 2739               	 ;  3257 "FreeRTOS/Source/tasks.c" 1
 2740 0b32 F894      		cli
 2741               	 ;  0 "" 2
 2742               	 ;  3257 "FreeRTOS/Source/tasks.c" 1
 2743 0b34 0F92      		push	__tmp_reg__
 2744               	 ;  0 "" 2
3259:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2746               	.LM386:
 2747               	/* #NOAPP */
 2748 0b36 8091 0000 		lds r24,xNumOfOverflows
 2749 0b3a 8083      		st Z,r24
3260:FreeRTOS/Source/tasks.c **** 	}
 2751               	.LM387:
 2752 0b3c 8091 0000 		lds r24,xTickCount
 2753 0b40 9091 0000 		lds r25,xTickCount+1
 2754 0b44 9283      		std Z+2,r25
 2755 0b46 8183      		std Z+1,r24
3262:FreeRTOS/Source/tasks.c **** }
 2757               	.LM388:
 2758               	/* #APP */
 2759               	 ;  3262 "FreeRTOS/Source/tasks.c" 1
 2760 0b48 0F90      		pop		__tmp_reg__
 2761               	 ;  0 "" 2
 2762               	 ;  3262 "FreeRTOS/Source/tasks.c" 1
 2763 0b4a 0FBE      		out		__SREG__, __tmp_reg__
 2764               	 ;  0 "" 2
 2765               	/* #NOAPP */
 2766               	/* epilogue start */
3263:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2768               	.LM389:
 2769 0b4c 0895      		ret
 2771               	.Lscope26:
 2775               	.global	vTaskInternalSetTimeOutState
 2777               	vTaskInternalSetTimeOutState:
3267:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2779               	.LM390:
 2780               	.LFBB27:
 2781               	/* prologue: function */
 2782               	/* frame size = 0 */
 2783               	/* stack size = 0 */
 2784               	.L__stack_usage = 0
 2785 0b4e FC01      		movw r30,r24
3269:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2787               	.LM391:
 2788 0b50 8091 0000 		lds r24,xNumOfOverflows
 2789 0b54 8083      		st Z,r24
3270:FreeRTOS/Source/tasks.c **** }
 2791               	.LM392:
 2792 0b56 8091 0000 		lds r24,xTickCount
 2793 0b5a 9091 0000 		lds r25,xTickCount+1
 2794 0b5e 9283      		std Z+2,r25
 2795 0b60 8183      		std Z+1,r24
 2796               	/* epilogue start */
3271:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2798               	.LM393:
 2799 0b62 0895      		ret
 2801               	.Lscope27:
 2806               	.global	xTaskCheckForTimeOut
 2808               	xTaskCheckForTimeOut:
3275:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 2810               	.LM394:
 2811               	.LFBB28:
 2812 0b64 CF93      		push r28
 2813 0b66 DF93      		push r29
 2814               	/* prologue: function */
 2815               	/* frame size = 0 */
 2816               	/* stack size = 2 */
 2817               	.L__stack_usage = 2
 2818 0b68 FB01      		movw r30,r22
3281:FreeRTOS/Source/tasks.c **** 	{
 2820               	.LM395:
 2821               	/* #APP */
 2822               	 ;  3281 "FreeRTOS/Source/tasks.c" 1
 2823 0b6a 0FB6      		in		__tmp_reg__, __SREG__
 2824               	 ;  0 "" 2
 2825               	 ;  3281 "FreeRTOS/Source/tasks.c" 1
 2826 0b6c F894      		cli
 2827               	 ;  0 "" 2
 2828               	 ;  3281 "FreeRTOS/Source/tasks.c" 1
 2829 0b6e 0F92      		push	__tmp_reg__
 2830               	 ;  0 "" 2
 2831               	/* #NOAPP */
 2832               	.LBB90:
3284:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2834               	.LM396:
 2835 0b70 6091 0000 		lds r22,xTickCount
 2836 0b74 7091 0000 		lds r23,xTickCount+1
3299:FreeRTOS/Source/tasks.c **** 			{
 2838               	.LM397:
 2839 0b78 2081      		ld r18,Z
 2840 0b7a 3181      		ldd r19,Z+1
3299:FreeRTOS/Source/tasks.c **** 			{
 2842               	.LM398:
 2843 0b7c 2F3F      		cpi r18,-1
 2844 0b7e 3207      		cpc r19,r18
 2845 0b80 01F0      		breq .L186
3285:FreeRTOS/Source/tasks.c **** 
 2847               	.LM399:
 2848 0b82 DC01      		movw r26,r24
 2849 0b84 1196      		adiw r26,1
 2850 0b86 4D91      		ld r20,X+
 2851 0b88 5C91      		ld r21,X
3309:FreeRTOS/Source/tasks.c **** 		{
 2853               	.LM400:
 2854 0b8a A091 0000 		lds r26,xNumOfOverflows
3309:FreeRTOS/Source/tasks.c **** 		{
 2856               	.LM401:
 2857 0b8e EC01      		movw r28,r24
 2858 0b90 B881      		ld r27,Y
 2859 0b92 BA17      		cp r27,r26
 2860 0b94 01F0      		breq .L184
3309:FreeRTOS/Source/tasks.c **** 		{
 2862               	.LM402:
 2863 0b96 6417      		cp r22,r20
 2864 0b98 7507      		cpc r23,r21
 2865 0b9a 00F4      		brsh .L187
 2866               	.L184:
3285:FreeRTOS/Source/tasks.c **** 
 2868               	.LM403:
 2869 0b9c DB01      		movw r26,r22
 2870 0b9e A41B      		sub r26,r20
 2871 0ba0 B50B      		sbc r27,r21
3318:FreeRTOS/Source/tasks.c **** 		{
 2873               	.LM404:
 2874 0ba2 A217      		cp r26,r18
 2875 0ba4 B307      		cpc r27,r19
 2876 0ba6 00F4      		brsh .L185
3321:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2878               	.LM405:
 2879 0ba8 261B      		sub r18,r22
 2880 0baa 370B      		sbc r19,r23
 2881 0bac 240F      		add r18,r20
 2882 0bae 351F      		adc r19,r21
 2883 0bb0 3183      		std Z+1,r19
 2884 0bb2 2083      		st Z,r18
3322:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2886               	.LM406:
 2887 0bb4 0E94 0000 		call vTaskInternalSetTimeOutState
 2888               	.L186:
3304:FreeRTOS/Source/tasks.c **** 			}
 2890               	.LM407:
 2891 0bb8 80E0      		ldi r24,0
 2892               	.L183:
 2893               	.LBE90:
3331:FreeRTOS/Source/tasks.c **** 
 2895               	.LM408:
 2896               	/* #APP */
 2897               	 ;  3331 "FreeRTOS/Source/tasks.c" 1
 2898 0bba 0F90      		pop		__tmp_reg__
 2899               	 ;  0 "" 2
 2900               	 ;  3331 "FreeRTOS/Source/tasks.c" 1
 2901 0bbc 0FBE      		out		__SREG__, __tmp_reg__
 2902               	 ;  0 "" 2
 2903               	/* #NOAPP */
 2904               	/* epilogue start */
3334:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2906               	.LM409:
 2907 0bbe DF91      		pop r29
 2908 0bc0 CF91      		pop r28
 2909 0bc2 0895      		ret
 2910               	.L185:
 2911               	.LBB91:
3327:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2913               	.LM410:
 2914 0bc4 1182      		std Z+1,__zero_reg__
 2915 0bc6 1082      		st Z,__zero_reg__
 2916               	.L187:
3316:FreeRTOS/Source/tasks.c **** 		}
 2918               	.LM411:
 2919 0bc8 81E0      		ldi r24,lo8(1)
 2920 0bca 00C0      		rjmp .L183
 2921               	.LBE91:
 2932               	.Lscope28:
 2935               	.global	vTaskMissedYield
 2937               	vTaskMissedYield:
3338:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 2939               	.LM412:
 2940               	.LFBB29:
 2941               	/* prologue: function */
 2942               	/* frame size = 0 */
 2943               	/* stack size = 0 */
 2944               	.L__stack_usage = 0
3339:FreeRTOS/Source/tasks.c **** }
 2946               	.LM413:
 2947 0bcc 81E0      		ldi r24,lo8(1)
 2948 0bce 8093 0000 		sts xYieldPending,r24
 2949               	/* epilogue start */
3340:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2951               	.LM414:
 2952 0bd2 0895      		ret
 2954               	.Lscope29:
 2957               	.global	xTaskGetCurrentTaskHandle
 2959               	xTaskGetCurrentTaskHandle:
3970:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 2961               	.LM415:
 2962               	.LFBB30:
 2963               	/* prologue: function */
 2964               	/* frame size = 0 */
 2965               	/* stack size = 0 */
 2966               	.L__stack_usage = 0
3976:FreeRTOS/Source/tasks.c **** 
 2968               	.LM416:
 2969 0bd4 8091 0000 		lds r24,pxCurrentTCB
 2970 0bd8 9091 0000 		lds r25,pxCurrentTCB+1
 2971               	/* epilogue start */
3979:FreeRTOS/Source/tasks.c **** 
 2973               	.LM417:
 2974 0bdc 0895      		ret
 2979               	.Lscope30:
 2983               	.global	xTaskPriorityInherit
 2985               	xTaskPriorityInherit:
4015:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 2987               	.LM418:
 2988               	.LFBB31:
 2989 0bde 0F93      		push r16
 2990 0be0 1F93      		push r17
 2991 0be2 CF93      		push r28
 2992 0be4 DF93      		push r29
 2993               	/* prologue: function */
 2994               	/* frame size = 0 */
 2995               	/* stack size = 4 */
 2996               	.L__stack_usage = 4
 2997 0be6 8C01      		movw r16,r24
4022:FreeRTOS/Source/tasks.c **** 		{
 2999               	.LM419:
 3000 0be8 0097      		sbiw r24,0
 3001 0bea 01F4      		brne .+2
 3002 0bec 00C0      		rjmp .L197
4027:FreeRTOS/Source/tasks.c **** 			{
 3004               	.LM420:
 3005 0bee DC01      		movw r26,r24
 3006 0bf0 5696      		adiw r26,22
 3007 0bf2 8C91      		ld r24,X
 3008 0bf4 5697      		sbiw r26,22
4027:FreeRTOS/Source/tasks.c **** 			{
 3010               	.LM421:
 3011 0bf6 E091 0000 		lds r30,pxCurrentTCB
 3012 0bfa F091 0000 		lds r31,pxCurrentTCB+1
4027:FreeRTOS/Source/tasks.c **** 			{
 3014               	.LM422:
 3015 0bfe 9689      		ldd r25,Z+22
 3016 0c00 8917      		cp r24,r25
 3017 0c02 00F0      		brlo .+2
 3018 0c04 00C0      		rjmp .L192
4032:FreeRTOS/Source/tasks.c **** 				{
 3020               	.LM423:
 3021 0c06 1C96      		adiw r26,12
 3022 0c08 2D91      		ld r18,X+
 3023 0c0a 3C91      		ld r19,X
 3024 0c0c 1D97      		sbiw r26,12+1
 3025 0c0e 37FD      		sbrc r19,7
 3026 0c10 00C0      		rjmp .L193
4034:FreeRTOS/Source/tasks.c **** 				}
 3028               	.LM424:
 3029 0c12 E091 0000 		lds r30,pxCurrentTCB
 3030 0c16 F091 0000 		lds r31,pxCurrentTCB+1
 3031 0c1a 9689      		ldd r25,Z+22
 3032 0c1c 24E0      		ldi r18,lo8(4)
 3033 0c1e 30E0      		ldi r19,0
 3034 0c20 291B      		sub r18,r25
 3035 0c22 3109      		sbc r19,__zero_reg__
 3036 0c24 1D96      		adiw r26,12+1
 3037 0c26 3C93      		st X,r19
 3038 0c28 2E93      		st -X,r18
 3039 0c2a 1C97      		sbiw r26,12
 3040               	.L193:
4043:FreeRTOS/Source/tasks.c **** 				{
 3042               	.LM425:
 3043 0c2c B9E0      		ldi r27,lo8(9)
 3044 0c2e 8B9F      		mul r24,r27
 3045 0c30 C001      		movw r24,r0
 3046 0c32 1124      		clr __zero_reg__
 3047 0c34 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3048 0c36 9040      		sbci r25,hi8(-(pxReadyTasksLists))
4043:FreeRTOS/Source/tasks.c **** 				{
 3050               	.LM426:
 3051 0c38 F801      		movw r30,r16
 3052 0c3a 2285      		ldd r18,Z+10
 3053 0c3c 3385      		ldd r19,Z+11
 3054 0c3e 2817      		cp r18,r24
 3055 0c40 3907      		cpc r19,r25
 3056 0c42 01F4      		brne .L194
4045:FreeRTOS/Source/tasks.c **** 					{
 3058               	.LM427:
 3059 0c44 E801      		movw r28,r16
 3060 0c46 2296      		adiw r28,2
 3061 0c48 CE01      		movw r24,r28
 3062 0c4a 0E94 0000 		call uxListRemove
4058:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
 3064               	.LM428:
 3065 0c4e E091 0000 		lds r30,pxCurrentTCB
 3066 0c52 F091 0000 		lds r31,pxCurrentTCB+1
 3067 0c56 8689      		ldd r24,Z+22
4058:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
 3069               	.LM429:
 3070 0c58 D801      		movw r26,r16
 3071 0c5a 5696      		adiw r26,22
 3072 0c5c 8C93      		st X,r24
4059:FreeRTOS/Source/tasks.c **** 				}
 3074               	.LM430:
 3075 0c5e 9091 0000 		lds r25,uxTopReadyPriority
 3076 0c62 9817      		cp r25,r24
 3077 0c64 00F4      		brsh .L195
4059:FreeRTOS/Source/tasks.c **** 				}
 3079               	.LM431:
 3080 0c66 8093 0000 		sts uxTopReadyPriority,r24
 3081               	.L195:
4059:FreeRTOS/Source/tasks.c **** 				}
 3083               	.LM432:
 3084 0c6a B9E0      		ldi r27,lo8(9)
 3085 0c6c 8B9F      		mul r24,r27
 3086 0c6e C001      		movw r24,r0
 3087 0c70 1124      		clr __zero_reg__
 3088 0c72 BE01      		movw r22,r28
 3089 0c74 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3090 0c76 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3091 0c78 0E94 0000 		call vListInsertEnd
 3092               	.L198:
4070:FreeRTOS/Source/tasks.c **** 			}
 3094               	.LM433:
 3095 0c7c 81E0      		ldi r24,lo8(1)
 3096               	.L190:
 3097               	/* epilogue start */
4097:FreeRTOS/Source/tasks.c **** 
 3099               	.LM434:
 3100 0c7e DF91      		pop r29
 3101 0c80 CF91      		pop r28
 3102 0c82 1F91      		pop r17
 3103 0c84 0F91      		pop r16
 3104 0c86 0895      		ret
 3105               	.L194:
4064:FreeRTOS/Source/tasks.c **** 				}
 3107               	.LM435:
 3108 0c88 E091 0000 		lds r30,pxCurrentTCB
 3109 0c8c F091 0000 		lds r31,pxCurrentTCB+1
 3110 0c90 8689      		ldd r24,Z+22
4064:FreeRTOS/Source/tasks.c **** 				}
 3112               	.LM436:
 3113 0c92 F801      		movw r30,r16
 3114 0c94 868B      		std Z+22,r24
 3115 0c96 00C0      		rjmp .L198
 3116               	.L192:
4074:FreeRTOS/Source/tasks.c **** 				{
 3118               	.LM437:
 3119 0c98 E091 0000 		lds r30,pxCurrentTCB
 3120 0c9c F091 0000 		lds r31,pxCurrentTCB+1
4074:FreeRTOS/Source/tasks.c **** 				{
 3122               	.LM438:
 3123 0ca0 81E0      		ldi r24,lo8(1)
 3124 0ca2 9196      		adiw r26,33
 3125 0ca4 2C91      		ld r18,X
 3126 0ca6 9689      		ldd r25,Z+22
 3127 0ca8 2917      		cp r18,r25
 3128 0caa 00F0      		brlo .L190
 3129               	.L197:
4017:FreeRTOS/Source/tasks.c **** 
 3131               	.LM439:
 3132 0cac 80E0      		ldi r24,0
4096:FreeRTOS/Source/tasks.c **** 	}
 3134               	.LM440:
 3135 0cae 00C0      		rjmp .L190
 3140               	.Lscope31:
 3144               	.global	xTaskPriorityDisinherit
 3146               	xTaskPriorityDisinherit:
4105:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
 3148               	.LM441:
 3149               	.LFBB32:
 3150 0cb0 0F93      		push r16
 3151 0cb2 1F93      		push r17
 3152 0cb4 CF93      		push r28
 3153 0cb6 DF93      		push r29
 3154               	/* prologue: function */
 3155               	/* frame size = 0 */
 3156               	/* stack size = 4 */
 3157               	.L__stack_usage = 4
 3158 0cb8 8C01      		movw r16,r24
4109:FreeRTOS/Source/tasks.c **** 		{
 3160               	.LM442:
 3161 0cba 0097      		sbiw r24,0
 3162 0cbc 01F4      		brne .L200
 3163               	.L202:
4107:FreeRTOS/Source/tasks.c **** 
 3165               	.LM443:
 3166 0cbe 80E0      		ldi r24,0
 3167               	.L199:
 3168               	/* epilogue start */
4177:FreeRTOS/Source/tasks.c **** 
 3170               	.LM444:
 3171 0cc0 DF91      		pop r29
 3172 0cc2 CF91      		pop r28
 3173 0cc4 1F91      		pop r17
 3174 0cc6 0F91      		pop r16
 3175 0cc8 0895      		ret
 3176               	.L200:
4117:FreeRTOS/Source/tasks.c **** 
 3178               	.LM445:
 3179 0cca FC01      		movw r30,r24
 3180 0ccc 82A1      		ldd r24,Z+34
 3181 0cce 8150      		subi r24,lo8(-(-1))
 3182 0cd0 82A3      		std Z+34,r24
4121:FreeRTOS/Source/tasks.c **** 			{
 3184               	.LM446:
 3185 0cd2 2689      		ldd r18,Z+22
 3186 0cd4 91A1      		ldd r25,Z+33
 3187 0cd6 2917      		cp r18,r25
 3188 0cd8 01F0      		breq .L202
4124:FreeRTOS/Source/tasks.c **** 				{
 3190               	.LM447:
 3191 0cda 8111      		cpse r24,__zero_reg__
 3192 0cdc 00C0      		rjmp .L202
4131:FreeRTOS/Source/tasks.c **** 					{
 3194               	.LM448:
 3195 0cde E801      		movw r28,r16
 3196 0ce0 2296      		adiw r28,2
 3197 0ce2 CE01      		movw r24,r28
 3198 0ce4 0E94 0000 		call uxListRemove
4143:FreeRTOS/Source/tasks.c **** 
 3200               	.LM449:
 3201 0ce8 F801      		movw r30,r16
 3202 0cea 81A1      		ldd r24,Z+33
4143:FreeRTOS/Source/tasks.c **** 
 3204               	.LM450:
 3205 0cec 868B      		std Z+22,r24
4148:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3207               	.LM451:
 3208 0cee 24E0      		ldi r18,lo8(4)
 3209 0cf0 30E0      		ldi r19,0
 3210 0cf2 281B      		sub r18,r24
 3211 0cf4 3109      		sbc r19,__zero_reg__
 3212 0cf6 3587      		std Z+13,r19
 3213 0cf8 2487      		std Z+12,r18
4149:FreeRTOS/Source/tasks.c **** 
 3215               	.LM452:
 3216 0cfa 9091 0000 		lds r25,uxTopReadyPriority
 3217 0cfe 9817      		cp r25,r24
 3218 0d00 00F4      		brsh .L203
4149:FreeRTOS/Source/tasks.c **** 
 3220               	.LM453:
 3221 0d02 8093 0000 		sts uxTopReadyPriority,r24
 3222               	.L203:
4149:FreeRTOS/Source/tasks.c **** 
 3224               	.LM454:
 3225 0d06 F9E0      		ldi r31,lo8(9)
 3226 0d08 8F9F      		mul r24,r31
 3227 0d0a C001      		movw r24,r0
 3228 0d0c 1124      		clr __zero_reg__
 3229 0d0e BE01      		movw r22,r28
 3230 0d10 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3231 0d12 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3232 0d14 0E94 0000 		call vListInsertEnd
4159:FreeRTOS/Source/tasks.c **** 				}
 3234               	.LM455:
 3235 0d18 81E0      		ldi r24,lo8(1)
4176:FreeRTOS/Source/tasks.c **** 	}
 3237               	.LM456:
 3238 0d1a 00C0      		rjmp .L199
 3243               	.Lscope32:
 3248               	.global	vTaskPriorityDisinheritAfterTimeout
 3250               	vTaskPriorityDisinheritAfterTimeout:
4185:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
 3252               	.LM457:
 3253               	.LFBB33:
 3254 0d1c 0F93      		push r16
 3255 0d1e 1F93      		push r17
 3256 0d20 CF93      		push r28
 3257 0d22 DF93      		push r29
 3258               	/* prologue: function */
 3259               	/* frame size = 0 */
 3260               	/* stack size = 4 */
 3261               	.L__stack_usage = 4
 3262 0d24 8C01      		movw r16,r24
4190:FreeRTOS/Source/tasks.c **** 		{
 3264               	.LM458:
 3265 0d26 0097      		sbiw r24,0
 3266 0d28 01F0      		breq .L204
 3267 0d2a FC01      		movw r30,r24
 3268 0d2c 91A1      		ldd r25,Z+33
 3269 0d2e 9617      		cp r25,r22
 3270 0d30 00F4      		brsh .L207
 3271 0d32 962F      		mov r25,r22
 3272               	.L207:
4210:FreeRTOS/Source/tasks.c **** 			{
 3274               	.LM459:
 3275 0d34 F801      		movw r30,r16
 3276 0d36 8689      		ldd r24,Z+22
4210:FreeRTOS/Source/tasks.c **** 			{
 3278               	.LM460:
 3279 0d38 8917      		cp r24,r25
 3280 0d3a 01F0      		breq .L204
4216:FreeRTOS/Source/tasks.c **** 				{
 3282               	.LM461:
 3283 0d3c 22A1      		ldd r18,Z+34
 3284 0d3e 2130      		cpi r18,lo8(1)
 3285 0d40 01F4      		brne .L204
4228:FreeRTOS/Source/tasks.c **** 
 3287               	.LM462:
 3288 0d42 968B      		std Z+22,r25
4232:FreeRTOS/Source/tasks.c **** 					{
 3290               	.LM463:
 3291 0d44 2485      		ldd r18,Z+12
 3292 0d46 3585      		ldd r19,Z+13
 3293 0d48 37FD      		sbrc r19,7
 3294 0d4a 00C0      		rjmp .L209
4234:FreeRTOS/Source/tasks.c **** 					}
 3296               	.LM464:
 3297 0d4c 24E0      		ldi r18,lo8(4)
 3298 0d4e 30E0      		ldi r19,0
 3299 0d50 291B      		sub r18,r25
 3300 0d52 3109      		sbc r19,__zero_reg__
 3301 0d54 3587      		std Z+13,r19
 3302 0d56 2487      		std Z+12,r18
 3303               	.L209:
4247:FreeRTOS/Source/tasks.c **** 					{
 3305               	.LM465:
 3306 0d58 F9E0      		ldi r31,lo8(9)
 3307 0d5a 8F9F      		mul r24,r31
 3308 0d5c C001      		movw r24,r0
 3309 0d5e 1124      		clr __zero_reg__
 3310 0d60 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3311 0d62 9040      		sbci r25,hi8(-(pxReadyTasksLists))
4247:FreeRTOS/Source/tasks.c **** 					{
 3313               	.LM466:
 3314 0d64 F801      		movw r30,r16
 3315 0d66 2285      		ldd r18,Z+10
 3316 0d68 3385      		ldd r19,Z+11
 3317 0d6a 2817      		cp r18,r24
 3318 0d6c 3907      		cpc r19,r25
 3319 0d6e 01F4      		brne .L204
4249:FreeRTOS/Source/tasks.c **** 						{
 3321               	.LM467:
 3322 0d70 E801      		movw r28,r16
 3323 0d72 2296      		adiw r28,2
 3324 0d74 CE01      		movw r24,r28
 3325 0d76 0E94 0000 		call uxListRemove
4261:FreeRTOS/Source/tasks.c **** 					}
 3327               	.LM468:
 3328 0d7a F801      		movw r30,r16
 3329 0d7c 8689      		ldd r24,Z+22
 3330 0d7e 9091 0000 		lds r25,uxTopReadyPriority
 3331 0d82 9817      		cp r25,r24
 3332 0d84 00F4      		brsh .L210
4261:FreeRTOS/Source/tasks.c **** 					}
 3334               	.LM469:
 3335 0d86 8093 0000 		sts uxTopReadyPriority,r24
 3336               	.L210:
4261:FreeRTOS/Source/tasks.c **** 					}
 3338               	.LM470:
 3339 0d8a F9E0      		ldi r31,lo8(9)
 3340 0d8c 8F9F      		mul r24,r31
 3341 0d8e C001      		movw r24,r0
 3342 0d90 1124      		clr __zero_reg__
 3343 0d92 BE01      		movw r22,r28
 3344 0d94 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3345 0d96 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3346               	/* epilogue start */
4282:FreeRTOS/Source/tasks.c **** 
 3348               	.LM471:
 3349 0d98 DF91      		pop r29
 3350 0d9a CF91      		pop r28
 3351 0d9c 1F91      		pop r17
 3352 0d9e 0F91      		pop r16
4261:FreeRTOS/Source/tasks.c **** 					}
 3354               	.LM472:
 3355 0da0 0C94 0000 		jmp vListInsertEnd
 3356               	.L204:
 3357               	/* epilogue start */
4282:FreeRTOS/Source/tasks.c **** 
 3359               	.LM473:
 3360 0da4 DF91      		pop r29
 3361 0da6 CF91      		pop r28
 3362 0da8 1F91      		pop r17
 3363 0daa 0F91      		pop r16
 3364 0dac 0895      		ret
 3369               	.Lscope33:
 3372               	.global	uxTaskResetEventItemValue
 3374               	uxTaskResetEventItemValue:
4603:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
 3376               	.LM474:
 3377               	.LFBB34:
 3378               	/* prologue: function */
 3379               	/* frame size = 0 */
 3380               	/* stack size = 0 */
 3381               	.L__stack_usage = 0
4606:FreeRTOS/Source/tasks.c **** 
 3383               	.LM475:
 3384 0dae E091 0000 		lds r30,pxCurrentTCB
 3385 0db2 F091 0000 		lds r31,pxCurrentTCB+1
4606:FreeRTOS/Source/tasks.c **** 
 3387               	.LM476:
 3388 0db6 8485      		ldd r24,Z+12
 3389 0db8 9585      		ldd r25,Z+13
4610:FreeRTOS/Source/tasks.c **** 
 3391               	.LM477:
 3392 0dba A091 0000 		lds r26,pxCurrentTCB
 3393 0dbe B091 0000 		lds r27,pxCurrentTCB+1
 3394 0dc2 E091 0000 		lds r30,pxCurrentTCB
 3395 0dc6 F091 0000 		lds r31,pxCurrentTCB+1
 3396 0dca 5696      		adiw r26,22
 3397 0dcc 4C91      		ld r20,X
 3398 0dce 24E0      		ldi r18,lo8(4)
 3399 0dd0 30E0      		ldi r19,0
 3400 0dd2 241B      		sub r18,r20
 3401 0dd4 3109      		sbc r19,__zero_reg__
 3402 0dd6 3587      		std Z+13,r19
 3403 0dd8 2487      		std Z+12,r18
 3404               	/* epilogue start */
4613:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3406               	.LM478:
 3407 0dda 0895      		ret
 3412               	.Lscope34:
 3415               	.global	pvTaskIncrementMutexHeldCount
 3417               	pvTaskIncrementMutexHeldCount:
4619:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
 3419               	.LM479:
 3420               	.LFBB35:
 3421               	/* prologue: function */
 3422               	/* frame size = 0 */
 3423               	/* stack size = 0 */
 3424               	.L__stack_usage = 0
4622:FreeRTOS/Source/tasks.c **** 		{
 3426               	.LM480:
 3427 0ddc 8091 0000 		lds r24,pxCurrentTCB
 3428 0de0 9091 0000 		lds r25,pxCurrentTCB+1
4622:FreeRTOS/Source/tasks.c **** 		{
 3430               	.LM481:
 3431 0de4 892B      		or r24,r25
 3432 0de6 01F0      		breq .L213
4624:FreeRTOS/Source/tasks.c **** 		}
 3434               	.LM482:
 3435 0de8 E091 0000 		lds r30,pxCurrentTCB
 3436 0dec F091 0000 		lds r31,pxCurrentTCB+1
4624:FreeRTOS/Source/tasks.c **** 		}
 3438               	.LM483:
 3439 0df0 82A1      		ldd r24,Z+34
 3440 0df2 8F5F      		subi r24,lo8(-(1))
 3441 0df4 82A3      		std Z+34,r24
 3442               	.L213:
4627:FreeRTOS/Source/tasks.c **** 	}
 3444               	.LM484:
 3445 0df6 8091 0000 		lds r24,pxCurrentTCB
 3446 0dfa 9091 0000 		lds r25,pxCurrentTCB+1
 3447               	/* epilogue start */
4628:FreeRTOS/Source/tasks.c **** 
 3449               	.LM485:
 3450 0dfe 0895      		ret
 3452               	.Lscope35:
 3457               	.global	ulTaskNotifyTake
 3459               	ulTaskNotifyTake:
4636:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
 3461               	.LM486:
 3462               	.LFBB36:
 3463 0e00 0F93      		push r16
 3464 0e02 1F93      		push r17
 3465 0e04 CF93      		push r28
 3466               	/* prologue: function */
 3467               	/* frame size = 0 */
 3468               	/* stack size = 3 */
 3469               	.L__stack_usage = 3
 3470 0e06 C82F      		mov r28,r24
 3471 0e08 CB01      		movw r24,r22
4639:FreeRTOS/Source/tasks.c **** 		{
 3473               	.LM487:
 3474               	/* #APP */
 3475               	 ;  4639 "FreeRTOS/Source/tasks.c" 1
 3476 0e0a 0FB6      		in		__tmp_reg__, __SREG__
 3477               	 ;  0 "" 2
 3478               	 ;  4639 "FreeRTOS/Source/tasks.c" 1
 3479 0e0c F894      		cli
 3480               	 ;  0 "" 2
 3481               	 ;  4639 "FreeRTOS/Source/tasks.c" 1
 3482 0e0e 0F92      		push	__tmp_reg__
 3483               	 ;  0 "" 2
4642:FreeRTOS/Source/tasks.c **** 			{
 3485               	.LM488:
 3486               	/* #NOAPP */
 3487 0e10 E091 0000 		lds r30,pxCurrentTCB
 3488 0e14 F091 0000 		lds r31,pxCurrentTCB+1
 3489 0e18 43A1      		ldd r20,Z+35
 3490 0e1a 54A1      		ldd r21,Z+36
 3491 0e1c 65A1      		ldd r22,Z+37
 3492 0e1e 76A1      		ldd r23,Z+38
4642:FreeRTOS/Source/tasks.c **** 			{
 3494               	.LM489:
 3495 0e20 452B      		or r20,r21
 3496 0e22 462B      		or r20,r22
 3497 0e24 472B      		or r20,r23
 3498 0e26 01F4      		brne .L219
4645:FreeRTOS/Source/tasks.c **** 
 3500               	.LM490:
 3501 0e28 E091 0000 		lds r30,pxCurrentTCB
 3502 0e2c F091 0000 		lds r31,pxCurrentTCB+1
4645:FreeRTOS/Source/tasks.c **** 
 3504               	.LM491:
 3505 0e30 21E0      		ldi r18,lo8(1)
 3506 0e32 27A3      		std Z+39,r18
4647:FreeRTOS/Source/tasks.c **** 				{
 3508               	.LM492:
 3509 0e34 0097      		sbiw r24,0
 3510 0e36 01F0      		breq .L219
4649:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 3512               	.LM493:
 3513 0e38 61E0      		ldi r22,lo8(1)
 3514 0e3a 0E94 0000 		call prvAddCurrentTaskToDelayedList
4656:FreeRTOS/Source/tasks.c **** 				}
 3516               	.LM494:
 3517 0e3e 0E94 0000 		call vPortYield
 3518               	.L219:
4668:FreeRTOS/Source/tasks.c **** 
 3520               	.LM495:
 3521               	/* #APP */
 3522               	 ;  4668 "FreeRTOS/Source/tasks.c" 1
 3523 0e42 0F90      		pop		__tmp_reg__
 3524               	 ;  0 "" 2
 3525               	 ;  4668 "FreeRTOS/Source/tasks.c" 1
 3526 0e44 0FBE      		out		__SREG__, __tmp_reg__
 3527               	 ;  0 "" 2
4670:FreeRTOS/Source/tasks.c **** 		{
 3529               	.LM496:
 3530               	 ;  4670 "FreeRTOS/Source/tasks.c" 1
 3531 0e46 0FB6      		in		__tmp_reg__, __SREG__
 3532               	 ;  0 "" 2
 3533               	 ;  4670 "FreeRTOS/Source/tasks.c" 1
 3534 0e48 F894      		cli
 3535               	 ;  0 "" 2
 3536               	 ;  4670 "FreeRTOS/Source/tasks.c" 1
 3537 0e4a 0F92      		push	__tmp_reg__
 3538               	 ;  0 "" 2
4673:FreeRTOS/Source/tasks.c **** 
 3540               	.LM497:
 3541               	/* #NOAPP */
 3542 0e4c E091 0000 		lds r30,pxCurrentTCB
 3543 0e50 F091 0000 		lds r31,pxCurrentTCB+1
4673:FreeRTOS/Source/tasks.c **** 
 3545               	.LM498:
 3546 0e54 63A1      		ldd r22,Z+35
 3547 0e56 74A1      		ldd r23,Z+36
 3548 0e58 85A1      		ldd r24,Z+37
 3549 0e5a 96A1      		ldd r25,Z+38
4675:FreeRTOS/Source/tasks.c **** 			{
 3551               	.LM499:
 3552 0e5c 6115      		cp r22,__zero_reg__
 3553 0e5e 7105      		cpc r23,__zero_reg__
 3554 0e60 8105      		cpc r24,__zero_reg__
 3555 0e62 9105      		cpc r25,__zero_reg__
 3556 0e64 01F0      		breq .L221
4679:FreeRTOS/Source/tasks.c **** 				}
 3558               	.LM500:
 3559 0e66 E091 0000 		lds r30,pxCurrentTCB
 3560 0e6a F091 0000 		lds r31,pxCurrentTCB+1
4677:FreeRTOS/Source/tasks.c **** 				{
 3562               	.LM501:
 3563 0e6e CC23      		tst r28
 3564 0e70 01F0      		breq .L222
4679:FreeRTOS/Source/tasks.c **** 				}
 3566               	.LM502:
 3567 0e72 13A2      		std Z+35,__zero_reg__
 3568 0e74 14A2      		std Z+36,__zero_reg__
 3569 0e76 15A2      		std Z+37,__zero_reg__
 3570 0e78 16A2      		std Z+38,__zero_reg__
 3571               	.L221:
4691:FreeRTOS/Source/tasks.c **** 		}
 3573               	.LM503:
 3574 0e7a E091 0000 		lds r30,pxCurrentTCB
 3575 0e7e F091 0000 		lds r31,pxCurrentTCB+1
4691:FreeRTOS/Source/tasks.c **** 		}
 3577               	.LM504:
 3578 0e82 17A2      		std Z+39,__zero_reg__
4693:FreeRTOS/Source/tasks.c **** 
 3580               	.LM505:
 3581               	/* #APP */
 3582               	 ;  4693 "FreeRTOS/Source/tasks.c" 1
 3583 0e84 0F90      		pop		__tmp_reg__
 3584               	 ;  0 "" 2
 3585               	 ;  4693 "FreeRTOS/Source/tasks.c" 1
 3586 0e86 0FBE      		out		__SREG__, __tmp_reg__
 3587               	 ;  0 "" 2
 3588               	/* #NOAPP */
 3589               	/* epilogue start */
4696:FreeRTOS/Source/tasks.c **** 
 3591               	.LM506:
 3592 0e88 CF91      		pop r28
 3593 0e8a 1F91      		pop r17
 3594 0e8c 0F91      		pop r16
 3595 0e8e 0895      		ret
 3596               	.L222:
4683:FreeRTOS/Source/tasks.c **** 				}
 3598               	.LM507:
 3599 0e90 8B01      		movw r16,r22
 3600 0e92 9C01      		movw r18,r24
 3601 0e94 0150      		subi r16,1
 3602 0e96 1109      		sbc r17,__zero_reg__
 3603 0e98 2109      		sbc r18,__zero_reg__
 3604 0e9a 3109      		sbc r19,__zero_reg__
4683:FreeRTOS/Source/tasks.c **** 				}
 3606               	.LM508:
 3607 0e9c 03A3      		std Z+35,r16
 3608 0e9e 14A3      		std Z+36,r17
 3609 0ea0 25A3      		std Z+37,r18
 3610 0ea2 36A3      		std Z+38,r19
 3611 0ea4 00C0      		rjmp .L221
 3616               	.Lscope36:
 3623               	.global	xTaskNotifyWait
 3625               	xTaskNotifyWait:
4704:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 3627               	.LM509:
 3628               	.LFBB37:
 3629 0ea6 4F92      		push r4
 3630 0ea8 5F92      		push r5
 3631 0eaa 6F92      		push r6
 3632 0eac 7F92      		push r7
 3633 0eae 8F92      		push r8
 3634 0eb0 9F92      		push r9
 3635 0eb2 AF92      		push r10
 3636 0eb4 BF92      		push r11
 3637 0eb6 EF92      		push r14
 3638 0eb8 FF92      		push r15
 3639 0eba 0F93      		push r16
 3640 0ebc 1F93      		push r17
 3641 0ebe CF93      		push r28
 3642 0ec0 DF93      		push r29
 3643 0ec2 00D0      		rcall .
 3644 0ec4 00D0      		rcall .
 3645 0ec6 CDB7      		in r28,__SP_L__
 3646 0ec8 DEB7      		in r29,__SP_H__
 3647               	/* prologue: function */
 3648               	/* frame size = 4 */
 3649               	/* stack size = 18 */
 3650               	.L__stack_usage = 18
 3651 0eca 6983      		std Y+1,r22
 3652 0ecc 7A83      		std Y+2,r23
 3653 0ece 8B83      		std Y+3,r24
 3654 0ed0 9C83      		std Y+4,r25
 3655 0ed2 2B01      		movw r4,r22
 3656 0ed4 3C01      		movw r6,r24
 3657 0ed6 4901      		movw r8,r18
 3658 0ed8 5A01      		movw r10,r20
 3659 0eda C701      		movw r24,r14
4707:FreeRTOS/Source/tasks.c **** 		{
 3661               	.LM510:
 3662               	/* #APP */
 3663               	 ;  4707 "FreeRTOS/Source/tasks.c" 1
 3664 0edc 0FB6      		in		__tmp_reg__, __SREG__
 3665               	 ;  0 "" 2
 3666               	 ;  4707 "FreeRTOS/Source/tasks.c" 1
 3667 0ede F894      		cli
 3668               	 ;  0 "" 2
 3669               	 ;  4707 "FreeRTOS/Source/tasks.c" 1
 3670 0ee0 0F92      		push	__tmp_reg__
 3671               	 ;  0 "" 2
4710:FreeRTOS/Source/tasks.c **** 			{
 3673               	.LM511:
 3674               	/* #NOAPP */
 3675 0ee2 E091 0000 		lds r30,pxCurrentTCB
 3676 0ee6 F091 0000 		lds r31,pxCurrentTCB+1
 3677 0eea 27A1      		ldd r18,Z+39
4710:FreeRTOS/Source/tasks.c **** 			{
 3679               	.LM512:
 3680 0eec 2230      		cpi r18,lo8(2)
 3681 0eee 01F0      		breq .L231
4715:FreeRTOS/Source/tasks.c **** 
 3683               	.LM513:
 3684 0ef0 E091 0000 		lds r30,pxCurrentTCB
 3685 0ef4 F091 0000 		lds r31,pxCurrentTCB+1
 3686 0ef8 43A1      		ldd r20,Z+35
 3687 0efa 54A1      		ldd r21,Z+36
 3688 0efc 65A1      		ldd r22,Z+37
 3689 0efe 76A1      		ldd r23,Z+38
4715:FreeRTOS/Source/tasks.c **** 
 3691               	.LM514:
 3692 0f00 4094      		com r4
 3693 0f02 5094      		com r5
 3694 0f04 6094      		com r6
 3695 0f06 7094      		com r7
4715:FreeRTOS/Source/tasks.c **** 
 3697               	.LM515:
 3698 0f08 4422      		and r4,r20
 3699 0f0a 5522      		and r5,r21
 3700 0f0c 6622      		and r6,r22
 3701 0f0e 7722      		and r7,r23
 3702 0f10 43A2      		std Z+35,r4
 3703 0f12 54A2      		std Z+36,r5
 3704 0f14 65A2      		std Z+37,r6
 3705 0f16 76A2      		std Z+38,r7
4718:FreeRTOS/Source/tasks.c **** 
 3707               	.LM516:
 3708 0f18 E091 0000 		lds r30,pxCurrentTCB
 3709 0f1c F091 0000 		lds r31,pxCurrentTCB+1
4718:FreeRTOS/Source/tasks.c **** 
 3711               	.LM517:
 3712 0f20 21E0      		ldi r18,lo8(1)
 3713 0f22 27A3      		std Z+39,r18
4720:FreeRTOS/Source/tasks.c **** 				{
 3715               	.LM518:
 3716 0f24 0097      		sbiw r24,0
 3717 0f26 01F0      		breq .L231
4722:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 3719               	.LM519:
 3720 0f28 61E0      		ldi r22,lo8(1)
 3721 0f2a 0E94 0000 		call prvAddCurrentTaskToDelayedList
4729:FreeRTOS/Source/tasks.c **** 				}
 3723               	.LM520:
 3724 0f2e 0E94 0000 		call vPortYield
 3725               	.L231:
4741:FreeRTOS/Source/tasks.c **** 
 3727               	.LM521:
 3728               	/* #APP */
 3729               	 ;  4741 "FreeRTOS/Source/tasks.c" 1
 3730 0f32 0F90      		pop		__tmp_reg__
 3731               	 ;  0 "" 2
 3732               	 ;  4741 "FreeRTOS/Source/tasks.c" 1
 3733 0f34 0FBE      		out		__SREG__, __tmp_reg__
 3734               	 ;  0 "" 2
4743:FreeRTOS/Source/tasks.c **** 		{
 3736               	.LM522:
 3737               	 ;  4743 "FreeRTOS/Source/tasks.c" 1
 3738 0f36 0FB6      		in		__tmp_reg__, __SREG__
 3739               	 ;  0 "" 2
 3740               	 ;  4743 "FreeRTOS/Source/tasks.c" 1
 3741 0f38 F894      		cli
 3742               	 ;  0 "" 2
 3743               	 ;  4743 "FreeRTOS/Source/tasks.c" 1
 3744 0f3a 0F92      		push	__tmp_reg__
 3745               	 ;  0 "" 2
4747:FreeRTOS/Source/tasks.c **** 			{
 3747               	.LM523:
 3748               	/* #NOAPP */
 3749 0f3c 0115      		cp r16,__zero_reg__
 3750 0f3e 1105      		cpc r17,__zero_reg__
 3751 0f40 01F0      		breq .L233
4751:FreeRTOS/Source/tasks.c **** 			}
 3753               	.LM524:
 3754 0f42 E091 0000 		lds r30,pxCurrentTCB
 3755 0f46 F091 0000 		lds r31,pxCurrentTCB+1
 3756 0f4a 83A1      		ldd r24,Z+35
 3757 0f4c 94A1      		ldd r25,Z+36
 3758 0f4e A5A1      		ldd r26,Z+37
 3759 0f50 B6A1      		ldd r27,Z+38
4751:FreeRTOS/Source/tasks.c **** 			}
 3761               	.LM525:
 3762 0f52 F801      		movw r30,r16
 3763 0f54 8083      		st Z,r24
 3764 0f56 9183      		std Z+1,r25
 3765 0f58 A283      		std Z+2,r26
 3766 0f5a B383      		std Z+3,r27
 3767               	.L233:
4758:FreeRTOS/Source/tasks.c **** 			{
 3769               	.LM526:
 3770 0f5c E091 0000 		lds r30,pxCurrentTCB
 3771 0f60 F091 0000 		lds r31,pxCurrentTCB+1
 3772 0f64 87A1      		ldd r24,Z+39
4758:FreeRTOS/Source/tasks.c **** 			{
 3774               	.LM527:
 3775 0f66 8230      		cpi r24,lo8(2)
 3776 0f68 01F4      		brne .L235
4767:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3778               	.LM528:
 3779 0f6a E091 0000 		lds r30,pxCurrentTCB
 3780 0f6e F091 0000 		lds r31,pxCurrentTCB+1
 3781 0f72 83A1      		ldd r24,Z+35
 3782 0f74 94A1      		ldd r25,Z+36
 3783 0f76 A5A1      		ldd r26,Z+37
 3784 0f78 B6A1      		ldd r27,Z+38
4767:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3786               	.LM529:
 3787 0f7a 8094      		com r8
 3788 0f7c 9094      		com r9
 3789 0f7e A094      		com r10
 3790 0f80 B094      		com r11
4767:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3792               	.LM530:
 3793 0f82 8821      		and r24,r8
 3794 0f84 9921      		and r25,r9
 3795 0f86 AA21      		and r26,r10
 3796 0f88 BB21      		and r27,r11
 3797 0f8a 83A3      		std Z+35,r24
 3798 0f8c 94A3      		std Z+36,r25
 3799 0f8e A5A3      		std Z+37,r26
 3800 0f90 B6A3      		std Z+38,r27
4768:FreeRTOS/Source/tasks.c **** 			}
 3802               	.LM531:
 3803 0f92 81E0      		ldi r24,lo8(1)
 3804               	.L234:
4771:FreeRTOS/Source/tasks.c **** 		}
 3806               	.LM532:
 3807 0f94 E091 0000 		lds r30,pxCurrentTCB
 3808 0f98 F091 0000 		lds r31,pxCurrentTCB+1
4771:FreeRTOS/Source/tasks.c **** 		}
 3810               	.LM533:
 3811 0f9c 17A2      		std Z+39,__zero_reg__
4773:FreeRTOS/Source/tasks.c **** 
 3813               	.LM534:
 3814               	/* #APP */
 3815               	 ;  4773 "FreeRTOS/Source/tasks.c" 1
 3816 0f9e 0F90      		pop		__tmp_reg__
 3817               	 ;  0 "" 2
 3818               	 ;  4773 "FreeRTOS/Source/tasks.c" 1
 3819 0fa0 0FBE      		out		__SREG__, __tmp_reg__
 3820               	 ;  0 "" 2
 3821               	/* #NOAPP */
 3822               	/* epilogue start */
4776:FreeRTOS/Source/tasks.c **** 
 3824               	.LM535:
 3825 0fa2 0F90      		pop __tmp_reg__
 3826 0fa4 0F90      		pop __tmp_reg__
 3827 0fa6 0F90      		pop __tmp_reg__
 3828 0fa8 0F90      		pop __tmp_reg__
 3829 0faa DF91      		pop r29
 3830 0fac CF91      		pop r28
 3831 0fae 1F91      		pop r17
 3832 0fb0 0F91      		pop r16
 3833 0fb2 FF90      		pop r15
 3834 0fb4 EF90      		pop r14
 3835 0fb6 BF90      		pop r11
 3836 0fb8 AF90      		pop r10
 3837 0fba 9F90      		pop r9
 3838 0fbc 8F90      		pop r8
 3839 0fbe 7F90      		pop r7
 3840 0fc0 6F90      		pop r6
 3841 0fc2 5F90      		pop r5
 3842 0fc4 4F90      		pop r4
 3843 0fc6 0895      		ret
 3844               	.L235:
4761:FreeRTOS/Source/tasks.c **** 			}
 3846               	.LM536:
 3847 0fc8 80E0      		ldi r24,0
 3848 0fca 00C0      		rjmp .L234
 3853               	.Lscope37:
 3861               	.global	xTaskGenericNotify
 3863               	xTaskGenericNotify:
4784:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3865               	.LM537:
 3866               	.LFBB38:
 3867 0fcc 0F93      		push r16
 3868 0fce 1F93      		push r17
 3869 0fd0 CF93      		push r28
 3870 0fd2 DF93      		push r29
 3871               	/* prologue: function */
 3872               	/* frame size = 0 */
 3873               	/* stack size = 4 */
 3874               	.L__stack_usage = 4
 3875 0fd4 EC01      		movw r28,r24
4792:FreeRTOS/Source/tasks.c **** 		{
 3877               	.LM538:
 3878               	/* #APP */
 3879               	 ;  4792 "FreeRTOS/Source/tasks.c" 1
 3880 0fd6 0FB6      		in		__tmp_reg__, __SREG__
 3881               	 ;  0 "" 2
 3882               	 ;  4792 "FreeRTOS/Source/tasks.c" 1
 3883 0fd8 F894      		cli
 3884               	 ;  0 "" 2
 3885               	 ;  4792 "FreeRTOS/Source/tasks.c" 1
 3886 0fda 0F92      		push	__tmp_reg__
 3887               	 ;  0 "" 2
4794:FreeRTOS/Source/tasks.c **** 			{
 3889               	.LM539:
 3890               	/* #NOAPP */
 3891 0fdc 0115      		cp r16,__zero_reg__
 3892 0fde 1105      		cpc r17,__zero_reg__
 3893 0fe0 01F0      		breq .L243
4796:FreeRTOS/Source/tasks.c **** 			}
 3895               	.LM540:
 3896 0fe2 8BA1      		ldd r24,Y+35
 3897 0fe4 9CA1      		ldd r25,Y+36
 3898 0fe6 ADA1      		ldd r26,Y+37
 3899 0fe8 BEA1      		ldd r27,Y+38
4796:FreeRTOS/Source/tasks.c **** 			}
 3901               	.LM541:
 3902 0fea F801      		movw r30,r16
 3903 0fec 8083      		st Z,r24
 3904 0fee 9183      		std Z+1,r25
 3905 0ff0 A283      		std Z+2,r26
 3906 0ff2 B383      		std Z+3,r27
 3907               	.L243:
4799:FreeRTOS/Source/tasks.c **** 
 3909               	.LM542:
 3910 0ff4 3FA1      		ldd r19,Y+39
4801:FreeRTOS/Source/tasks.c **** 
 3912               	.LM543:
 3913 0ff6 82E0      		ldi r24,lo8(2)
 3914 0ff8 8FA3      		std Y+39,r24
4803:FreeRTOS/Source/tasks.c **** 			{
 3916               	.LM544:
 3917 0ffa 2330      		cpi r18,lo8(3)
 3918 0ffc 01F0      		breq .L259
 3919 0ffe 00F4      		brsh .L245
 3920 1000 2130      		cpi r18,lo8(1)
 3921 1002 01F0      		breq .L246
 3922 1004 2230      		cpi r18,lo8(2)
 3923 1006 01F0      		breq .L247
 3924               	.L248:
4847:FreeRTOS/Source/tasks.c **** 			{
 3926               	.LM545:
 3927 1008 3130      		cpi r19,lo8(1)
 3928 100a 01F0      		breq .L251
 3929               	.L260:
 3930 100c 81E0      		ldi r24,lo8(1)
 3931               	.L250:
4887:FreeRTOS/Source/tasks.c **** 
 3933               	.LM546:
 3934               	/* #APP */
 3935               	 ;  4887 "FreeRTOS/Source/tasks.c" 1
 3936 100e 0F90      		pop		__tmp_reg__
 3937               	 ;  0 "" 2
 3938               	 ;  4887 "FreeRTOS/Source/tasks.c" 1
 3939 1010 0FBE      		out		__SREG__, __tmp_reg__
 3940               	 ;  0 "" 2
 3941               	/* #NOAPP */
 3942               	/* epilogue start */
4890:FreeRTOS/Source/tasks.c **** 
 3944               	.LM547:
 3945 1012 DF91      		pop r29
 3946 1014 CF91      		pop r28
 3947 1016 1F91      		pop r17
 3948 1018 0F91      		pop r16
 3949 101a 0895      		ret
 3950               	.L245:
4803:FreeRTOS/Source/tasks.c **** 			{
 3952               	.LM548:
 3953 101c 2430      		cpi r18,lo8(4)
 3954 101e 01F4      		brne .L248
4825:FreeRTOS/Source/tasks.c **** 					}
 3956               	.LM549:
 3957 1020 80E0      		ldi r24,0
4818:FreeRTOS/Source/tasks.c **** 					{
 3959               	.LM550:
 3960 1022 3230      		cpi r19,lo8(2)
 3961 1024 01F0      		breq .L250
 3962               	.L259:
4820:FreeRTOS/Source/tasks.c **** 					}
 3964               	.LM551:
 3965 1026 4BA3      		std Y+35,r20
 3966 1028 5CA3      		std Y+36,r21
 3967 102a 6DA3      		std Y+37,r22
 3968 102c 7EA3      		std Y+38,r23
 3969 102e 00C0      		rjmp .L248
 3970               	.L246:
4806:FreeRTOS/Source/tasks.c **** 					break;
 3972               	.LM552:
 3973 1030 8BA1      		ldd r24,Y+35
 3974 1032 9CA1      		ldd r25,Y+36
 3975 1034 ADA1      		ldd r26,Y+37
 3976 1036 BEA1      		ldd r27,Y+38
 3977 1038 842B      		or r24,r20
 3978 103a 952B      		or r25,r21
 3979 103c A62B      		or r26,r22
 3980 103e B72B      		or r27,r23
 3981               	.L258:
4810:FreeRTOS/Source/tasks.c **** 					break;
 3983               	.LM553:
 3984 1040 8BA3      		std Y+35,r24
 3985 1042 9CA3      		std Y+36,r25
 3986 1044 ADA3      		std Y+37,r26
 3987 1046 BEA3      		std Y+38,r27
4811:FreeRTOS/Source/tasks.c **** 
 3989               	.LM554:
 3990 1048 00C0      		rjmp .L248
 3991               	.L247:
4810:FreeRTOS/Source/tasks.c **** 					break;
 3993               	.LM555:
 3994 104a 8BA1      		ldd r24,Y+35
 3995 104c 9CA1      		ldd r25,Y+36
 3996 104e ADA1      		ldd r26,Y+37
 3997 1050 BEA1      		ldd r27,Y+38
4810:FreeRTOS/Source/tasks.c **** 					break;
 3999               	.LM556:
 4000 1052 0196      		adiw r24,1
 4001 1054 A11D      		adc r26,__zero_reg__
 4002 1056 B11D      		adc r27,__zero_reg__
 4003 1058 00C0      		rjmp .L258
 4004               	.L251:
4849:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 4006               	.LM557:
 4007 105a 8E01      		movw r16,r28
 4008 105c 0E5F      		subi r16,-2
 4009 105e 1F4F      		sbci r17,-1
 4010 1060 C801      		movw r24,r16
 4011 1062 0E94 0000 		call uxListRemove
4850:FreeRTOS/Source/tasks.c **** 
 4013               	.LM558:
 4014 1066 8E89      		ldd r24,Y+22
 4015 1068 9091 0000 		lds r25,uxTopReadyPriority
 4016 106c 9817      		cp r25,r24
 4017 106e 00F4      		brsh .L252
4850:FreeRTOS/Source/tasks.c **** 
 4019               	.LM559:
 4020 1070 8093 0000 		sts uxTopReadyPriority,r24
 4021               	.L252:
4850:FreeRTOS/Source/tasks.c **** 
 4023               	.LM560:
 4024 1074 F9E0      		ldi r31,lo8(9)
 4025 1076 8F9F      		mul r24,r31
 4026 1078 C001      		movw r24,r0
 4027 107a 1124      		clr __zero_reg__
 4028 107c B801      		movw r22,r16
 4029 107e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 4030 1080 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 4031 1082 0E94 0000 		call vListInsertEnd
4871:FreeRTOS/Source/tasks.c **** 				{
 4033               	.LM561:
 4034 1086 E091 0000 		lds r30,pxCurrentTCB
 4035 108a F091 0000 		lds r31,pxCurrentTCB+1
4871:FreeRTOS/Source/tasks.c **** 				{
 4037               	.LM562:
 4038 108e 9E89      		ldd r25,Y+22
 4039 1090 8689      		ldd r24,Z+22
 4040 1092 8917      		cp r24,r25
 4041 1094 00F0      		brlo .+2
 4042 1096 00C0      		rjmp .L260
4875:FreeRTOS/Source/tasks.c **** 				}
 4044               	.LM563:
 4045 1098 0E94 0000 		call vPortYield
 4046 109c 00C0      		rjmp .L260
 4052               	.Lscope38:
 4060               	.global	xTaskGenericNotifyFromISR
 4062               	xTaskGenericNotifyFromISR:
4898:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 4064               	.LM564:
 4065               	.LFBB39:
 4066 109e EF92      		push r14
 4067 10a0 FF92      		push r15
 4068 10a2 0F93      		push r16
 4069 10a4 1F93      		push r17
 4070 10a6 CF93      		push r28
 4071 10a8 DF93      		push r29
 4072               	/* prologue: function */
 4073               	/* frame size = 0 */
 4074               	/* stack size = 6 */
 4075               	.L__stack_usage = 6
 4076 10aa EC01      		movw r28,r24
4928:FreeRTOS/Source/tasks.c **** 			{
 4078               	.LM565:
 4079 10ac 0115      		cp r16,__zero_reg__
 4080 10ae 1105      		cpc r17,__zero_reg__
 4081 10b0 01F0      		breq .L262
4930:FreeRTOS/Source/tasks.c **** 			}
 4083               	.LM566:
 4084 10b2 8BA1      		ldd r24,Y+35
 4085 10b4 9CA1      		ldd r25,Y+36
 4086 10b6 ADA1      		ldd r26,Y+37
 4087 10b8 BEA1      		ldd r27,Y+38
4930:FreeRTOS/Source/tasks.c **** 			}
 4089               	.LM567:
 4090 10ba F801      		movw r30,r16
 4091 10bc 8083      		st Z,r24
 4092 10be 9183      		std Z+1,r25
 4093 10c0 A283      		std Z+2,r26
 4094 10c2 B383      		std Z+3,r27
 4095               	.L262:
4933:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4097               	.LM568:
 4098 10c4 3FA1      		ldd r19,Y+39
4934:FreeRTOS/Source/tasks.c **** 
 4100               	.LM569:
 4101 10c6 82E0      		ldi r24,lo8(2)
 4102 10c8 8FA3      		std Y+39,r24
4936:FreeRTOS/Source/tasks.c **** 			{
 4104               	.LM570:
 4105 10ca 2330      		cpi r18,lo8(3)
 4106 10cc 01F0      		breq .L284
 4107 10ce 00F4      		brsh .L264
 4108 10d0 2130      		cpi r18,lo8(1)
 4109 10d2 01F0      		breq .L265
 4110 10d4 2230      		cpi r18,lo8(2)
 4111 10d6 01F0      		breq .L266
 4112               	.L267:
4979:FreeRTOS/Source/tasks.c **** 			{
 4114               	.LM571:
 4115 10d8 3130      		cpi r19,lo8(1)
 4116 10da 01F0      		breq .L270
 4117               	.L274:
 4118 10dc 81E0      		ldi r24,lo8(1)
 4119               	.L261:
 4120               	/* epilogue start */
5019:FreeRTOS/Source/tasks.c **** 
 4122               	.LM572:
 4123 10de DF91      		pop r29
 4124 10e0 CF91      		pop r28
 4125 10e2 1F91      		pop r17
 4126 10e4 0F91      		pop r16
 4127 10e6 FF90      		pop r15
 4128 10e8 EF90      		pop r14
 4129 10ea 0895      		ret
 4130               	.L264:
4936:FreeRTOS/Source/tasks.c **** 			{
 4132               	.LM573:
 4133 10ec 2430      		cpi r18,lo8(4)
 4134 10ee 01F4      		brne .L267
4958:FreeRTOS/Source/tasks.c **** 					}
 4136               	.LM574:
 4137 10f0 80E0      		ldi r24,0
4951:FreeRTOS/Source/tasks.c **** 					{
 4139               	.LM575:
 4140 10f2 3230      		cpi r19,lo8(2)
 4141 10f4 01F0      		breq .L261
 4142               	.L284:
4953:FreeRTOS/Source/tasks.c **** 					}
 4144               	.LM576:
 4145 10f6 4BA3      		std Y+35,r20
 4146 10f8 5CA3      		std Y+36,r21
 4147 10fa 6DA3      		std Y+37,r22
 4148 10fc 7EA3      		std Y+38,r23
 4149 10fe 00C0      		rjmp .L267
 4150               	.L265:
4939:FreeRTOS/Source/tasks.c **** 					break;
 4152               	.LM577:
 4153 1100 8BA1      		ldd r24,Y+35
 4154 1102 9CA1      		ldd r25,Y+36
 4155 1104 ADA1      		ldd r26,Y+37
 4156 1106 BEA1      		ldd r27,Y+38
 4157 1108 842B      		or r24,r20
 4158 110a 952B      		or r25,r21
 4159 110c A62B      		or r26,r22
 4160 110e B72B      		or r27,r23
 4161               	.L283:
4943:FreeRTOS/Source/tasks.c **** 					break;
 4163               	.LM578:
 4164 1110 8BA3      		std Y+35,r24
 4165 1112 9CA3      		std Y+36,r25
 4166 1114 ADA3      		std Y+37,r26
 4167 1116 BEA3      		std Y+38,r27
4944:FreeRTOS/Source/tasks.c **** 
 4169               	.LM579:
 4170 1118 00C0      		rjmp .L267
 4171               	.L266:
4943:FreeRTOS/Source/tasks.c **** 					break;
 4173               	.LM580:
 4174 111a 8BA1      		ldd r24,Y+35
 4175 111c 9CA1      		ldd r25,Y+36
 4176 111e ADA1      		ldd r26,Y+37
 4177 1120 BEA1      		ldd r27,Y+38
4943:FreeRTOS/Source/tasks.c **** 					break;
 4179               	.LM581:
 4180 1122 0196      		adiw r24,1
 4181 1124 A11D      		adc r26,__zero_reg__
 4182 1126 B11D      		adc r27,__zero_reg__
 4183 1128 00C0      		rjmp .L283
 4184               	.L270:
4984:FreeRTOS/Source/tasks.c **** 				{
 4186               	.LM582:
 4187 112a 8091 0000 		lds r24,uxSchedulerSuspended
4984:FreeRTOS/Source/tasks.c **** 				{
 4189               	.LM583:
 4190 112e 8111      		cpse r24,__zero_reg__
 4191 1130 00C0      		rjmp .L271
4986:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4193               	.LM584:
 4194 1132 8E01      		movw r16,r28
 4195 1134 0E5F      		subi r16,-2
 4196 1136 1F4F      		sbci r17,-1
 4197 1138 C801      		movw r24,r16
 4198 113a 0E94 0000 		call uxListRemove
4987:FreeRTOS/Source/tasks.c **** 				}
 4200               	.LM585:
 4201 113e 8E89      		ldd r24,Y+22
 4202 1140 9091 0000 		lds r25,uxTopReadyPriority
 4203 1144 9817      		cp r25,r24
 4204 1146 00F4      		brsh .L272
4987:FreeRTOS/Source/tasks.c **** 				}
 4206               	.LM586:
 4207 1148 8093 0000 		sts uxTopReadyPriority,r24
 4208               	.L272:
4987:FreeRTOS/Source/tasks.c **** 				}
 4210               	.LM587:
 4211 114c F9E0      		ldi r31,lo8(9)
 4212 114e 8F9F      		mul r24,r31
 4213 1150 C001      		movw r24,r0
 4214 1152 1124      		clr __zero_reg__
 4215 1154 B801      		movw r22,r16
 4216 1156 8050      		subi r24,lo8(-(pxReadyTasksLists))
 4217 1158 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 4218               	.L285:
4993:FreeRTOS/Source/tasks.c **** 				}
 4220               	.LM588:
 4221 115a 0E94 0000 		call vListInsertEnd
4996:FreeRTOS/Source/tasks.c **** 				{
 4223               	.LM589:
 4224 115e E091 0000 		lds r30,pxCurrentTCB
 4225 1162 F091 0000 		lds r31,pxCurrentTCB+1
4996:FreeRTOS/Source/tasks.c **** 				{
 4227               	.LM590:
 4228 1166 9E89      		ldd r25,Y+22
 4229 1168 8689      		ldd r24,Z+22
 4230 116a 8917      		cp r24,r25
 4231 116c 00F0      		brlo .+2
 4232 116e 00C0      		rjmp .L274
5000:FreeRTOS/Source/tasks.c **** 					{
 4234               	.LM591:
 4235 1170 E114      		cp r14,__zero_reg__
 4236 1172 F104      		cpc r15,__zero_reg__
 4237 1174 01F0      		breq .L275
5002:FreeRTOS/Source/tasks.c **** 					}
 4239               	.LM592:
 4240 1176 81E0      		ldi r24,lo8(1)
 4241 1178 F701      		movw r30,r14
 4242 117a 8083      		st Z,r24
 4243               	.L275:
5008:FreeRTOS/Source/tasks.c **** 				}
 4245               	.LM593:
 4246 117c 81E0      		ldi r24,lo8(1)
 4247 117e 8093 0000 		sts xYieldPending,r24
 4248 1182 00C0      		rjmp .L261
 4249               	.L271:
4993:FreeRTOS/Source/tasks.c **** 				}
 4251               	.LM594:
 4252 1184 BE01      		movw r22,r28
 4253 1186 645F      		subi r22,-12
 4254 1188 7F4F      		sbci r23,-1
 4255 118a 80E0      		ldi r24,lo8(xPendingReadyList)
 4256 118c 90E0      		ldi r25,hi8(xPendingReadyList)
 4257 118e 00C0      		rjmp .L285
 4263               	.Lscope39:
 4268               	.global	vTaskNotifyGiveFromISR
 4270               	vTaskNotifyGiveFromISR:
5027:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 4272               	.LM595:
 4273               	.LFBB40:
 4274 1190 EF92      		push r14
 4275 1192 FF92      		push r15
 4276 1194 0F93      		push r16
 4277 1196 1F93      		push r17
 4278 1198 CF93      		push r28
 4279 119a DF93      		push r29
 4280               	/* prologue: function */
 4281               	/* frame size = 0 */
 4282               	/* stack size = 6 */
 4283               	.L__stack_usage = 6
 4284 119c 8C01      		movw r16,r24
 4285 119e 7B01      		movw r14,r22
5056:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4287               	.LM596:
 4288 11a0 DC01      		movw r26,r24
 4289 11a2 9796      		adiw r26,39
 4290 11a4 2C91      		ld r18,X
 4291 11a6 9797      		sbiw r26,39
5057:FreeRTOS/Source/tasks.c **** 
 4293               	.LM597:
 4294 11a8 82E0      		ldi r24,lo8(2)
 4295 11aa 9796      		adiw r26,39
 4296 11ac 8C93      		st X,r24
 4297 11ae 9797      		sbiw r26,39
5061:FreeRTOS/Source/tasks.c **** 
 4299               	.LM598:
 4300 11b0 9396      		adiw r26,35
 4301 11b2 8D91      		ld r24,X+
 4302 11b4 9D91      		ld r25,X+
 4303 11b6 0D90      		ld __tmp_reg__,X+
 4304 11b8 BC91      		ld r27,X
 4305 11ba A02D      		mov r26,__tmp_reg__
5061:FreeRTOS/Source/tasks.c **** 
 4307               	.LM599:
 4308 11bc 0196      		adiw r24,1
 4309 11be A11D      		adc r26,__zero_reg__
 4310 11c0 B11D      		adc r27,__zero_reg__
 4311 11c2 F801      		movw r30,r16
 4312 11c4 83A3      		std Z+35,r24
 4313 11c6 94A3      		std Z+36,r25
 4314 11c8 A5A3      		std Z+37,r26
 4315 11ca B6A3      		std Z+38,r27
5067:FreeRTOS/Source/tasks.c **** 			{
 4317               	.LM600:
 4318 11cc 2130      		cpi r18,lo8(1)
 4319 11ce 01F4      		brne .L286
5072:FreeRTOS/Source/tasks.c **** 				{
 4321               	.LM601:
 4322 11d0 8091 0000 		lds r24,uxSchedulerSuspended
5072:FreeRTOS/Source/tasks.c **** 				{
 4324               	.LM602:
 4325 11d4 8111      		cpse r24,__zero_reg__
 4326 11d6 00C0      		rjmp .L289
5074:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4328               	.LM603:
 4329 11d8 E801      		movw r28,r16
 4330 11da 2296      		adiw r28,2
 4331 11dc CE01      		movw r24,r28
 4332 11de 0E94 0000 		call uxListRemove
5075:FreeRTOS/Source/tasks.c **** 				}
 4334               	.LM604:
 4335 11e2 D801      		movw r26,r16
 4336 11e4 5696      		adiw r26,22
 4337 11e6 8C91      		ld r24,X
 4338 11e8 9091 0000 		lds r25,uxTopReadyPriority
 4339 11ec 9817      		cp r25,r24
 4340 11ee 00F4      		brsh .L290
5075:FreeRTOS/Source/tasks.c **** 				}
 4342               	.LM605:
 4343 11f0 8093 0000 		sts uxTopReadyPriority,r24
 4344               	.L290:
5075:FreeRTOS/Source/tasks.c **** 				}
 4346               	.LM606:
 4347 11f4 B9E0      		ldi r27,lo8(9)
 4348 11f6 8B9F      		mul r24,r27
 4349 11f8 C001      		movw r24,r0
 4350 11fa 1124      		clr __zero_reg__
 4351 11fc BE01      		movw r22,r28
 4352 11fe 8050      		subi r24,lo8(-(pxReadyTasksLists))
 4353 1200 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 4354               	.L297:
5081:FreeRTOS/Source/tasks.c **** 				}
 4356               	.LM607:
 4357 1202 0E94 0000 		call vListInsertEnd
5084:FreeRTOS/Source/tasks.c **** 				{
 4359               	.LM608:
 4360 1206 E091 0000 		lds r30,pxCurrentTCB
 4361 120a F091 0000 		lds r31,pxCurrentTCB+1
5084:FreeRTOS/Source/tasks.c **** 				{
 4363               	.LM609:
 4364 120e D801      		movw r26,r16
 4365 1210 5696      		adiw r26,22
 4366 1212 9C91      		ld r25,X
 4367 1214 8689      		ldd r24,Z+22
 4368 1216 8917      		cp r24,r25
 4369 1218 00F4      		brsh .L286
5088:FreeRTOS/Source/tasks.c **** 					{
 4371               	.LM610:
 4372 121a E114      		cp r14,__zero_reg__
 4373 121c F104      		cpc r15,__zero_reg__
 4374 121e 01F0      		breq .L293
5090:FreeRTOS/Source/tasks.c **** 					}
 4376               	.LM611:
 4377 1220 81E0      		ldi r24,lo8(1)
 4378 1222 F701      		movw r30,r14
 4379 1224 8083      		st Z,r24
 4380               	.L293:
5096:FreeRTOS/Source/tasks.c **** 				}
 4382               	.LM612:
 4383 1226 81E0      		ldi r24,lo8(1)
 4384 1228 8093 0000 		sts xYieldPending,r24
 4385               	.L286:
 4386               	/* epilogue start */
5105:FreeRTOS/Source/tasks.c **** 
 4388               	.LM613:
 4389 122c DF91      		pop r29
 4390 122e CF91      		pop r28
 4391 1230 1F91      		pop r17
 4392 1232 0F91      		pop r16
 4393 1234 FF90      		pop r15
 4394 1236 EF90      		pop r14
 4395 1238 0895      		ret
 4396               	.L289:
5081:FreeRTOS/Source/tasks.c **** 				}
 4398               	.LM614:
 4399 123a B801      		movw r22,r16
 4400 123c 645F      		subi r22,-12
 4401 123e 7F4F      		sbci r23,-1
 4402 1240 80E0      		ldi r24,lo8(xPendingReadyList)
 4403 1242 90E0      		ldi r25,hi8(xPendingReadyList)
 4404 1244 00C0      		rjmp .L297
 4409               	.Lscope40:
 4413               	.global	xTaskNotifyStateClear
 4415               	xTaskNotifyStateClear:
5113:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 4417               	.LM615:
 4418               	.LFBB41:
 4419               	/* prologue: function */
 4420               	/* frame size = 0 */
 4421               	/* stack size = 0 */
 4422               	.L__stack_usage = 0
 4423 1246 FC01      		movw r30,r24
5119:FreeRTOS/Source/tasks.c **** 
 4425               	.LM616:
 4426 1248 892B      		or r24,r25
 4427 124a 01F4      		brne .L299
5119:FreeRTOS/Source/tasks.c **** 
 4429               	.LM617:
 4430 124c E091 0000 		lds r30,pxCurrentTCB
 4431 1250 F091 0000 		lds r31,pxCurrentTCB+1
 4432               	.L299:
5121:FreeRTOS/Source/tasks.c **** 		{
 4434               	.LM618:
 4435               	/* #APP */
 4436               	 ;  5121 "FreeRTOS/Source/tasks.c" 1
 4437 1254 0FB6      		in		__tmp_reg__, __SREG__
 4438               	 ;  0 "" 2
 4439               	 ;  5121 "FreeRTOS/Source/tasks.c" 1
 4440 1256 F894      		cli
 4441               	 ;  0 "" 2
 4442               	 ;  5121 "FreeRTOS/Source/tasks.c" 1
 4443 1258 0F92      		push	__tmp_reg__
 4444               	 ;  0 "" 2
5123:FreeRTOS/Source/tasks.c **** 			{
 4446               	.LM619:
 4447               	/* #NOAPP */
 4448 125a 87A1      		ldd r24,Z+39
5123:FreeRTOS/Source/tasks.c **** 			{
 4450               	.LM620:
 4451 125c 8230      		cpi r24,lo8(2)
 4452 125e 01F4      		brne .L301
5125:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 4454               	.LM621:
 4455 1260 17A2      		std Z+39,__zero_reg__
5126:FreeRTOS/Source/tasks.c **** 			}
 4457               	.LM622:
 4458 1262 81E0      		ldi r24,lo8(1)
 4459               	.L300:
5133:FreeRTOS/Source/tasks.c **** 
 4461               	.LM623:
 4462               	/* #APP */
 4463               	 ;  5133 "FreeRTOS/Source/tasks.c" 1
 4464 1264 0F90      		pop		__tmp_reg__
 4465               	 ;  0 "" 2
 4466               	 ;  5133 "FreeRTOS/Source/tasks.c" 1
 4467 1266 0FBE      		out		__SREG__, __tmp_reg__
 4468               	 ;  0 "" 2
 4469               	/* #NOAPP */
 4470               	/* epilogue start */
5136:FreeRTOS/Source/tasks.c **** 
 4472               	.LM624:
 4473 1268 0895      		ret
 4474               	.L301:
5130:FreeRTOS/Source/tasks.c **** 			}
 4476               	.LM625:
 4477 126a 80E0      		ldi r24,0
 4478 126c 00C0      		rjmp .L300
 4483               	.Lscope41:
 4488               	.global	ulTaskNotifyValueClear
 4490               	ulTaskNotifyValueClear:
5144:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 4492               	.LM626:
 4493               	.LFBB42:
 4494 126e 0F93      		push r16
 4495 1270 1F93      		push r17
 4496 1272 CF93      		push r28
 4497 1274 DF93      		push r29
 4498 1276 00D0      		rcall .
 4499 1278 00D0      		rcall .
 4500 127a CDB7      		in r28,__SP_L__
 4501 127c DEB7      		in r29,__SP_H__
 4502               	/* prologue: function */
 4503               	/* frame size = 4 */
 4504               	/* stack size = 8 */
 4505               	.L__stack_usage = 8
 4506 127e FC01      		movw r30,r24
5150:FreeRTOS/Source/tasks.c **** 
 4508               	.LM627:
 4509 1280 892B      		or r24,r25
 4510 1282 01F4      		brne .L303
5150:FreeRTOS/Source/tasks.c **** 
 4512               	.LM628:
 4513 1284 E091 0000 		lds r30,pxCurrentTCB
 4514 1288 F091 0000 		lds r31,pxCurrentTCB+1
 4515               	.L303:
5152:FreeRTOS/Source/tasks.c **** 		{
 4517               	.LM629:
 4518               	/* #APP */
 4519               	 ;  5152 "FreeRTOS/Source/tasks.c" 1
 4520 128c 0FB6      		in		__tmp_reg__, __SREG__
 4521               	 ;  0 "" 2
 4522               	 ;  5152 "FreeRTOS/Source/tasks.c" 1
 4523 128e F894      		cli
 4524               	 ;  0 "" 2
 4525               	 ;  5152 "FreeRTOS/Source/tasks.c" 1
 4526 1290 0F92      		push	__tmp_reg__
 4527               	 ;  0 "" 2
5156:FreeRTOS/Source/tasks.c **** 			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 4529               	.LM630:
 4530               	/* #NOAPP */
 4531 1292 A091 0000 		lds r26,pxCurrentTCB
 4532 1296 B091 0000 		lds r27,pxCurrentTCB+1
5156:FreeRTOS/Source/tasks.c **** 			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 4534               	.LM631:
 4535 129a 9396      		adiw r26,35
 4536 129c 0D91      		ld r16,X+
 4537 129e 1D91      		ld r17,X+
 4538 12a0 2D91      		ld r18,X+
 4539 12a2 3C91      		ld r19,X
 4540 12a4 9697      		sbiw r26,35+3
 4541 12a6 0983      		std Y+1,r16
 4542 12a8 1A83      		std Y+2,r17
 4543 12aa 2B83      		std Y+3,r18
 4544 12ac 3C83      		std Y+4,r19
5157:FreeRTOS/Source/tasks.c **** 		}
 4546               	.LM632:
 4547 12ae 83A1      		ldd r24,Z+35
 4548 12b0 94A1      		ldd r25,Z+36
 4549 12b2 A5A1      		ldd r26,Z+37
 4550 12b4 B6A1      		ldd r27,Z+38
5157:FreeRTOS/Source/tasks.c **** 		}
 4552               	.LM633:
 4553 12b6 4095      		com r20
 4554 12b8 5095      		com r21
 4555 12ba 6095      		com r22
 4556 12bc 7095      		com r23
5157:FreeRTOS/Source/tasks.c **** 		}
 4558               	.LM634:
 4559 12be 8423      		and r24,r20
 4560 12c0 9523      		and r25,r21
 4561 12c2 A623      		and r26,r22
 4562 12c4 B723      		and r27,r23
 4563 12c6 83A3      		std Z+35,r24
 4564 12c8 94A3      		std Z+36,r25
 4565 12ca A5A3      		std Z+37,r26
 4566 12cc B6A3      		std Z+38,r27
5159:FreeRTOS/Source/tasks.c **** 
 4568               	.LM635:
 4569               	/* #APP */
 4570               	 ;  5159 "FreeRTOS/Source/tasks.c" 1
 4571 12ce 0F90      		pop		__tmp_reg__
 4572               	 ;  0 "" 2
 4573               	 ;  5159 "FreeRTOS/Source/tasks.c" 1
 4574 12d0 0FBE      		out		__SREG__, __tmp_reg__
 4575               	 ;  0 "" 2
5162:FreeRTOS/Source/tasks.c **** 
 4577               	.LM636:
 4578               	/* #NOAPP */
 4579 12d2 C901      		movw r24,r18
 4580 12d4 B801      		movw r22,r16
 4581               	/* epilogue start */
 4582 12d6 0F90      		pop __tmp_reg__
 4583 12d8 0F90      		pop __tmp_reg__
 4584 12da 0F90      		pop __tmp_reg__
 4585 12dc 0F90      		pop __tmp_reg__
 4586 12de DF91      		pop r29
 4587 12e0 CF91      		pop r28
 4588 12e2 1F91      		pop r17
 4589 12e4 0F91      		pop r16
 4590 12e6 0895      		ret
 4595               	.Lscope42:
 4597               		.local	uxSchedulerSuspended
 4598               		.comm	uxSchedulerSuspended,1,1
 4600               		.local	xIdleTaskHandle
 4601               		.comm	xIdleTaskHandle,2,1
 4603               		.local	xNextTaskUnblockTime
 4604               		.comm	xNextTaskUnblockTime,2,1
 4606               		.local	uxTaskNumber
 4607               		.comm	uxTaskNumber,1,1
 4609               		.local	xNumOfOverflows
 4610               		.comm	xNumOfOverflows,1,1
 4612               		.local	xYieldPending
 4613               		.comm	xYieldPending,1,1
 4615               		.local	xPendedTicks
 4616               		.comm	xPendedTicks,2,1
 4618               		.local	xSchedulerRunning
 4619               		.comm	xSchedulerRunning,1,1
 4621               		.local	uxTopReadyPriority
 4622               		.comm	uxTopReadyPriority,1,1
 4624               		.local	xTickCount
 4625               		.comm	xTickCount,2,1
 4627               		.local	uxCurrentNumberOfTasks
 4628               		.comm	uxCurrentNumberOfTasks,1,1
 4630               		.local	xSuspendedTaskList
 4631               		.comm	xSuspendedTaskList,9,1
 4633               		.local	uxDeletedTasksWaitingCleanUp
 4634               		.comm	uxDeletedTasksWaitingCleanUp,1,1
 4636               		.local	xTasksWaitingTermination
 4637               		.comm	xTasksWaitingTermination,9,1
 4639               		.local	xPendingReadyList
 4640               		.comm	xPendingReadyList,9,1
 4642               		.local	pxOverflowDelayedTaskList
 4643               		.comm	pxOverflowDelayedTaskList,2,1
 4645               		.local	pxDelayedTaskList
 4646               		.comm	pxDelayedTaskList,2,1
 4648               		.local	xDelayedTaskList2
 4649               		.comm	xDelayedTaskList2,9,1
 4651               		.local	xDelayedTaskList1
 4652               		.comm	xDelayedTaskList1,9,1
 4654               		.local	pxReadyTasksLists
 4655               		.comm	pxReadyTasksLists,36,1
 4657               	.global	pxCurrentTCB
 4658               		.section .bss
 4661               	pxCurrentTCB:
 4662 0000 0000      		.zero	2
 4664               		.text
 4666               	.Letext0:
 4667               		.ident	"GCC: (SUSE Linux) 10.0.1 20200218 (experimental) [revision fa1160f6e50500aa38162fefb43bfb1
 4668               	.global __do_copy_data
 4669               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccwvknYt.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccwvknYt.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccwvknYt.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccwvknYt.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccwvknYt.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccwvknYt.s:24     .text:0000000000000000 prvAddCurrentTaskToDelayedList
     /tmp/ccwvknYt.s:4622   .bss:000000000000000e xTickCount
     /tmp/ccwvknYt.s:4661   .bss:0000000000000000 pxCurrentTCB
     /tmp/ccwvknYt.s:4628   .bss:0000000000000011 xSuspendedTaskList
     /tmp/ccwvknYt.s:4640   .bss:000000000000002d pxOverflowDelayedTaskList
     /tmp/ccwvknYt.s:4643   .bss:000000000000002f pxDelayedTaskList
     /tmp/ccwvknYt.s:4601   .bss:0000000000000005 xNextTaskUnblockTime
     /tmp/ccwvknYt.s:158    .text:00000000000000b6 prvResetNextTaskUnblockTime
     /tmp/ccwvknYt.s:220    .text:00000000000000ec prvIdleTask
     /tmp/ccwvknYt.s:4631   .bss:000000000000001a uxDeletedTasksWaitingCleanUp
     /tmp/ccwvknYt.s:4652   .bss:0000000000000043 pxReadyTasksLists
     /tmp/ccwvknYt.s:4634   .bss:000000000000001b xTasksWaitingTermination
     /tmp/ccwvknYt.s:4625   .bss:0000000000000010 uxCurrentNumberOfTasks
     /tmp/ccwvknYt.s:355    .text:0000000000000148 xTaskCreate
     /tmp/ccwvknYt.s:4649   .bss:000000000000003a xDelayedTaskList1
     /tmp/ccwvknYt.s:4646   .bss:0000000000000031 xDelayedTaskList2
     /tmp/ccwvknYt.s:4637   .bss:0000000000000024 xPendingReadyList
     /tmp/ccwvknYt.s:4604   .bss:0000000000000007 uxTaskNumber
     /tmp/ccwvknYt.s:4619   .bss:000000000000000d uxTopReadyPriority
     /tmp/ccwvknYt.s:4616   .bss:000000000000000c xSchedulerRunning
     /tmp/ccwvknYt.s:780    .text:0000000000000350 vTaskDelete
     /tmp/ccwvknYt.s:929    .text:00000000000003fc vTaskResume
     /tmp/ccwvknYt.s:1072   .text:0000000000000496 xTaskResumeFromISR
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/ccwvknYt.s:1208   .text:000000000000052e vTaskStartScheduler
     /tmp/ccwvknYt.s:4598   .bss:0000000000000003 xIdleTaskHandle
     /tmp/ccwvknYt.s:1285   .text:0000000000000582 vTaskEndScheduler
     /tmp/ccwvknYt.s:1312   .text:000000000000058c vTaskSuspendAll
     /tmp/ccwvknYt.s:1335   .text:0000000000000598 xTaskGetTickCount
     /tmp/ccwvknYt.s:1383   .text:00000000000005ac xTaskGetTickCountFromISR
     /tmp/ccwvknYt.s:1408   .text:00000000000005b6 uxTaskGetNumberOfTasks
     /tmp/ccwvknYt.s:1430   .text:00000000000005bc pcTaskGetName
     /tmp/ccwvknYt.s:1458   .text:00000000000005cc xTaskIncrementTick
     /tmp/ccwvknYt.s:4607   .bss:0000000000000008 xNumOfOverflows
     /tmp/ccwvknYt.s:4610   .bss:0000000000000009 xYieldPending
     /tmp/ccwvknYt.s:4613   .bss:000000000000000a xPendedTicks
     /tmp/ccwvknYt.s:1732   .text:0000000000000724 xTaskResumeAll
     /tmp/ccwvknYt.s:1952   .text:0000000000000810 vTaskDelayUntil
     /tmp/ccwvknYt.s:2056   .text:0000000000000870 vTaskDelay
     /tmp/ccwvknYt.s:2106   .text:000000000000089a xTaskCatchUpTicks
     /tmp/ccwvknYt.s:2142   .text:00000000000008c0 vTaskSwitchContext
     /tmp/ccwvknYt.s:2255   .text:0000000000000944 vTaskSuspend
     /tmp/ccwvknYt.s:2434   .text:00000000000009f0 vTaskPlaceOnEventList
     /tmp/ccwvknYt.s:2475   .text:0000000000000a12 vTaskPlaceOnUnorderedEventList
     /tmp/ccwvknYt.s:2521   .text:0000000000000a42 xTaskRemoveFromEventList
     /tmp/ccwvknYt.s:2634   .text:0000000000000ac2 vTaskRemoveFromUnorderedEventList
     /tmp/ccwvknYt.s:2724   .text:0000000000000b2e vTaskSetTimeOutState
     /tmp/ccwvknYt.s:2777   .text:0000000000000b4e vTaskInternalSetTimeOutState
     /tmp/ccwvknYt.s:2808   .text:0000000000000b64 xTaskCheckForTimeOut
     /tmp/ccwvknYt.s:2937   .text:0000000000000bcc vTaskMissedYield
     /tmp/ccwvknYt.s:2959   .text:0000000000000bd4 xTaskGetCurrentTaskHandle
     /tmp/ccwvknYt.s:2985   .text:0000000000000bde xTaskPriorityInherit
     /tmp/ccwvknYt.s:3146   .text:0000000000000cb0 xTaskPriorityDisinherit
     /tmp/ccwvknYt.s:3250   .text:0000000000000d1c vTaskPriorityDisinheritAfterTimeout
     /tmp/ccwvknYt.s:3374   .text:0000000000000dae uxTaskResetEventItemValue
     /tmp/ccwvknYt.s:3417   .text:0000000000000ddc pvTaskIncrementMutexHeldCount
     /tmp/ccwvknYt.s:3459   .text:0000000000000e00 ulTaskNotifyTake
     /tmp/ccwvknYt.s:3625   .text:0000000000000ea6 xTaskNotifyWait
     /tmp/ccwvknYt.s:3863   .text:0000000000000fcc xTaskGenericNotify
     /tmp/ccwvknYt.s:4062   .text:000000000000109e xTaskGenericNotifyFromISR
     /tmp/ccwvknYt.s:4270   .text:0000000000001190 vTaskNotifyGiveFromISR
     /tmp/ccwvknYt.s:4415   .text:0000000000001246 xTaskNotifyStateClear
     /tmp/ccwvknYt.s:4490   .text:000000000000126e ulTaskNotifyValueClear

UNDEFINED SYMBOLS
uxListRemove
vListInsertEnd
vListInsert
vPortYield
vApplicationIdleHook
vPortFree
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
xPortStartScheduler
vPortEndScheduler
__do_copy_data
__do_clear_bss
