   1               		.file	"queue.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  32               	prvIsQueueEmpty:
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.3.1
   3:FreeRTOS/Source/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/queue.c ****  *
   5:FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/queue.c ****  *
  12:FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/queue.c ****  *
  15:FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/queue.c ****  *
  22:FreeRTOS/Source/queue.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/queue.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/queue.c ****  *
  25:FreeRTOS/Source/queue.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/queue.c ****  */
  27:FreeRTOS/Source/queue.c **** 
  28:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  29:FreeRTOS/Source/queue.c **** #include <string.h>
  30:FreeRTOS/Source/queue.c **** 
  31:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  34:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:FreeRTOS/Source/queue.c **** 
  36:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  37:FreeRTOS/Source/queue.c **** #include "task.h"
  38:FreeRTOS/Source/queue.c **** #include "queue.h"
  39:FreeRTOS/Source/queue.c **** 
  40:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  42:FreeRTOS/Source/queue.c **** #endif
  43:FreeRTOS/Source/queue.c **** 
  44:FreeRTOS/Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:FreeRTOS/Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:FreeRTOS/Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:FreeRTOS/Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:FreeRTOS/Source/queue.c **** 
  50:FreeRTOS/Source/queue.c **** 
  51:FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:FreeRTOS/Source/queue.c **** 
  55:FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:FreeRTOS/Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:FreeRTOS/Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:FreeRTOS/Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:FreeRTOS/Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:FreeRTOS/Source/queue.c **** being used for. */
  64:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  65:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:FreeRTOS/Source/queue.c **** 
  67:FreeRTOS/Source/queue.c **** typedef struct QueuePointers
  68:FreeRTOS/Source/queue.c **** {
  69:FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:FreeRTOS/Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:FreeRTOS/Source/queue.c **** } QueuePointers_t;
  72:FreeRTOS/Source/queue.c **** 
  73:FreeRTOS/Source/queue.c **** typedef struct SemaphoreData
  74:FreeRTOS/Source/queue.c **** {
  75:FreeRTOS/Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:FreeRTOS/Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:FreeRTOS/Source/queue.c **** } SemaphoreData_t;
  78:FreeRTOS/Source/queue.c **** 
  79:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:FreeRTOS/Source/queue.c **** zero. */
  81:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:FreeRTOS/Source/queue.c **** 
  84:FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
  87:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:FreeRTOS/Source/queue.c **** #else
  89:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:FreeRTOS/Source/queue.c **** #endif
  91:FreeRTOS/Source/queue.c **** 
  92:FreeRTOS/Source/queue.c **** /*
  93:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:FreeRTOS/Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:FreeRTOS/Source/queue.c ****  */
  97:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aw
  98:FreeRTOS/Source/queue.c **** {
  99:FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:FreeRTOS/Source/queue.c **** 
 102:FreeRTOS/Source/queue.c **** 	union
 103:FreeRTOS/Source/queue.c **** 	{
 104:FreeRTOS/Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:FreeRTOS/Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:FreeRTOS/Source/queue.c **** 	} u;
 107:FreeRTOS/Source/queue.c **** 
 108:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:FreeRTOS/Source/queue.c **** 
 111:FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:FreeRTOS/Source/queue.c **** 
 115:FreeRTOS/Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:FreeRTOS/Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:FreeRTOS/Source/queue.c **** 
 118:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:FreeRTOS/Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:FreeRTOS/Source/queue.c **** 	#endif
 121:FreeRTOS/Source/queue.c **** 
 122:FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:FreeRTOS/Source/queue.c **** 	#endif
 125:FreeRTOS/Source/queue.c **** 
 126:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 129:FreeRTOS/Source/queue.c **** 	#endif
 130:FreeRTOS/Source/queue.c **** 
 131:FreeRTOS/Source/queue.c **** } xQUEUE;
 132:FreeRTOS/Source/queue.c **** 
 133:FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 136:FreeRTOS/Source/queue.c **** 
 137:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 138:FreeRTOS/Source/queue.c **** 
 139:FreeRTOS/Source/queue.c **** /*
 140:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:FreeRTOS/Source/queue.c ****  */
 143:FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:FreeRTOS/Source/queue.c **** 
 145:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:FreeRTOS/Source/queue.c **** 	more user friendly. */
 148:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:FreeRTOS/Source/queue.c **** 	{
 150:FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 152:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 153:FreeRTOS/Source/queue.c **** 
 154:FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:FreeRTOS/Source/queue.c **** 	debuggers. */
 157:FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:FreeRTOS/Source/queue.c **** 
 159:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 162:FreeRTOS/Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:FreeRTOS/Source/queue.c **** 
 164:FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:FreeRTOS/Source/queue.c **** 
 166:FreeRTOS/Source/queue.c **** /*
 167:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:FreeRTOS/Source/queue.c ****  */
 174:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:FreeRTOS/Source/queue.c **** 
 176:FreeRTOS/Source/queue.c **** /*
 177:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:FreeRTOS/Source/queue.c ****  *
 179:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:FreeRTOS/Source/queue.c ****  */
 181:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:FreeRTOS/Source/queue.c **** 
 183:FreeRTOS/Source/queue.c **** /*
 184:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:FreeRTOS/Source/queue.c ****  *
 186:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:FreeRTOS/Source/queue.c ****  */
 188:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:FreeRTOS/Source/queue.c **** 
 190:FreeRTOS/Source/queue.c **** /*
 191:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:FreeRTOS/Source/queue.c ****  * back of the queue.
 193:FreeRTOS/Source/queue.c ****  */
 194:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:FreeRTOS/Source/queue.c **** 
 196:FreeRTOS/Source/queue.c **** /*
 197:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 198:FreeRTOS/Source/queue.c ****  */
 199:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:FreeRTOS/Source/queue.c **** 
 201:FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:FreeRTOS/Source/queue.c **** 	/*
 203:FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 205:FreeRTOS/Source/queue.c **** 	 */
 206:FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 207:FreeRTOS/Source/queue.c **** #endif
 208:FreeRTOS/Source/queue.c **** 
 209:FreeRTOS/Source/queue.c **** /*
 210:FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 212:FreeRTOS/Source/queue.c ****  */
 213:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:FreeRTOS/Source/queue.c **** 
 215:FreeRTOS/Source/queue.c **** /*
 216:FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:FreeRTOS/Source/queue.c ****  * as a mutex.
 219:FreeRTOS/Source/queue.c ****  */
 220:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:FreeRTOS/Source/queue.c **** #endif
 223:FreeRTOS/Source/queue.c **** 
 224:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:FreeRTOS/Source/queue.c **** 	/*
 226:FreeRTOS/Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:FreeRTOS/Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:FreeRTOS/Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:FreeRTOS/Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:FreeRTOS/Source/queue.c **** 	 * that priority.
 231:FreeRTOS/Source/queue.c **** 	 */
 232:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:FreeRTOS/Source/queue.c **** #endif
 234:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 235:FreeRTOS/Source/queue.c **** 
 236:FreeRTOS/Source/queue.c **** /*
 237:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 239:FreeRTOS/Source/queue.c ****  */
 240:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:FreeRTOS/Source/queue.c **** 	{														\
 243:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:FreeRTOS/Source/queue.c **** 		{													\
 245:FreeRTOS/Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:FreeRTOS/Source/queue.c **** 		}													\
 247:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:FreeRTOS/Source/queue.c **** 		{													\
 249:FreeRTOS/Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:FreeRTOS/Source/queue.c **** 		}													\
 251:FreeRTOS/Source/queue.c **** 	}														\
 252:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 253:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 254:FreeRTOS/Source/queue.c **** 
 255:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:FreeRTOS/Source/queue.c **** {
 257:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 258:FreeRTOS/Source/queue.c **** 
 259:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 260:FreeRTOS/Source/queue.c **** 
 261:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 262:FreeRTOS/Source/queue.c **** 	{
 263:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
 264:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 265:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 266:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 267:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 268:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 269:FreeRTOS/Source/queue.c **** 
 270:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 271:FreeRTOS/Source/queue.c **** 		{
 272:FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 277:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 278:FreeRTOS/Source/queue.c **** 			{
 279:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 280:FreeRTOS/Source/queue.c **** 				{
 281:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 282:FreeRTOS/Source/queue.c **** 				}
 283:FreeRTOS/Source/queue.c **** 				else
 284:FreeRTOS/Source/queue.c **** 				{
 285:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:FreeRTOS/Source/queue.c **** 				}
 287:FreeRTOS/Source/queue.c **** 			}
 288:FreeRTOS/Source/queue.c **** 			else
 289:FreeRTOS/Source/queue.c **** 			{
 290:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:FreeRTOS/Source/queue.c **** 			}
 292:FreeRTOS/Source/queue.c **** 		}
 293:FreeRTOS/Source/queue.c **** 		else
 294:FreeRTOS/Source/queue.c **** 		{
 295:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 297:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 298:FreeRTOS/Source/queue.c **** 		}
 299:FreeRTOS/Source/queue.c **** 	}
 300:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 301:FreeRTOS/Source/queue.c **** 
 302:FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:FreeRTOS/Source/queue.c **** 	versions. */
 304:FreeRTOS/Source/queue.c **** 	return pdPASS;
 305:FreeRTOS/Source/queue.c **** }
 306:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 307:FreeRTOS/Source/queue.c **** 
 308:FreeRTOS/Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:FreeRTOS/Source/queue.c **** 
 310:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:FreeRTOS/Source/queue.c **** 	{
 312:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 313:FreeRTOS/Source/queue.c **** 
 314:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:FreeRTOS/Source/queue.c **** 
 316:FreeRTOS/Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:FreeRTOS/Source/queue.c **** 		supplied. */
 318:FreeRTOS/Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:FreeRTOS/Source/queue.c **** 
 320:FreeRTOS/Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:FreeRTOS/Source/queue.c **** 		should not be provided if the item size is 0. */
 322:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:FreeRTOS/Source/queue.c **** 
 325:FreeRTOS/Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:FreeRTOS/Source/queue.c **** 		{
 327:FreeRTOS/Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:FreeRTOS/Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:FreeRTOS/Source/queue.c **** 			the real queue and semaphore structures. */
 330:FreeRTOS/Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:FreeRTOS/Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:FreeRTOS/Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:FreeRTOS/Source/queue.c **** 		}
 334:FreeRTOS/Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:FreeRTOS/Source/queue.c **** 
 336:FreeRTOS/Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:FreeRTOS/Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:FreeRTOS/Source/queue.c **** 		but is already set. */
 339:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:FreeRTOS/Source/queue.c **** 
 341:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 342:FreeRTOS/Source/queue.c **** 		{
 343:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:FreeRTOS/Source/queue.c **** 			{
 345:FreeRTOS/Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:FreeRTOS/Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:FreeRTOS/Source/queue.c **** 				later deleted. */
 348:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:FreeRTOS/Source/queue.c **** 			}
 350:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:FreeRTOS/Source/queue.c **** 
 352:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:FreeRTOS/Source/queue.c **** 		}
 354:FreeRTOS/Source/queue.c **** 		else
 355:FreeRTOS/Source/queue.c **** 		{
 356:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:FreeRTOS/Source/queue.c **** 		}
 359:FreeRTOS/Source/queue.c **** 
 360:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 361:FreeRTOS/Source/queue.c **** 	}
 362:FreeRTOS/Source/queue.c **** 
 363:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 365:FreeRTOS/Source/queue.c **** 
 366:FreeRTOS/Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:FreeRTOS/Source/queue.c **** 
 368:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:FreeRTOS/Source/queue.c **** 	{
 370:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 371:FreeRTOS/Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:FreeRTOS/Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:FreeRTOS/Source/queue.c **** 
 374:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:FreeRTOS/Source/queue.c **** 
 376:FreeRTOS/Source/queue.c **** 		/* Allocate enough space to hold the maximum number of items that
 377:FreeRTOS/Source/queue.c **** 		can be in the queue at any time.  It is valid for uxItemSize to be
 378:FreeRTOS/Source/queue.c **** 		zero in the case the queue is used as a semaphore. */
 379:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as th
 380:FreeRTOS/Source/queue.c **** 
 381:FreeRTOS/Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 382:FreeRTOS/Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 383:FreeRTOS/Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 384:FreeRTOS/Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 385:FreeRTOS/Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 386:FreeRTOS/Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 387:FreeRTOS/Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 388:FreeRTOS/Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 389:FreeRTOS/Source/queue.c **** 		two bytes). */
 390:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 391:FreeRTOS/Source/queue.c **** 
 392:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 393:FreeRTOS/Source/queue.c **** 		{
 394:FreeRTOS/Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 395:FreeRTOS/Source/queue.c **** 			storage area. */
 396:FreeRTOS/Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 397:FreeRTOS/Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 398:FreeRTOS/Source/queue.c **** 
 399:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 400:FreeRTOS/Source/queue.c **** 			{
 401:FreeRTOS/Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 402:FreeRTOS/Source/queue.c **** 				note this task was created dynamically in case it is later
 403:FreeRTOS/Source/queue.c **** 				deleted. */
 404:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 405:FreeRTOS/Source/queue.c **** 			}
 406:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 407:FreeRTOS/Source/queue.c **** 
 408:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 409:FreeRTOS/Source/queue.c **** 		}
 410:FreeRTOS/Source/queue.c **** 		else
 411:FreeRTOS/Source/queue.c **** 		{
 412:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 413:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 414:FreeRTOS/Source/queue.c **** 		}
 415:FreeRTOS/Source/queue.c **** 
 416:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 417:FreeRTOS/Source/queue.c **** 	}
 418:FreeRTOS/Source/queue.c **** 
 419:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 420:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 421:FreeRTOS/Source/queue.c **** 
 422:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 423:FreeRTOS/Source/queue.c **** {
 424:FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 425:FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 426:FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 427:FreeRTOS/Source/queue.c **** 
 428:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 429:FreeRTOS/Source/queue.c **** 	{
 430:FreeRTOS/Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 431:FreeRTOS/Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 432:FreeRTOS/Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 433:FreeRTOS/Source/queue.c **** 		value that is known to be within the memory map. */
 434:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 435:FreeRTOS/Source/queue.c **** 	}
 436:FreeRTOS/Source/queue.c **** 	else
 437:FreeRTOS/Source/queue.c **** 	{
 438:FreeRTOS/Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 439:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 440:FreeRTOS/Source/queue.c **** 	}
 441:FreeRTOS/Source/queue.c **** 
 442:FreeRTOS/Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 443:FreeRTOS/Source/queue.c **** 	defined. */
 444:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 445:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 446:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 447:FreeRTOS/Source/queue.c **** 
 448:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 449:FreeRTOS/Source/queue.c **** 	{
 450:FreeRTOS/Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 451:FreeRTOS/Source/queue.c **** 	}
 452:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 453:FreeRTOS/Source/queue.c **** 
 454:FreeRTOS/Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 455:FreeRTOS/Source/queue.c **** 	{
 456:FreeRTOS/Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 457:FreeRTOS/Source/queue.c **** 	}
 458:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 459:FreeRTOS/Source/queue.c **** 
 460:FreeRTOS/Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 461:FreeRTOS/Source/queue.c **** }
 462:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 463:FreeRTOS/Source/queue.c **** 
 464:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 465:FreeRTOS/Source/queue.c **** 
 466:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 467:FreeRTOS/Source/queue.c **** 	{
 468:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 469:FreeRTOS/Source/queue.c **** 		{
 470:FreeRTOS/Source/queue.c **** 			/* The queue create function will set all the queue structure members
 471:FreeRTOS/Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 472:FreeRTOS/Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 473:FreeRTOS/Source/queue.c **** 			in particular the information required for priority inheritance. */
 474:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 475:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 476:FreeRTOS/Source/queue.c **** 
 477:FreeRTOS/Source/queue.c **** 			/* In case this is a recursive mutex. */
 478:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 479:FreeRTOS/Source/queue.c **** 
 480:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 481:FreeRTOS/Source/queue.c **** 
 482:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 483:FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 484:FreeRTOS/Source/queue.c **** 		}
 485:FreeRTOS/Source/queue.c **** 		else
 486:FreeRTOS/Source/queue.c **** 		{
 487:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 488:FreeRTOS/Source/queue.c **** 		}
 489:FreeRTOS/Source/queue.c **** 	}
 490:FreeRTOS/Source/queue.c **** 
 491:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 492:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 493:FreeRTOS/Source/queue.c **** 
 494:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 495:FreeRTOS/Source/queue.c **** 
 496:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 497:FreeRTOS/Source/queue.c **** 	{
 498:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 499:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 500:FreeRTOS/Source/queue.c **** 
 501:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 502:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 503:FreeRTOS/Source/queue.c **** 
 504:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 505:FreeRTOS/Source/queue.c **** 	}
 506:FreeRTOS/Source/queue.c **** 
 507:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 508:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 509:FreeRTOS/Source/queue.c **** 
 510:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 511:FreeRTOS/Source/queue.c **** 
 512:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 513:FreeRTOS/Source/queue.c **** 	{
 514:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 515:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 516:FreeRTOS/Source/queue.c **** 
 517:FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 518:FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 519:FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 520:FreeRTOS/Source/queue.c **** 
 521:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 522:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 523:FreeRTOS/Source/queue.c **** 
 524:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 525:FreeRTOS/Source/queue.c **** 	}
 526:FreeRTOS/Source/queue.c **** 
 527:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 528:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 529:FreeRTOS/Source/queue.c **** 
 530:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 531:FreeRTOS/Source/queue.c **** 
 532:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 533:FreeRTOS/Source/queue.c **** 	{
 534:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 535:FreeRTOS/Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 536:FreeRTOS/Source/queue.c **** 
 537:FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 538:FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 539:FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 540:FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 541:FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 542:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 543:FreeRTOS/Source/queue.c **** 		{
 544:FreeRTOS/Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 545:FreeRTOS/Source/queue.c **** 			{
 546:FreeRTOS/Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 547:FreeRTOS/Source/queue.c **** 			}
 548:FreeRTOS/Source/queue.c **** 			else
 549:FreeRTOS/Source/queue.c **** 			{
 550:FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 551:FreeRTOS/Source/queue.c **** 			}
 552:FreeRTOS/Source/queue.c **** 		}
 553:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 554:FreeRTOS/Source/queue.c **** 
 555:FreeRTOS/Source/queue.c **** 		return pxReturn;
 556:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 557:FreeRTOS/Source/queue.c **** 
 558:FreeRTOS/Source/queue.c **** #endif
 559:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 560:FreeRTOS/Source/queue.c **** 
 561:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 562:FreeRTOS/Source/queue.c **** 
 563:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 564:FreeRTOS/Source/queue.c **** 	{
 565:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 566:FreeRTOS/Source/queue.c **** 
 567:FreeRTOS/Source/queue.c **** 		configASSERT( xSemaphore );
 568:FreeRTOS/Source/queue.c **** 
 569:FreeRTOS/Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 570:FreeRTOS/Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 571:FreeRTOS/Source/queue.c **** 		not required here. */
 572:FreeRTOS/Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 573:FreeRTOS/Source/queue.c **** 		{
 574:FreeRTOS/Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 575:FreeRTOS/Source/queue.c **** 		}
 576:FreeRTOS/Source/queue.c **** 		else
 577:FreeRTOS/Source/queue.c **** 		{
 578:FreeRTOS/Source/queue.c **** 			pxReturn = NULL;
 579:FreeRTOS/Source/queue.c **** 		}
 580:FreeRTOS/Source/queue.c **** 
 581:FreeRTOS/Source/queue.c **** 		return pxReturn;
 582:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 583:FreeRTOS/Source/queue.c **** 
 584:FreeRTOS/Source/queue.c **** #endif
 585:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 586:FreeRTOS/Source/queue.c **** 
 587:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 588:FreeRTOS/Source/queue.c **** 
 589:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 590:FreeRTOS/Source/queue.c **** 	{
 591:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 592:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 593:FreeRTOS/Source/queue.c **** 
 594:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 595:FreeRTOS/Source/queue.c **** 
 596:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 597:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 598:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 599:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 600:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 601:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 602:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 603:FreeRTOS/Source/queue.c **** 		{
 604:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 605:FreeRTOS/Source/queue.c **** 
 606:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 607:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 608:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 609:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 610:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 611:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 612:FreeRTOS/Source/queue.c **** 
 613:FreeRTOS/Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 614:FreeRTOS/Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 615:FreeRTOS/Source/queue.c **** 			{
 616:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 617:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 618:FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 619:FreeRTOS/Source/queue.c **** 			}
 620:FreeRTOS/Source/queue.c **** 			else
 621:FreeRTOS/Source/queue.c **** 			{
 622:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 623:FreeRTOS/Source/queue.c **** 			}
 624:FreeRTOS/Source/queue.c **** 
 625:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 626:FreeRTOS/Source/queue.c **** 		}
 627:FreeRTOS/Source/queue.c **** 		else
 628:FreeRTOS/Source/queue.c **** 		{
 629:FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 630:FreeRTOS/Source/queue.c **** 			holder. */
 631:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 632:FreeRTOS/Source/queue.c **** 
 633:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 634:FreeRTOS/Source/queue.c **** 		}
 635:FreeRTOS/Source/queue.c **** 
 636:FreeRTOS/Source/queue.c **** 		return xReturn;
 637:FreeRTOS/Source/queue.c **** 	}
 638:FreeRTOS/Source/queue.c **** 
 639:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 640:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 641:FreeRTOS/Source/queue.c **** 
 642:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 643:FreeRTOS/Source/queue.c **** 
 644:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 645:FreeRTOS/Source/queue.c **** 	{
 646:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 647:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 648:FreeRTOS/Source/queue.c **** 
 649:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 650:FreeRTOS/Source/queue.c **** 
 651:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 652:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 653:FreeRTOS/Source/queue.c **** 
 654:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 655:FreeRTOS/Source/queue.c **** 
 656:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 657:FreeRTOS/Source/queue.c **** 		{
 658:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 659:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 660:FreeRTOS/Source/queue.c **** 		}
 661:FreeRTOS/Source/queue.c **** 		else
 662:FreeRTOS/Source/queue.c **** 		{
 663:FreeRTOS/Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 664:FreeRTOS/Source/queue.c **** 
 665:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 666:FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 667:FreeRTOS/Source/queue.c **** 			before reaching here. */
 668:FreeRTOS/Source/queue.c **** 			if( xReturn != pdFAIL )
 669:FreeRTOS/Source/queue.c **** 			{
 670:FreeRTOS/Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 671:FreeRTOS/Source/queue.c **** 			}
 672:FreeRTOS/Source/queue.c **** 			else
 673:FreeRTOS/Source/queue.c **** 			{
 674:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 675:FreeRTOS/Source/queue.c **** 			}
 676:FreeRTOS/Source/queue.c **** 		}
 677:FreeRTOS/Source/queue.c **** 
 678:FreeRTOS/Source/queue.c **** 		return xReturn;
 679:FreeRTOS/Source/queue.c **** 	}
 680:FreeRTOS/Source/queue.c **** 
 681:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 682:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 683:FreeRTOS/Source/queue.c **** 
 684:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 685:FreeRTOS/Source/queue.c **** 
 686:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 687:FreeRTOS/Source/queue.c **** 	{
 688:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 689:FreeRTOS/Source/queue.c **** 
 690:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 691:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 692:FreeRTOS/Source/queue.c **** 
 693:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 694:FreeRTOS/Source/queue.c **** 
 695:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 696:FreeRTOS/Source/queue.c **** 		{
 697:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 698:FreeRTOS/Source/queue.c **** 
 699:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 700:FreeRTOS/Source/queue.c **** 		}
 701:FreeRTOS/Source/queue.c **** 		else
 702:FreeRTOS/Source/queue.c **** 		{
 703:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 704:FreeRTOS/Source/queue.c **** 		}
 705:FreeRTOS/Source/queue.c **** 
 706:FreeRTOS/Source/queue.c **** 		return xHandle;
 707:FreeRTOS/Source/queue.c **** 	}
 708:FreeRTOS/Source/queue.c **** 
 709:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 710:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 711:FreeRTOS/Source/queue.c **** 
 712:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 713:FreeRTOS/Source/queue.c **** 
 714:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 715:FreeRTOS/Source/queue.c **** 	{
 716:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 717:FreeRTOS/Source/queue.c **** 
 718:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 719:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 720:FreeRTOS/Source/queue.c **** 
 721:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 722:FreeRTOS/Source/queue.c **** 
 723:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 724:FreeRTOS/Source/queue.c **** 		{
 725:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 726:FreeRTOS/Source/queue.c **** 
 727:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 728:FreeRTOS/Source/queue.c **** 		}
 729:FreeRTOS/Source/queue.c **** 		else
 730:FreeRTOS/Source/queue.c **** 		{
 731:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 732:FreeRTOS/Source/queue.c **** 		}
 733:FreeRTOS/Source/queue.c **** 
 734:FreeRTOS/Source/queue.c **** 		return xHandle;
 735:FreeRTOS/Source/queue.c **** 	}
 736:FreeRTOS/Source/queue.c **** 
 737:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 738:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 739:FreeRTOS/Source/queue.c **** 
 740:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 741:FreeRTOS/Source/queue.c **** {
 742:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 743:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 744:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 745:FreeRTOS/Source/queue.c **** 
 746:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 747:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 748:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 749:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 750:FreeRTOS/Source/queue.c **** 	{
 751:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 752:FreeRTOS/Source/queue.c **** 	}
 753:FreeRTOS/Source/queue.c **** 	#endif
 754:FreeRTOS/Source/queue.c **** 
 755:FreeRTOS/Source/queue.c **** 
 756:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 757:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
 758:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
 759:FreeRTOS/Source/queue.c **** 	for( ;; )
 760:FreeRTOS/Source/queue.c **** 	{
 761:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 762:FreeRTOS/Source/queue.c **** 		{
 763:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 764:FreeRTOS/Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 765:FreeRTOS/Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 766:FreeRTOS/Source/queue.c **** 			queue is full. */
 767:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 768:FreeRTOS/Source/queue.c **** 			{
 769:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 770:FreeRTOS/Source/queue.c **** 
 771:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 772:FreeRTOS/Source/queue.c **** 				{
 773:FreeRTOS/Source/queue.c **** 				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 774:FreeRTOS/Source/queue.c **** 
 775:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 776:FreeRTOS/Source/queue.c **** 
 777:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 778:FreeRTOS/Source/queue.c **** 					{
 779:FreeRTOS/Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 780:FreeRTOS/Source/queue.c **** 						{
 781:FreeRTOS/Source/queue.c **** 							/* Do not notify the queue set as an existing item
 782:FreeRTOS/Source/queue.c **** 							was overwritten in the queue so the number of items
 783:FreeRTOS/Source/queue.c **** 							in the queue has not changed. */
 784:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 785:FreeRTOS/Source/queue.c **** 						}
 786:FreeRTOS/Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 787:FreeRTOS/Source/queue.c **** 						{
 788:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 789:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 790:FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 791:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 792:FreeRTOS/Source/queue.c **** 						}
 793:FreeRTOS/Source/queue.c **** 						else
 794:FreeRTOS/Source/queue.c **** 						{
 795:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 796:FreeRTOS/Source/queue.c **** 						}
 797:FreeRTOS/Source/queue.c **** 					}
 798:FreeRTOS/Source/queue.c **** 					else
 799:FreeRTOS/Source/queue.c **** 					{
 800:FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 801:FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 802:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 803:FreeRTOS/Source/queue.c **** 						{
 804:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805:FreeRTOS/Source/queue.c **** 							{
 806:FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 807:FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 808:FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 809:FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 810:FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 811:FreeRTOS/Source/queue.c **** 							}
 812:FreeRTOS/Source/queue.c **** 							else
 813:FreeRTOS/Source/queue.c **** 							{
 814:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 815:FreeRTOS/Source/queue.c **** 							}
 816:FreeRTOS/Source/queue.c **** 						}
 817:FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 818:FreeRTOS/Source/queue.c **** 						{
 819:FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 820:FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 821:FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 822:FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 823:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 824:FreeRTOS/Source/queue.c **** 						}
 825:FreeRTOS/Source/queue.c **** 						else
 826:FreeRTOS/Source/queue.c **** 						{
 827:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 828:FreeRTOS/Source/queue.c **** 						}
 829:FreeRTOS/Source/queue.c **** 					}
 830:FreeRTOS/Source/queue.c **** 				}
 831:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 832:FreeRTOS/Source/queue.c **** 				{
 833:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 834:FreeRTOS/Source/queue.c **** 
 835:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 836:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 837:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 838:FreeRTOS/Source/queue.c **** 					{
 839:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 840:FreeRTOS/Source/queue.c **** 						{
 841:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 842:FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 843:FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 844:FreeRTOS/Source/queue.c **** 							takes care of that. */
 845:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 846:FreeRTOS/Source/queue.c **** 						}
 847:FreeRTOS/Source/queue.c **** 						else
 848:FreeRTOS/Source/queue.c **** 						{
 849:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 850:FreeRTOS/Source/queue.c **** 						}
 851:FreeRTOS/Source/queue.c **** 					}
 852:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 853:FreeRTOS/Source/queue.c **** 					{
 854:FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 855:FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 856:FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 857:FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 858:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 859:FreeRTOS/Source/queue.c **** 					}
 860:FreeRTOS/Source/queue.c **** 					else
 861:FreeRTOS/Source/queue.c **** 					{
 862:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 863:FreeRTOS/Source/queue.c **** 					}
 864:FreeRTOS/Source/queue.c **** 				}
 865:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 866:FreeRTOS/Source/queue.c **** 
 867:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 868:FreeRTOS/Source/queue.c **** 				return pdPASS;
 869:FreeRTOS/Source/queue.c **** 			}
 870:FreeRTOS/Source/queue.c **** 			else
 871:FreeRTOS/Source/queue.c **** 			{
 872:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 873:FreeRTOS/Source/queue.c **** 				{
 874:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 875:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 876:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 877:FreeRTOS/Source/queue.c **** 
 878:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 879:FreeRTOS/Source/queue.c **** 					the function. */
 880:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 881:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 882:FreeRTOS/Source/queue.c **** 				}
 883:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 884:FreeRTOS/Source/queue.c **** 				{
 885:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 886:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 887:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 888:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 889:FreeRTOS/Source/queue.c **** 				}
 890:FreeRTOS/Source/queue.c **** 				else
 891:FreeRTOS/Source/queue.c **** 				{
 892:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 893:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 894:FreeRTOS/Source/queue.c **** 				}
 895:FreeRTOS/Source/queue.c **** 			}
 896:FreeRTOS/Source/queue.c **** 		}
 897:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 898:FreeRTOS/Source/queue.c **** 
 899:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 900:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 901:FreeRTOS/Source/queue.c **** 
 902:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 903:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 904:FreeRTOS/Source/queue.c **** 
 905:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 906:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 907:FreeRTOS/Source/queue.c **** 		{
 908:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 909:FreeRTOS/Source/queue.c **** 			{
 910:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 911:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 912:FreeRTOS/Source/queue.c **** 
 913:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 914:FreeRTOS/Source/queue.c **** 				event list.  It is possible that interrupts occurring now
 915:FreeRTOS/Source/queue.c **** 				remove this task from the event list again - but as the
 916:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 917:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 918:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 919:FreeRTOS/Source/queue.c **** 
 920:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 921:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 922:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 923:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 924:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 925:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 926:FreeRTOS/Source/queue.c **** 				{
 927:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 928:FreeRTOS/Source/queue.c **** 				}
 929:FreeRTOS/Source/queue.c **** 			}
 930:FreeRTOS/Source/queue.c **** 			else
 931:FreeRTOS/Source/queue.c **** 			{
 932:FreeRTOS/Source/queue.c **** 				/* Try again. */
 933:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 934:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 935:FreeRTOS/Source/queue.c **** 			}
 936:FreeRTOS/Source/queue.c **** 		}
 937:FreeRTOS/Source/queue.c **** 		else
 938:FreeRTOS/Source/queue.c **** 		{
 939:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 940:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 941:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 942:FreeRTOS/Source/queue.c **** 
 943:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 944:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 945:FreeRTOS/Source/queue.c **** 		}
 946:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
 947:FreeRTOS/Source/queue.c **** }
 948:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 949:FreeRTOS/Source/queue.c **** 
 950:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 951:FreeRTOS/Source/queue.c **** {
 952:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 953:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 954:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 955:FreeRTOS/Source/queue.c **** 
 956:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 957:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 958:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 959:FreeRTOS/Source/queue.c **** 
 960:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 961:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 962:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 963:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 964:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 965:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 966:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 967:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 968:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 969:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 970:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 971:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 972:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 973:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 974:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 975:FreeRTOS/Source/queue.c **** 
 976:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 977:FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 978:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 979:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 980:FreeRTOS/Source/queue.c **** 	post). */
 981:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 982:FreeRTOS/Source/queue.c **** 	{
 983:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 984:FreeRTOS/Source/queue.c **** 		{
 985:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 986:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 987:FreeRTOS/Source/queue.c **** 
 988:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 989:FreeRTOS/Source/queue.c **** 
 990:FreeRTOS/Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 991:FreeRTOS/Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 992:FreeRTOS/Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 993:FreeRTOS/Source/queue.c **** 			called here even though the disinherit function does not check if
 994:FreeRTOS/Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 995:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 996:FreeRTOS/Source/queue.c **** 
 997:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 998:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
 999:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1000:FreeRTOS/Source/queue.c **** 			{
1001:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1002:FreeRTOS/Source/queue.c **** 				{
1003:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1004:FreeRTOS/Source/queue.c **** 					{
1005:FreeRTOS/Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
1006:FreeRTOS/Source/queue.c **** 						{
1007:FreeRTOS/Source/queue.c **** 							/* Do not notify the queue set as an existing item
1008:FreeRTOS/Source/queue.c **** 							was overwritten in the queue so the number of items
1009:FreeRTOS/Source/queue.c **** 							in the queue has not changed. */
1010:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1011:FreeRTOS/Source/queue.c **** 						}
1012:FreeRTOS/Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1013:FreeRTOS/Source/queue.c **** 						{
1014:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1015:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1016:FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1017:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1018:FreeRTOS/Source/queue.c **** 							{
1019:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1020:FreeRTOS/Source/queue.c **** 							}
1021:FreeRTOS/Source/queue.c **** 							else
1022:FreeRTOS/Source/queue.c **** 							{
1023:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1024:FreeRTOS/Source/queue.c **** 							}
1025:FreeRTOS/Source/queue.c **** 						}
1026:FreeRTOS/Source/queue.c **** 						else
1027:FreeRTOS/Source/queue.c **** 						{
1028:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1029:FreeRTOS/Source/queue.c **** 						}
1030:FreeRTOS/Source/queue.c **** 					}
1031:FreeRTOS/Source/queue.c **** 					else
1032:FreeRTOS/Source/queue.c **** 					{
1033:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1034:FreeRTOS/Source/queue.c **** 						{
1035:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1036:FreeRTOS/Source/queue.c **** 							{
1037:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1038:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1039:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1040:FreeRTOS/Source/queue.c **** 								{
1041:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1042:FreeRTOS/Source/queue.c **** 								}
1043:FreeRTOS/Source/queue.c **** 								else
1044:FreeRTOS/Source/queue.c **** 								{
1045:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1046:FreeRTOS/Source/queue.c **** 								}
1047:FreeRTOS/Source/queue.c **** 							}
1048:FreeRTOS/Source/queue.c **** 							else
1049:FreeRTOS/Source/queue.c **** 							{
1050:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1051:FreeRTOS/Source/queue.c **** 							}
1052:FreeRTOS/Source/queue.c **** 						}
1053:FreeRTOS/Source/queue.c **** 						else
1054:FreeRTOS/Source/queue.c **** 						{
1055:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1056:FreeRTOS/Source/queue.c **** 						}
1057:FreeRTOS/Source/queue.c **** 					}
1058:FreeRTOS/Source/queue.c **** 				}
1059:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1060:FreeRTOS/Source/queue.c **** 				{
1061:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1062:FreeRTOS/Source/queue.c **** 					{
1063:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1064:FreeRTOS/Source/queue.c **** 						{
1065:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1066:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1067:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1068:FreeRTOS/Source/queue.c **** 							{
1069:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1070:FreeRTOS/Source/queue.c **** 							}
1071:FreeRTOS/Source/queue.c **** 							else
1072:FreeRTOS/Source/queue.c **** 							{
1073:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1074:FreeRTOS/Source/queue.c **** 							}
1075:FreeRTOS/Source/queue.c **** 						}
1076:FreeRTOS/Source/queue.c **** 						else
1077:FreeRTOS/Source/queue.c **** 						{
1078:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1079:FreeRTOS/Source/queue.c **** 						}
1080:FreeRTOS/Source/queue.c **** 					}
1081:FreeRTOS/Source/queue.c **** 					else
1082:FreeRTOS/Source/queue.c **** 					{
1083:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1084:FreeRTOS/Source/queue.c **** 					}
1085:FreeRTOS/Source/queue.c **** 					
1086:FreeRTOS/Source/queue.c **** 					/* Not used in this path. */
1087:FreeRTOS/Source/queue.c **** 					( void ) uxPreviousMessagesWaiting;
1088:FreeRTOS/Source/queue.c **** 				}
1089:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1090:FreeRTOS/Source/queue.c **** 			}
1091:FreeRTOS/Source/queue.c **** 			else
1092:FreeRTOS/Source/queue.c **** 			{
1093:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1094:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1095:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1096:FreeRTOS/Source/queue.c **** 			}
1097:FreeRTOS/Source/queue.c **** 
1098:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1099:FreeRTOS/Source/queue.c **** 		}
1100:FreeRTOS/Source/queue.c **** 		else
1101:FreeRTOS/Source/queue.c **** 		{
1102:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1103:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1104:FreeRTOS/Source/queue.c **** 		}
1105:FreeRTOS/Source/queue.c **** 	}
1106:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1107:FreeRTOS/Source/queue.c **** 
1108:FreeRTOS/Source/queue.c **** 	return xReturn;
1109:FreeRTOS/Source/queue.c **** }
1110:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1111:FreeRTOS/Source/queue.c **** 
1112:FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1113:FreeRTOS/Source/queue.c **** {
1114:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1115:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1116:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1117:FreeRTOS/Source/queue.c **** 
1118:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1119:FreeRTOS/Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1120:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1121:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1122:FreeRTOS/Source/queue.c **** 	post). */
1123:FreeRTOS/Source/queue.c **** 
1124:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1125:FreeRTOS/Source/queue.c **** 
1126:FreeRTOS/Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1127:FreeRTOS/Source/queue.c **** 	if the item size is not 0. */
1128:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1129:FreeRTOS/Source/queue.c **** 
1130:FreeRTOS/Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1131:FreeRTOS/Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1132:FreeRTOS/Source/queue.c **** 	interrupts, only tasks. */
1133:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1134:FreeRTOS/Source/queue.c **** 
1135:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1136:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1137:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1138:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1139:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1140:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1141:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1142:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1143:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1144:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1145:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1146:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1147:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1148:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1149:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1150:FreeRTOS/Source/queue.c **** 
1151:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1152:FreeRTOS/Source/queue.c **** 	{
1153:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1154:FreeRTOS/Source/queue.c **** 
1155:FreeRTOS/Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1156:FreeRTOS/Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1157:FreeRTOS/Source/queue.c **** 		space'. */
1158:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
1159:FreeRTOS/Source/queue.c **** 		{
1160:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
1161:FreeRTOS/Source/queue.c **** 
1162:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1163:FreeRTOS/Source/queue.c **** 
1164:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1165:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1166:FreeRTOS/Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1167:FreeRTOS/Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1168:FreeRTOS/Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1169:FreeRTOS/Source/queue.c **** 			messages (semaphores) available. */
1170:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1171:FreeRTOS/Source/queue.c **** 
1172:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1173:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1174:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
1175:FreeRTOS/Source/queue.c **** 			{
1176:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1177:FreeRTOS/Source/queue.c **** 				{
1178:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1179:FreeRTOS/Source/queue.c **** 					{
1180:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1181:FreeRTOS/Source/queue.c **** 						{
1182:FreeRTOS/Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1183:FreeRTOS/Source/queue.c **** 							posting	to the queue set caused a higher priority
1184:FreeRTOS/Source/queue.c **** 							task to	unblock.  A context switch is required. */
1185:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1186:FreeRTOS/Source/queue.c **** 							{
1187:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1188:FreeRTOS/Source/queue.c **** 							}
1189:FreeRTOS/Source/queue.c **** 							else
1190:FreeRTOS/Source/queue.c **** 							{
1191:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1192:FreeRTOS/Source/queue.c **** 							}
1193:FreeRTOS/Source/queue.c **** 						}
1194:FreeRTOS/Source/queue.c **** 						else
1195:FreeRTOS/Source/queue.c **** 						{
1196:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1197:FreeRTOS/Source/queue.c **** 						}
1198:FreeRTOS/Source/queue.c **** 					}
1199:FreeRTOS/Source/queue.c **** 					else
1200:FreeRTOS/Source/queue.c **** 					{
1201:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1202:FreeRTOS/Source/queue.c **** 						{
1203:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1204:FreeRTOS/Source/queue.c **** 							{
1205:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1206:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1207:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1208:FreeRTOS/Source/queue.c **** 								{
1209:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1210:FreeRTOS/Source/queue.c **** 								}
1211:FreeRTOS/Source/queue.c **** 								else
1212:FreeRTOS/Source/queue.c **** 								{
1213:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1214:FreeRTOS/Source/queue.c **** 								}
1215:FreeRTOS/Source/queue.c **** 							}
1216:FreeRTOS/Source/queue.c **** 							else
1217:FreeRTOS/Source/queue.c **** 							{
1218:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1219:FreeRTOS/Source/queue.c **** 							}
1220:FreeRTOS/Source/queue.c **** 						}
1221:FreeRTOS/Source/queue.c **** 						else
1222:FreeRTOS/Source/queue.c **** 						{
1223:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1224:FreeRTOS/Source/queue.c **** 						}
1225:FreeRTOS/Source/queue.c **** 					}
1226:FreeRTOS/Source/queue.c **** 				}
1227:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1228:FreeRTOS/Source/queue.c **** 				{
1229:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1230:FreeRTOS/Source/queue.c **** 					{
1231:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1232:FreeRTOS/Source/queue.c **** 						{
1233:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1234:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1235:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1236:FreeRTOS/Source/queue.c **** 							{
1237:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1238:FreeRTOS/Source/queue.c **** 							}
1239:FreeRTOS/Source/queue.c **** 							else
1240:FreeRTOS/Source/queue.c **** 							{
1241:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1242:FreeRTOS/Source/queue.c **** 							}
1243:FreeRTOS/Source/queue.c **** 						}
1244:FreeRTOS/Source/queue.c **** 						else
1245:FreeRTOS/Source/queue.c **** 						{
1246:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1247:FreeRTOS/Source/queue.c **** 						}
1248:FreeRTOS/Source/queue.c **** 					}
1249:FreeRTOS/Source/queue.c **** 					else
1250:FreeRTOS/Source/queue.c **** 					{
1251:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1252:FreeRTOS/Source/queue.c **** 					}
1253:FreeRTOS/Source/queue.c **** 				}
1254:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1255:FreeRTOS/Source/queue.c **** 			}
1256:FreeRTOS/Source/queue.c **** 			else
1257:FreeRTOS/Source/queue.c **** 			{
1258:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1259:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1260:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1261:FreeRTOS/Source/queue.c **** 			}
1262:FreeRTOS/Source/queue.c **** 
1263:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1264:FreeRTOS/Source/queue.c **** 		}
1265:FreeRTOS/Source/queue.c **** 		else
1266:FreeRTOS/Source/queue.c **** 		{
1267:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1268:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1269:FreeRTOS/Source/queue.c **** 		}
1270:FreeRTOS/Source/queue.c **** 	}
1271:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1272:FreeRTOS/Source/queue.c **** 
1273:FreeRTOS/Source/queue.c **** 	return xReturn;
1274:FreeRTOS/Source/queue.c **** }
1275:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1276:FreeRTOS/Source/queue.c **** 
1277:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1278:FreeRTOS/Source/queue.c **** {
1279:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1280:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1281:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1282:FreeRTOS/Source/queue.c **** 
1283:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1284:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1285:FreeRTOS/Source/queue.c **** 
1286:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1287:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1288:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1289:FreeRTOS/Source/queue.c **** 
1290:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1291:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1292:FreeRTOS/Source/queue.c **** 	{
1293:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1294:FreeRTOS/Source/queue.c **** 	}
1295:FreeRTOS/Source/queue.c **** 	#endif
1296:FreeRTOS/Source/queue.c **** 
1297:FreeRTOS/Source/queue.c **** 
1298:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1299:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1300:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1301:FreeRTOS/Source/queue.c **** 	for( ;; )
1302:FreeRTOS/Source/queue.c **** 	{
1303:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1304:FreeRTOS/Source/queue.c **** 		{
1305:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1306:FreeRTOS/Source/queue.c **** 
1307:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1308:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1309:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1310:FreeRTOS/Source/queue.c **** 			{
1311:FreeRTOS/Source/queue.c **** 				/* Data available, remove one item. */
1312:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1313:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1314:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1315:FreeRTOS/Source/queue.c **** 
1316:FreeRTOS/Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1317:FreeRTOS/Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1318:FreeRTOS/Source/queue.c **** 				task. */
1319:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1320:FreeRTOS/Source/queue.c **** 				{
1321:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1322:FreeRTOS/Source/queue.c **** 					{
1323:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1324:FreeRTOS/Source/queue.c **** 					}
1325:FreeRTOS/Source/queue.c **** 					else
1326:FreeRTOS/Source/queue.c **** 					{
1327:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1328:FreeRTOS/Source/queue.c **** 					}
1329:FreeRTOS/Source/queue.c **** 				}
1330:FreeRTOS/Source/queue.c **** 				else
1331:FreeRTOS/Source/queue.c **** 				{
1332:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1333:FreeRTOS/Source/queue.c **** 				}
1334:FreeRTOS/Source/queue.c **** 
1335:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1336:FreeRTOS/Source/queue.c **** 				return pdPASS;
1337:FreeRTOS/Source/queue.c **** 			}
1338:FreeRTOS/Source/queue.c **** 			else
1339:FreeRTOS/Source/queue.c **** 			{
1340:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1341:FreeRTOS/Source/queue.c **** 				{
1342:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1343:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1344:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1345:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1346:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1347:FreeRTOS/Source/queue.c **** 				}
1348:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1349:FreeRTOS/Source/queue.c **** 				{
1350:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1351:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1352:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1353:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1354:FreeRTOS/Source/queue.c **** 				}
1355:FreeRTOS/Source/queue.c **** 				else
1356:FreeRTOS/Source/queue.c **** 				{
1357:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1358:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1359:FreeRTOS/Source/queue.c **** 				}
1360:FreeRTOS/Source/queue.c **** 			}
1361:FreeRTOS/Source/queue.c **** 		}
1362:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1363:FreeRTOS/Source/queue.c **** 
1364:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1365:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1366:FreeRTOS/Source/queue.c **** 
1367:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1368:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1369:FreeRTOS/Source/queue.c **** 
1370:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1371:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1372:FreeRTOS/Source/queue.c **** 		{
1373:FreeRTOS/Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1374:FreeRTOS/Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1375:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1376:FreeRTOS/Source/queue.c **** 			{
1377:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1378:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1379:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1380:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1381:FreeRTOS/Source/queue.c **** 				{
1382:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1383:FreeRTOS/Source/queue.c **** 				}
1384:FreeRTOS/Source/queue.c **** 				else
1385:FreeRTOS/Source/queue.c **** 				{
1386:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1387:FreeRTOS/Source/queue.c **** 				}
1388:FreeRTOS/Source/queue.c **** 			}
1389:FreeRTOS/Source/queue.c **** 			else
1390:FreeRTOS/Source/queue.c **** 			{
1391:FreeRTOS/Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1392:FreeRTOS/Source/queue.c **** 				data. */
1393:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1394:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1395:FreeRTOS/Source/queue.c **** 			}
1396:FreeRTOS/Source/queue.c **** 		}
1397:FreeRTOS/Source/queue.c **** 		else
1398:FreeRTOS/Source/queue.c **** 		{
1399:FreeRTOS/Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1400:FreeRTOS/Source/queue.c **** 			back and attempt to read the data. */
1401:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1402:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1403:FreeRTOS/Source/queue.c **** 
1404:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1405:FreeRTOS/Source/queue.c **** 			{
1406:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1407:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1408:FreeRTOS/Source/queue.c **** 			}
1409:FreeRTOS/Source/queue.c **** 			else
1410:FreeRTOS/Source/queue.c **** 			{
1411:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1412:FreeRTOS/Source/queue.c **** 			}
1413:FreeRTOS/Source/queue.c **** 		}
1414:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1415:FreeRTOS/Source/queue.c **** }
1416:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1417:FreeRTOS/Source/queue.c **** 
1418:FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1419:FreeRTOS/Source/queue.c **** {
1420:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1421:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1422:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1423:FreeRTOS/Source/queue.c **** 
1424:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1425:FreeRTOS/Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
1426:FreeRTOS/Source/queue.c **** #endif
1427:FreeRTOS/Source/queue.c **** 
1428:FreeRTOS/Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1429:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1430:FreeRTOS/Source/queue.c **** 
1431:FreeRTOS/Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1432:FreeRTOS/Source/queue.c **** 	0. */
1433:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1434:FreeRTOS/Source/queue.c **** 
1435:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1436:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1437:FreeRTOS/Source/queue.c **** 	{
1438:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1439:FreeRTOS/Source/queue.c **** 	}
1440:FreeRTOS/Source/queue.c **** 	#endif
1441:FreeRTOS/Source/queue.c **** 
1442:FreeRTOS/Source/queue.c **** 
1443:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1444:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1445:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1446:FreeRTOS/Source/queue.c **** 	for( ;; )
1447:FreeRTOS/Source/queue.c **** 	{
1448:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1449:FreeRTOS/Source/queue.c **** 		{
1450:FreeRTOS/Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1451:FreeRTOS/Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1452:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1453:FreeRTOS/Source/queue.c **** 
1454:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1455:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1456:FreeRTOS/Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1457:FreeRTOS/Source/queue.c **** 			{
1458:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1459:FreeRTOS/Source/queue.c **** 
1460:FreeRTOS/Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1461:FreeRTOS/Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1462:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1463:FreeRTOS/Source/queue.c **** 
1464:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1465:FreeRTOS/Source/queue.c **** 				{
1466:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1467:FreeRTOS/Source/queue.c **** 					{
1468:FreeRTOS/Source/queue.c **** 						/* Record the information required to implement
1469:FreeRTOS/Source/queue.c **** 						priority inheritance should it become necessary. */
1470:FreeRTOS/Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1471:FreeRTOS/Source/queue.c **** 					}
1472:FreeRTOS/Source/queue.c **** 					else
1473:FreeRTOS/Source/queue.c **** 					{
1474:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1475:FreeRTOS/Source/queue.c **** 					}
1476:FreeRTOS/Source/queue.c **** 				}
1477:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1478:FreeRTOS/Source/queue.c **** 
1479:FreeRTOS/Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1480:FreeRTOS/Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1481:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1482:FreeRTOS/Source/queue.c **** 				{
1483:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1484:FreeRTOS/Source/queue.c **** 					{
1485:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1486:FreeRTOS/Source/queue.c **** 					}
1487:FreeRTOS/Source/queue.c **** 					else
1488:FreeRTOS/Source/queue.c **** 					{
1489:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1490:FreeRTOS/Source/queue.c **** 					}
1491:FreeRTOS/Source/queue.c **** 				}
1492:FreeRTOS/Source/queue.c **** 				else
1493:FreeRTOS/Source/queue.c **** 				{
1494:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1495:FreeRTOS/Source/queue.c **** 				}
1496:FreeRTOS/Source/queue.c **** 
1497:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1498:FreeRTOS/Source/queue.c **** 				return pdPASS;
1499:FreeRTOS/Source/queue.c **** 			}
1500:FreeRTOS/Source/queue.c **** 			else
1501:FreeRTOS/Source/queue.c **** 			{
1502:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1503:FreeRTOS/Source/queue.c **** 				{
1504:FreeRTOS/Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1505:FreeRTOS/Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1506:FreeRTOS/Source/queue.c **** 					if it were 0 the function would have exited. */
1507:FreeRTOS/Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1508:FreeRTOS/Source/queue.c **** 					{
1509:FreeRTOS/Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1510:FreeRTOS/Source/queue.c **** 					}
1511:FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1512:FreeRTOS/Source/queue.c **** 
1513:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1514:FreeRTOS/Source/queue.c **** 					(or the block time has expired) so exit now. */
1515:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1516:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1517:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1518:FreeRTOS/Source/queue.c **** 				}
1519:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1520:FreeRTOS/Source/queue.c **** 				{
1521:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1522:FreeRTOS/Source/queue.c **** 					so configure the timeout structure ready to block. */
1523:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1524:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1525:FreeRTOS/Source/queue.c **** 				}
1526:FreeRTOS/Source/queue.c **** 				else
1527:FreeRTOS/Source/queue.c **** 				{
1528:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1529:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1530:FreeRTOS/Source/queue.c **** 				}
1531:FreeRTOS/Source/queue.c **** 			}
1532:FreeRTOS/Source/queue.c **** 		}
1533:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1534:FreeRTOS/Source/queue.c **** 
1535:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1536:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1537:FreeRTOS/Source/queue.c **** 
1538:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1539:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1540:FreeRTOS/Source/queue.c **** 
1541:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1542:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1543:FreeRTOS/Source/queue.c **** 		{
1544:FreeRTOS/Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1545:FreeRTOS/Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1546:FreeRTOS/Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1547:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1548:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1549:FreeRTOS/Source/queue.c **** 			{
1550:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1551:FreeRTOS/Source/queue.c **** 
1552:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1553:FreeRTOS/Source/queue.c **** 				{
1554:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1555:FreeRTOS/Source/queue.c **** 					{
1556:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1557:FreeRTOS/Source/queue.c **** 						{
1558:FreeRTOS/Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
1559:FreeRTOS/Source/queue.c **** 						}
1560:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1561:FreeRTOS/Source/queue.c **** 					}
1562:FreeRTOS/Source/queue.c **** 					else
1563:FreeRTOS/Source/queue.c **** 					{
1564:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1565:FreeRTOS/Source/queue.c **** 					}
1566:FreeRTOS/Source/queue.c **** 				}
1567:FreeRTOS/Source/queue.c **** 				#endif
1568:FreeRTOS/Source/queue.c **** 
1569:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1570:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1571:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1572:FreeRTOS/Source/queue.c **** 				{
1573:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1574:FreeRTOS/Source/queue.c **** 				}
1575:FreeRTOS/Source/queue.c **** 				else
1576:FreeRTOS/Source/queue.c **** 				{
1577:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1578:FreeRTOS/Source/queue.c **** 				}
1579:FreeRTOS/Source/queue.c **** 			}
1580:FreeRTOS/Source/queue.c **** 			else
1581:FreeRTOS/Source/queue.c **** 			{
1582:FreeRTOS/Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1583:FreeRTOS/Source/queue.c **** 				attempt to take the semaphore again. */
1584:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1585:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1586:FreeRTOS/Source/queue.c **** 			}
1587:FreeRTOS/Source/queue.c **** 		}
1588:FreeRTOS/Source/queue.c **** 		else
1589:FreeRTOS/Source/queue.c **** 		{
1590:FreeRTOS/Source/queue.c **** 			/* Timed out. */
1591:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1592:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1593:FreeRTOS/Source/queue.c **** 
1594:FreeRTOS/Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1595:FreeRTOS/Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1596:FreeRTOS/Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1597:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1598:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1599:FreeRTOS/Source/queue.c **** 			{
1600:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1601:FreeRTOS/Source/queue.c **** 				{
1602:FreeRTOS/Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1603:FreeRTOS/Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1604:FreeRTOS/Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1605:FreeRTOS/Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
1606:FreeRTOS/Source/queue.c **** 					{
1607:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1608:FreeRTOS/Source/queue.c **** 						{
1609:FreeRTOS/Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1610:FreeRTOS/Source/queue.c **** 
1611:FreeRTOS/Source/queue.c **** 							/* This task blocking on the mutex caused another
1612:FreeRTOS/Source/queue.c **** 							task to inherit this task's priority.  Now this task
1613:FreeRTOS/Source/queue.c **** 							has timed out the priority should be disinherited
1614:FreeRTOS/Source/queue.c **** 							again, but only as low as the next highest priority
1615:FreeRTOS/Source/queue.c **** 							task that is waiting for the same mutex. */
1616:FreeRTOS/Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1617:FreeRTOS/Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
1618:FreeRTOS/Source/queue.c **** 						}
1619:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1620:FreeRTOS/Source/queue.c **** 					}
1621:FreeRTOS/Source/queue.c **** 				}
1622:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1623:FreeRTOS/Source/queue.c **** 
1624:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1625:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1626:FreeRTOS/Source/queue.c **** 			}
1627:FreeRTOS/Source/queue.c **** 			else
1628:FreeRTOS/Source/queue.c **** 			{
1629:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1630:FreeRTOS/Source/queue.c **** 			}
1631:FreeRTOS/Source/queue.c **** 		}
1632:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1633:FreeRTOS/Source/queue.c **** }
1634:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1635:FreeRTOS/Source/queue.c **** 
1636:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1637:FreeRTOS/Source/queue.c **** {
1638:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1639:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1640:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1641:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1642:FreeRTOS/Source/queue.c **** 
1643:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1644:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1645:FreeRTOS/Source/queue.c **** 
1646:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1647:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1648:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1649:FreeRTOS/Source/queue.c **** 
1650:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1651:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1652:FreeRTOS/Source/queue.c **** 	{
1653:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1654:FreeRTOS/Source/queue.c **** 	}
1655:FreeRTOS/Source/queue.c **** 	#endif
1656:FreeRTOS/Source/queue.c **** 
1657:FreeRTOS/Source/queue.c **** 
1658:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1659:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1660:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1661:FreeRTOS/Source/queue.c **** 	for( ;; )
1662:FreeRTOS/Source/queue.c **** 	{
1663:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1664:FreeRTOS/Source/queue.c **** 		{
1665:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1666:FreeRTOS/Source/queue.c **** 
1667:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1668:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1669:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1670:FreeRTOS/Source/queue.c **** 			{
1671:FreeRTOS/Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1672:FreeRTOS/Source/queue.c **** 				is read from the queue as this function is only peeking the
1673:FreeRTOS/Source/queue.c **** 				data, not removing it. */
1674:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1675:FreeRTOS/Source/queue.c **** 
1676:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1677:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1678:FreeRTOS/Source/queue.c **** 
1679:FreeRTOS/Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1680:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1681:FreeRTOS/Source/queue.c **** 
1682:FreeRTOS/Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1683:FreeRTOS/Source/queue.c **** 				any other tasks waiting for the data. */
1684:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1685:FreeRTOS/Source/queue.c **** 				{
1686:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1687:FreeRTOS/Source/queue.c **** 					{
1688:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1689:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
1690:FreeRTOS/Source/queue.c **** 					}
1691:FreeRTOS/Source/queue.c **** 					else
1692:FreeRTOS/Source/queue.c **** 					{
1693:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1694:FreeRTOS/Source/queue.c **** 					}
1695:FreeRTOS/Source/queue.c **** 				}
1696:FreeRTOS/Source/queue.c **** 				else
1697:FreeRTOS/Source/queue.c **** 				{
1698:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1699:FreeRTOS/Source/queue.c **** 				}
1700:FreeRTOS/Source/queue.c **** 
1701:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1702:FreeRTOS/Source/queue.c **** 				return pdPASS;
1703:FreeRTOS/Source/queue.c **** 			}
1704:FreeRTOS/Source/queue.c **** 			else
1705:FreeRTOS/Source/queue.c **** 			{
1706:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1707:FreeRTOS/Source/queue.c **** 				{
1708:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1709:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1710:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1711:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1712:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1713:FreeRTOS/Source/queue.c **** 				}
1714:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1715:FreeRTOS/Source/queue.c **** 				{
1716:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1717:FreeRTOS/Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1718:FreeRTOS/Source/queue.c **** 					state. */
1719:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
1720:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1721:FreeRTOS/Source/queue.c **** 				}
1722:FreeRTOS/Source/queue.c **** 				else
1723:FreeRTOS/Source/queue.c **** 				{
1724:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1725:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1726:FreeRTOS/Source/queue.c **** 				}
1727:FreeRTOS/Source/queue.c **** 			}
1728:FreeRTOS/Source/queue.c **** 		}
1729:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1730:FreeRTOS/Source/queue.c **** 
1731:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1732:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1733:FreeRTOS/Source/queue.c **** 
1734:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1735:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1736:FreeRTOS/Source/queue.c **** 
1737:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1738:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1739:FreeRTOS/Source/queue.c **** 		{
1740:FreeRTOS/Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1741:FreeRTOS/Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1742:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1743:FreeRTOS/Source/queue.c **** 			{
1744:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1745:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1746:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1747:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1748:FreeRTOS/Source/queue.c **** 				{
1749:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1750:FreeRTOS/Source/queue.c **** 				}
1751:FreeRTOS/Source/queue.c **** 				else
1752:FreeRTOS/Source/queue.c **** 				{
1753:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1754:FreeRTOS/Source/queue.c **** 				}
1755:FreeRTOS/Source/queue.c **** 			}
1756:FreeRTOS/Source/queue.c **** 			else
1757:FreeRTOS/Source/queue.c **** 			{
1758:FreeRTOS/Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1759:FreeRTOS/Source/queue.c **** 				state, instead return to try and obtain the data. */
1760:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1761:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1762:FreeRTOS/Source/queue.c **** 			}
1763:FreeRTOS/Source/queue.c **** 		}
1764:FreeRTOS/Source/queue.c **** 		else
1765:FreeRTOS/Source/queue.c **** 		{
1766:FreeRTOS/Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1767:FreeRTOS/Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
1768:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1769:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1770:FreeRTOS/Source/queue.c **** 
1771:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1772:FreeRTOS/Source/queue.c **** 			{
1773:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1774:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
1775:FreeRTOS/Source/queue.c **** 			}
1776:FreeRTOS/Source/queue.c **** 			else
1777:FreeRTOS/Source/queue.c **** 			{
1778:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1779:FreeRTOS/Source/queue.c **** 			}
1780:FreeRTOS/Source/queue.c **** 		}
1781:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1782:FreeRTOS/Source/queue.c **** }
1783:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1784:FreeRTOS/Source/queue.c **** 
1785:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1786:FreeRTOS/Source/queue.c **** {
1787:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1788:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1789:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1790:FreeRTOS/Source/queue.c **** 
1791:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1792:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1793:FreeRTOS/Source/queue.c **** 
1794:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1795:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1796:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1797:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1798:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1799:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1800:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1801:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1802:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1803:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1804:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1805:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1806:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1807:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1808:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1809:FreeRTOS/Source/queue.c **** 
1810:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1811:FreeRTOS/Source/queue.c **** 	{
1812:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1813:FreeRTOS/Source/queue.c **** 
1814:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1815:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1816:FreeRTOS/Source/queue.c **** 		{
1817:FreeRTOS/Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
1818:FreeRTOS/Source/queue.c **** 
1819:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1820:FreeRTOS/Source/queue.c **** 
1821:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1822:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1823:FreeRTOS/Source/queue.c **** 
1824:FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1825:FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1826:FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1827:FreeRTOS/Source/queue.c **** 			locked. */
1828:FreeRTOS/Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
1829:FreeRTOS/Source/queue.c **** 			{
1830:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1831:FreeRTOS/Source/queue.c **** 				{
1832:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1833:FreeRTOS/Source/queue.c **** 					{
1834:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1835:FreeRTOS/Source/queue.c **** 						force a context switch. */
1836:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1837:FreeRTOS/Source/queue.c **** 						{
1838:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1839:FreeRTOS/Source/queue.c **** 						}
1840:FreeRTOS/Source/queue.c **** 						else
1841:FreeRTOS/Source/queue.c **** 						{
1842:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:FreeRTOS/Source/queue.c **** 						}
1844:FreeRTOS/Source/queue.c **** 					}
1845:FreeRTOS/Source/queue.c **** 					else
1846:FreeRTOS/Source/queue.c **** 					{
1847:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/Source/queue.c **** 					}
1849:FreeRTOS/Source/queue.c **** 				}
1850:FreeRTOS/Source/queue.c **** 				else
1851:FreeRTOS/Source/queue.c **** 				{
1852:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1853:FreeRTOS/Source/queue.c **** 				}
1854:FreeRTOS/Source/queue.c **** 			}
1855:FreeRTOS/Source/queue.c **** 			else
1856:FreeRTOS/Source/queue.c **** 			{
1857:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1858:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1859:FreeRTOS/Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
1860:FreeRTOS/Source/queue.c **** 			}
1861:FreeRTOS/Source/queue.c **** 
1862:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1863:FreeRTOS/Source/queue.c **** 		}
1864:FreeRTOS/Source/queue.c **** 		else
1865:FreeRTOS/Source/queue.c **** 		{
1866:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1867:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1868:FreeRTOS/Source/queue.c **** 		}
1869:FreeRTOS/Source/queue.c **** 	}
1870:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1871:FreeRTOS/Source/queue.c **** 
1872:FreeRTOS/Source/queue.c **** 	return xReturn;
1873:FreeRTOS/Source/queue.c **** }
1874:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1875:FreeRTOS/Source/queue.c **** 
1876:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1877:FreeRTOS/Source/queue.c **** {
1878:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1879:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1880:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1881:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1882:FreeRTOS/Source/queue.c **** 
1883:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1884:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1885:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1886:FreeRTOS/Source/queue.c **** 
1887:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1888:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1889:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1890:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1891:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1892:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1893:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1894:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1895:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1896:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1897:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1898:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1899:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1900:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1901:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1902:FreeRTOS/Source/queue.c **** 
1903:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1904:FreeRTOS/Source/queue.c **** 	{
1905:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1906:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1907:FreeRTOS/Source/queue.c **** 		{
1908:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1909:FreeRTOS/Source/queue.c **** 
1910:FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1911:FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1912:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1913:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1914:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1915:FreeRTOS/Source/queue.c **** 
1916:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1917:FreeRTOS/Source/queue.c **** 		}
1918:FreeRTOS/Source/queue.c **** 		else
1919:FreeRTOS/Source/queue.c **** 		{
1920:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1921:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1922:FreeRTOS/Source/queue.c **** 		}
1923:FreeRTOS/Source/queue.c **** 	}
1924:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1925:FreeRTOS/Source/queue.c **** 
1926:FreeRTOS/Source/queue.c **** 	return xReturn;
1927:FreeRTOS/Source/queue.c **** }
1928:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1929:FreeRTOS/Source/queue.c **** 
1930:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1931:FreeRTOS/Source/queue.c **** {
1932:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1933:FreeRTOS/Source/queue.c **** 
1934:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1935:FreeRTOS/Source/queue.c **** 
1936:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1937:FreeRTOS/Source/queue.c **** 	{
1938:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1939:FreeRTOS/Source/queue.c **** 	}
1940:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1941:FreeRTOS/Source/queue.c **** 
1942:FreeRTOS/Source/queue.c **** 	return uxReturn;
1943:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1944:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1945:FreeRTOS/Source/queue.c **** 
1946:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1947:FreeRTOS/Source/queue.c **** {
1948:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1949:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1950:FreeRTOS/Source/queue.c **** 
1951:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1952:FreeRTOS/Source/queue.c **** 
1953:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1954:FreeRTOS/Source/queue.c **** 	{
1955:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1956:FreeRTOS/Source/queue.c **** 	}
1957:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1958:FreeRTOS/Source/queue.c **** 
1959:FreeRTOS/Source/queue.c **** 	return uxReturn;
1960:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1961:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1962:FreeRTOS/Source/queue.c **** 
1963:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1964:FreeRTOS/Source/queue.c **** {
1965:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1966:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1967:FreeRTOS/Source/queue.c **** 
1968:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1969:FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
1970:FreeRTOS/Source/queue.c **** 
1971:FreeRTOS/Source/queue.c **** 	return uxReturn;
1972:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1973:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1974:FreeRTOS/Source/queue.c **** 
1975:FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1976:FreeRTOS/Source/queue.c **** {
1977:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
1978:FreeRTOS/Source/queue.c **** 
1979:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1980:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1981:FreeRTOS/Source/queue.c **** 
1982:FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1983:FreeRTOS/Source/queue.c **** 	{
1984:FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1985:FreeRTOS/Source/queue.c **** 	}
1986:FreeRTOS/Source/queue.c **** 	#endif
1987:FreeRTOS/Source/queue.c **** 
1988:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1989:FreeRTOS/Source/queue.c **** 	{
1990:FreeRTOS/Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1991:FreeRTOS/Source/queue.c **** 		again. */
1992:FreeRTOS/Source/queue.c **** 		vPortFree( pxQueue );
1993:FreeRTOS/Source/queue.c **** 	}
1994:FreeRTOS/Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1995:FreeRTOS/Source/queue.c **** 	{
1996:FreeRTOS/Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1997:FreeRTOS/Source/queue.c **** 		check before attempting to free the memory. */
1998:FreeRTOS/Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1999:FreeRTOS/Source/queue.c **** 		{
2000:FreeRTOS/Source/queue.c **** 			vPortFree( pxQueue );
2001:FreeRTOS/Source/queue.c **** 		}
2002:FreeRTOS/Source/queue.c **** 		else
2003:FreeRTOS/Source/queue.c **** 		{
2004:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2005:FreeRTOS/Source/queue.c **** 		}
2006:FreeRTOS/Source/queue.c **** 	}
2007:FreeRTOS/Source/queue.c **** 	#else
2008:FreeRTOS/Source/queue.c **** 	{
2009:FreeRTOS/Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2010:FreeRTOS/Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2011:FreeRTOS/Source/queue.c **** 		( void ) pxQueue;
2012:FreeRTOS/Source/queue.c **** 	}
2013:FreeRTOS/Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2014:FreeRTOS/Source/queue.c **** }
2015:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2016:FreeRTOS/Source/queue.c **** 
2017:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2018:FreeRTOS/Source/queue.c **** 
2019:FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2020:FreeRTOS/Source/queue.c **** 	{
2021:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2022:FreeRTOS/Source/queue.c **** 	}
2023:FreeRTOS/Source/queue.c **** 
2024:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2025:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2026:FreeRTOS/Source/queue.c **** 
2027:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2028:FreeRTOS/Source/queue.c **** 
2029:FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2030:FreeRTOS/Source/queue.c **** 	{
2031:FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2032:FreeRTOS/Source/queue.c **** 	}
2033:FreeRTOS/Source/queue.c **** 
2034:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2035:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2036:FreeRTOS/Source/queue.c **** 
2037:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2038:FreeRTOS/Source/queue.c **** 
2039:FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2040:FreeRTOS/Source/queue.c **** 	{
2041:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2042:FreeRTOS/Source/queue.c **** 	}
2043:FreeRTOS/Source/queue.c **** 
2044:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2045:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2046:FreeRTOS/Source/queue.c **** 
2047:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2048:FreeRTOS/Source/queue.c **** 
2049:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2050:FreeRTOS/Source/queue.c **** 	{
2051:FreeRTOS/Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2052:FreeRTOS/Source/queue.c **** 
2053:FreeRTOS/Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2054:FreeRTOS/Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2055:FreeRTOS/Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2056:FreeRTOS/Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2057:FreeRTOS/Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2058:FreeRTOS/Source/queue.c **** 		mutex. */
2059:FreeRTOS/Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2060:FreeRTOS/Source/queue.c **** 		{
2061:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
2062:FreeRTOS/Source/queue.c **** 		}
2063:FreeRTOS/Source/queue.c **** 		else
2064:FreeRTOS/Source/queue.c **** 		{
2065:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2066:FreeRTOS/Source/queue.c **** 		}
2067:FreeRTOS/Source/queue.c **** 
2068:FreeRTOS/Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
2069:FreeRTOS/Source/queue.c **** 	}
2070:FreeRTOS/Source/queue.c **** 
2071:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2072:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2073:FreeRTOS/Source/queue.c **** 
2074:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2075:FreeRTOS/Source/queue.c **** {
2076:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
2077:FreeRTOS/Source/queue.c **** UBaseType_t uxMessagesWaiting;
2078:FreeRTOS/Source/queue.c **** 
2079:FreeRTOS/Source/queue.c **** 	/* This function is called from a critical section. */
2080:FreeRTOS/Source/queue.c **** 
2081:FreeRTOS/Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2082:FreeRTOS/Source/queue.c **** 
2083:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2084:FreeRTOS/Source/queue.c **** 	{
2085:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2086:FreeRTOS/Source/queue.c **** 		{
2087:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2088:FreeRTOS/Source/queue.c **** 			{
2089:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
2090:FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2091:FreeRTOS/Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
2092:FreeRTOS/Source/queue.c **** 			}
2093:FreeRTOS/Source/queue.c **** 			else
2094:FreeRTOS/Source/queue.c **** 			{
2095:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2096:FreeRTOS/Source/queue.c **** 			}
2097:FreeRTOS/Source/queue.c **** 		}
2098:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2099:FreeRTOS/Source/queue.c **** 	}
2100:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
2101:FreeRTOS/Source/queue.c **** 	{
2102:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
2103:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
2104:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
2105:FreeRTOS/Source/queue.c **** 		{
2106:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
2107:FreeRTOS/Source/queue.c **** 		}
2108:FreeRTOS/Source/queue.c **** 		else
2109:FreeRTOS/Source/queue.c **** 		{
2110:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2111:FreeRTOS/Source/queue.c **** 		}
2112:FreeRTOS/Source/queue.c **** 	}
2113:FreeRTOS/Source/queue.c **** 	else
2114:FreeRTOS/Source/queue.c **** 	{
2115:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
2116:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2117:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
2118:FreeRTOS/Source/queue.c **** 		{
2119:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2120:FreeRTOS/Source/queue.c **** 		}
2121:FreeRTOS/Source/queue.c **** 		else
2122:FreeRTOS/Source/queue.c **** 		{
2123:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2124:FreeRTOS/Source/queue.c **** 		}
2125:FreeRTOS/Source/queue.c **** 
2126:FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
2127:FreeRTOS/Source/queue.c **** 		{
2128:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2129:FreeRTOS/Source/queue.c **** 			{
2130:FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2131:FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
2132:FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
2133:FreeRTOS/Source/queue.c **** 				correct. */
2134:FreeRTOS/Source/queue.c **** 				--uxMessagesWaiting;
2135:FreeRTOS/Source/queue.c **** 			}
2136:FreeRTOS/Source/queue.c **** 			else
2137:FreeRTOS/Source/queue.c **** 			{
2138:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2139:FreeRTOS/Source/queue.c **** 			}
2140:FreeRTOS/Source/queue.c **** 		}
2141:FreeRTOS/Source/queue.c **** 		else
2142:FreeRTOS/Source/queue.c **** 		{
2143:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2144:FreeRTOS/Source/queue.c **** 		}
2145:FreeRTOS/Source/queue.c **** 	}
2146:FreeRTOS/Source/queue.c **** 
2147:FreeRTOS/Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2148:FreeRTOS/Source/queue.c **** 
2149:FreeRTOS/Source/queue.c **** 	return xReturn;
2150:FreeRTOS/Source/queue.c **** }
2151:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2152:FreeRTOS/Source/queue.c **** 
2153:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2154:FreeRTOS/Source/queue.c **** {
2155:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2156:FreeRTOS/Source/queue.c **** 	{
2157:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
2158:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
2159:FreeRTOS/Source/queue.c **** 		{
2160:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2161:FreeRTOS/Source/queue.c **** 		}
2162:FreeRTOS/Source/queue.c **** 		else
2163:FreeRTOS/Source/queue.c **** 		{
2164:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2165:FreeRTOS/Source/queue.c **** 		}
2166:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
2167:FreeRTOS/Source/queue.c **** 	}
2168:FreeRTOS/Source/queue.c **** }
2169:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2170:FreeRTOS/Source/queue.c **** 
2171:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2172:FreeRTOS/Source/queue.c **** {
2173:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2174:FreeRTOS/Source/queue.c **** 
2175:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2176:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2177:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2178:FreeRTOS/Source/queue.c **** 	updated. */
2179:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2180:FreeRTOS/Source/queue.c **** 	{
2181:FreeRTOS/Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
2182:FreeRTOS/Source/queue.c **** 
2183:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2184:FreeRTOS/Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
2185:FreeRTOS/Source/queue.c **** 		{
2186:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2187:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
2188:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2189:FreeRTOS/Source/queue.c **** 			{
2190:FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2191:FreeRTOS/Source/queue.c **** 				{
2192:FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2193:FreeRTOS/Source/queue.c **** 					{
2194:FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2195:FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2196:FreeRTOS/Source/queue.c **** 						A context switch is required. */
2197:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2198:FreeRTOS/Source/queue.c **** 					}
2199:FreeRTOS/Source/queue.c **** 					else
2200:FreeRTOS/Source/queue.c **** 					{
2201:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2202:FreeRTOS/Source/queue.c **** 					}
2203:FreeRTOS/Source/queue.c **** 				}
2204:FreeRTOS/Source/queue.c **** 				else
2205:FreeRTOS/Source/queue.c **** 				{
2206:FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get
2207:FreeRTOS/Source/queue.c **** 					added to the pending ready list as the scheduler is still
2208:FreeRTOS/Source/queue.c **** 					suspended. */
2209:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2210:FreeRTOS/Source/queue.c **** 					{
2211:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2212:FreeRTOS/Source/queue.c **** 						{
2213:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2214:FreeRTOS/Source/queue.c **** 							context	switch is required. */
2215:FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
2216:FreeRTOS/Source/queue.c **** 						}
2217:FreeRTOS/Source/queue.c **** 						else
2218:FreeRTOS/Source/queue.c **** 						{
2219:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2220:FreeRTOS/Source/queue.c **** 						}
2221:FreeRTOS/Source/queue.c **** 					}
2222:FreeRTOS/Source/queue.c **** 					else
2223:FreeRTOS/Source/queue.c **** 					{
2224:FreeRTOS/Source/queue.c **** 						break;
2225:FreeRTOS/Source/queue.c **** 					}
2226:FreeRTOS/Source/queue.c **** 				}
2227:FreeRTOS/Source/queue.c **** 			}
2228:FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2229:FreeRTOS/Source/queue.c **** 			{
2230:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2231:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2232:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2233:FreeRTOS/Source/queue.c **** 				{
2234:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2235:FreeRTOS/Source/queue.c **** 					{
2236:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that
2237:FreeRTOS/Source/queue.c **** 						a context switch is required. */
2238:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2239:FreeRTOS/Source/queue.c **** 					}
2240:FreeRTOS/Source/queue.c **** 					else
2241:FreeRTOS/Source/queue.c **** 					{
2242:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2243:FreeRTOS/Source/queue.c **** 					}
2244:FreeRTOS/Source/queue.c **** 				}
2245:FreeRTOS/Source/queue.c **** 				else
2246:FreeRTOS/Source/queue.c **** 				{
2247:FreeRTOS/Source/queue.c **** 					break;
2248:FreeRTOS/Source/queue.c **** 				}
2249:FreeRTOS/Source/queue.c **** 			}
2250:FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2251:FreeRTOS/Source/queue.c **** 
2252:FreeRTOS/Source/queue.c **** 			--cTxLock;
2253:FreeRTOS/Source/queue.c **** 		}
2254:FreeRTOS/Source/queue.c **** 
2255:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
2256:FreeRTOS/Source/queue.c **** 	}
2257:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2258:FreeRTOS/Source/queue.c **** 
2259:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
2260:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
2261:FreeRTOS/Source/queue.c **** 	{
2262:FreeRTOS/Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
2263:FreeRTOS/Source/queue.c **** 
2264:FreeRTOS/Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
2265:FreeRTOS/Source/queue.c **** 		{
2266:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2267:FreeRTOS/Source/queue.c **** 			{
2268:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2269:FreeRTOS/Source/queue.c **** 				{
2270:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
2271:FreeRTOS/Source/queue.c **** 				}
2272:FreeRTOS/Source/queue.c **** 				else
2273:FreeRTOS/Source/queue.c **** 				{
2274:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2275:FreeRTOS/Source/queue.c **** 				}
2276:FreeRTOS/Source/queue.c **** 
2277:FreeRTOS/Source/queue.c **** 				--cRxLock;
2278:FreeRTOS/Source/queue.c **** 			}
2279:FreeRTOS/Source/queue.c **** 			else
2280:FreeRTOS/Source/queue.c **** 			{
2281:FreeRTOS/Source/queue.c **** 				break;
2282:FreeRTOS/Source/queue.c **** 			}
2283:FreeRTOS/Source/queue.c **** 		}
2284:FreeRTOS/Source/queue.c **** 
2285:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
2286:FreeRTOS/Source/queue.c **** 	}
2287:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2288:FreeRTOS/Source/queue.c **** }
2289:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2290:FreeRTOS/Source/queue.c **** 
2291:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2292:FreeRTOS/Source/queue.c **** {
  34               	.LM0:
  35               	.LFBB1:
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
2293:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2294:FreeRTOS/Source/queue.c **** 
2295:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
  41               	.LM1:
  42               	/* #APP */
  43               	 ;  2295 "FreeRTOS/Source/queue.c" 1
  44 0000 0FB6      		in		__tmp_reg__, __SREG__
  45               	 ;  0 "" 2
  46               	 ;  2295 "FreeRTOS/Source/queue.c" 1
  47 0002 F894      		cli
  48               	 ;  0 "" 2
  49               	 ;  2295 "FreeRTOS/Source/queue.c" 1
  50 0004 0F92      		push	__tmp_reg__
  51               	 ;  0 "" 2
2296:FreeRTOS/Source/queue.c **** 	{
2297:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  53               	.LM2:
  54               	/* #NOAPP */
  55 0006 FC01      		movw r30,r24
  56 0008 928D      		ldd r25,Z+26
2298:FreeRTOS/Source/queue.c **** 		{
2299:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2300:FreeRTOS/Source/queue.c **** 		}
2301:FreeRTOS/Source/queue.c **** 		else
2302:FreeRTOS/Source/queue.c **** 		{
2303:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2304:FreeRTOS/Source/queue.c **** 		}
2305:FreeRTOS/Source/queue.c **** 	}
2306:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
  58               	.LM3:
  59               	/* #APP */
  60               	 ;  2306 "FreeRTOS/Source/queue.c" 1
  61 000a 0F90      		pop		__tmp_reg__
  62               	 ;  0 "" 2
  63               	 ;  2306 "FreeRTOS/Source/queue.c" 1
  64 000c 0FBE      		out		__SREG__, __tmp_reg__
  65               	 ;  0 "" 2
2297:FreeRTOS/Source/queue.c **** 		{
  67               	.LM4:
  68               	/* #NOAPP */
  69 000e 81E0      		ldi r24,lo8(1)
  70 0010 9111      		cpse r25,__zero_reg__
  71 0012 80E0      		ldi r24,0
  72               	.L2:
  73               	/* epilogue start */
2307:FreeRTOS/Source/queue.c **** 
2308:FreeRTOS/Source/queue.c **** 	return xReturn;
2309:FreeRTOS/Source/queue.c **** }
  75               	.LM5:
  76 0014 0895      		ret
  78               	.Lscope1:
  86               	prvCopyDataToQueue:
2075:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
  88               	.LM6:
  89               	.LFBB2:
  90 0016 0F93      		push r16
  91 0018 1F93      		push r17
  92 001a CF93      		push r28
  93 001c DF93      		push r29
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 4 */
  97               	.L__stack_usage = 4
  98 001e EC01      		movw r28,r24
  99 0020 042F      		mov r16,r20
2081:FreeRTOS/Source/queue.c **** 
 101               	.LM7:
 102 0022 1A8D      		ldd r17,Y+26
2083:FreeRTOS/Source/queue.c **** 	{
 104               	.LM8:
 105 0024 4C8D      		ldd r20,Y+28
2083:FreeRTOS/Source/queue.c **** 	{
 107               	.LM9:
 108 0026 4111      		cpse r20,__zero_reg__
 109 0028 00C0      		rjmp .L7
2087:FreeRTOS/Source/queue.c **** 			{
 111               	.LM10:
 112 002a 8881      		ld r24,Y
 113 002c 9981      		ldd r25,Y+1
 114 002e 892B      		or r24,r25
 115 0030 01F0      		breq .+2
 116 0032 00C0      		rjmp .L13
2090:FreeRTOS/Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 118               	.LM11:
 119 0034 8C81      		ldd r24,Y+4
 120 0036 9D81      		ldd r25,Y+5
 121 0038 0E94 0000 		call xTaskPriorityDisinherit
 122 003c 082F      		mov r16,r24
2091:FreeRTOS/Source/queue.c **** 			}
 124               	.LM12:
 125 003e 1D82      		std Y+5,__zero_reg__
 126 0040 1C82      		std Y+4,__zero_reg__
 127               	.L8:
2147:FreeRTOS/Source/queue.c **** 
 129               	.LM13:
 130 0042 81E0      		ldi r24,lo8(1)
 131 0044 810F      		add r24,r17
2147:FreeRTOS/Source/queue.c **** 
 133               	.LM14:
 134 0046 8A8F      		std Y+26,r24
2150:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 136               	.LM15:
 137 0048 802F      		mov r24,r16
 138               	/* epilogue start */
 139 004a DF91      		pop r29
 140 004c CF91      		pop r28
 141 004e 1F91      		pop r17
 142 0050 0F91      		pop r16
 143 0052 0895      		ret
 144               	.L7:
2102:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 146               	.LM16:
 147 0054 50E0      		ldi r21,0
2100:FreeRTOS/Source/queue.c **** 	{
 149               	.LM17:
 150 0056 0111      		cpse r16,__zero_reg__
 151 0058 00C0      		rjmp .L9
2102:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 153               	.LM18:
 154 005a 8A81      		ldd r24,Y+2
 155 005c 9B81      		ldd r25,Y+3
 156 005e 0E94 0000 		call memcpy
2103:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 158               	.LM19:
 159 0062 2C8D      		ldd r18,Y+28
2103:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 161               	.LM20:
 162 0064 8A81      		ldd r24,Y+2
 163 0066 9B81      		ldd r25,Y+3
 164 0068 820F      		add r24,r18
 165 006a 911D      		adc r25,__zero_reg__
 166 006c 9B83      		std Y+3,r25
 167 006e 8A83      		std Y+2,r24
2104:FreeRTOS/Source/queue.c **** 		{
 169               	.LM21:
 170 0070 2C81      		ldd r18,Y+4
 171 0072 3D81      		ldd r19,Y+5
 172 0074 8217      		cp r24,r18
 173 0076 9307      		cpc r25,r19
 174 0078 00F0      		brlo .L8
2106:FreeRTOS/Source/queue.c **** 		}
 176               	.LM22:
 177 007a 8881      		ld r24,Y
 178 007c 9981      		ldd r25,Y+1
 179 007e 9B83      		std Y+3,r25
 180 0080 8A83      		std Y+2,r24
 181 0082 00C0      		rjmp .L8
 182               	.L9:
2115:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 184               	.LM23:
 185 0084 8E81      		ldd r24,Y+6
 186 0086 9F81      		ldd r25,Y+7
 187 0088 0E94 0000 		call memcpy
2116:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 189               	.LM24:
 190 008c 2C8D      		ldd r18,Y+28
 191 008e 30E0      		ldi r19,0
2116:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 193               	.LM25:
 194 0090 4427      		clr r20
 195 0092 5527      		clr r21
 196 0094 421B      		sub r20,r18
 197 0096 530B      		sbc r21,r19
 198 0098 8E81      		ldd r24,Y+6
 199 009a 9F81      		ldd r25,Y+7
 200 009c 821B      		sub r24,r18
 201 009e 930B      		sbc r25,r19
 202 00a0 9F83      		std Y+7,r25
 203 00a2 8E83      		std Y+6,r24
2117:FreeRTOS/Source/queue.c **** 		{
 205               	.LM26:
 206 00a4 2881      		ld r18,Y
 207 00a6 3981      		ldd r19,Y+1
 208 00a8 8217      		cp r24,r18
 209 00aa 9307      		cpc r25,r19
 210 00ac 00F4      		brsh .L10
2119:FreeRTOS/Source/queue.c **** 		}
 212               	.LM27:
 213 00ae 8C81      		ldd r24,Y+4
 214 00b0 9D81      		ldd r25,Y+5
 215 00b2 840F      		add r24,r20
 216 00b4 951F      		adc r25,r21
2119:FreeRTOS/Source/queue.c **** 		}
 218               	.LM28:
 219 00b6 9F83      		std Y+7,r25
 220 00b8 8E83      		std Y+6,r24
 221               	.L10:
2126:FreeRTOS/Source/queue.c **** 		{
 223               	.LM29:
 224 00ba 0230      		cpi r16,lo8(2)
 225 00bc 01F4      		brne .L13
2128:FreeRTOS/Source/queue.c **** 			{
 227               	.LM30:
 228 00be 1111      		cpse r17,__zero_reg__
2134:FreeRTOS/Source/queue.c **** 			}
 230               	.LM31:
 231 00c0 1150      		subi r17,lo8(-(-1))
 232               	.L13:
2076:FreeRTOS/Source/queue.c **** UBaseType_t uxMessagesWaiting;
 234               	.LM32:
 235 00c2 00E0      		ldi r16,0
 236 00c4 00C0      		rjmp .L8
 242               	.Lscope2:
 248               	prvCopyDataFromQueue:
2154:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 250               	.LM33:
 251               	.LFBB3:
 252               	/* prologue: function */
 253               	/* frame size = 0 */
 254               	/* stack size = 0 */
 255               	.L__stack_usage = 0
 256 00c6 FC01      		movw r30,r24
 257 00c8 CB01      		movw r24,r22
2155:FreeRTOS/Source/queue.c **** 	{
 259               	.LM34:
 260 00ca 448D      		ldd r20,Z+28
2155:FreeRTOS/Source/queue.c **** 	{
 262               	.LM35:
 263 00cc 4423      		tst r20
 264 00ce 01F0      		breq .L14
2157:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 266               	.LM36:
 267 00d0 50E0      		ldi r21,0
2157:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 269               	.LM37:
 270 00d2 2681      		ldd r18,Z+6
 271 00d4 3781      		ldd r19,Z+7
 272 00d6 240F      		add r18,r20
 273 00d8 351F      		adc r19,r21
 274 00da 3783      		std Z+7,r19
 275 00dc 2683      		std Z+6,r18
2158:FreeRTOS/Source/queue.c **** 		{
 277               	.LM38:
 278 00de 6481      		ldd r22,Z+4
 279 00e0 7581      		ldd r23,Z+5
 280 00e2 2617      		cp r18,r22
 281 00e4 3707      		cpc r19,r23
 282 00e6 00F0      		brlo .L16
2160:FreeRTOS/Source/queue.c **** 		}
 284               	.LM39:
 285 00e8 2081      		ld r18,Z
 286 00ea 3181      		ldd r19,Z+1
 287 00ec 3783      		std Z+7,r19
 288 00ee 2683      		std Z+6,r18
 289               	.L16:
2166:FreeRTOS/Source/queue.c **** 	}
 291               	.LM40:
 292 00f0 6681      		ldd r22,Z+6
 293 00f2 7781      		ldd r23,Z+7
 294 00f4 0C94 0000 		jmp memcpy
 295               	.L14:
 296               	/* epilogue start */
2168:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 298               	.LM41:
 299 00f8 0895      		ret
 301               	.Lscope3:
 306               	prvUnlockQueue:
2172:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 308               	.LM42:
 309               	.LFBB4:
 310 00fa FF92      		push r15
 311 00fc 0F93      		push r16
 312 00fe 1F93      		push r17
 313 0100 CF93      		push r28
 314 0102 DF93      		push r29
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 5 */
 318               	.L__stack_usage = 5
 319 0104 8C01      		movw r16,r24
2179:FreeRTOS/Source/queue.c **** 	{
 321               	.LM43:
 322               	/* #APP */
 323               	 ;  2179 "FreeRTOS/Source/queue.c" 1
 324 0106 0FB6      		in		__tmp_reg__, __SREG__
 325               	 ;  0 "" 2
 326               	 ;  2179 "FreeRTOS/Source/queue.c" 1
 327 0108 F894      		cli
 328               	 ;  0 "" 2
 329               	 ;  2179 "FreeRTOS/Source/queue.c" 1
 330 010a 0F92      		push	__tmp_reg__
 331               	 ;  0 "" 2
 332               	/* #NOAPP */
 333               	.LBB2:
2181:FreeRTOS/Source/queue.c **** 
 335               	.LM44:
 336 010c FC01      		movw r30,r24
 337 010e F68C      		ldd r15,Z+30
2234:FreeRTOS/Source/queue.c **** 					{
 339               	.LM45:
 340 0110 EC01      		movw r28,r24
 341 0112 6196      		adiw r28,17
 342               	.L18:
2184:FreeRTOS/Source/queue.c **** 		{
 344               	.LM46:
 345 0114 1F14      		cp __zero_reg__,r15
 346 0116 04F0      		brlt .L21
 347               	.L19:
2255:FreeRTOS/Source/queue.c **** 	}
 349               	.LM47:
 350 0118 8FEF      		ldi r24,lo8(-1)
 351 011a F801      		movw r30,r16
 352 011c 868F      		std Z+30,r24
 353               	.LBE2:
2257:FreeRTOS/Source/queue.c **** 
 355               	.LM48:
 356               	/* #APP */
 357               	 ;  2257 "FreeRTOS/Source/queue.c" 1
 358 011e 0F90      		pop		__tmp_reg__
 359               	 ;  0 "" 2
 360               	 ;  2257 "FreeRTOS/Source/queue.c" 1
 361 0120 0FBE      		out		__SREG__, __tmp_reg__
 362               	 ;  0 "" 2
2260:FreeRTOS/Source/queue.c **** 	{
 364               	.LM49:
 365               	 ;  2260 "FreeRTOS/Source/queue.c" 1
 366 0122 0FB6      		in		__tmp_reg__, __SREG__
 367               	 ;  0 "" 2
 368               	 ;  2260 "FreeRTOS/Source/queue.c" 1
 369 0124 F894      		cli
 370               	 ;  0 "" 2
 371               	 ;  2260 "FreeRTOS/Source/queue.c" 1
 372 0126 0F92      		push	__tmp_reg__
 373               	 ;  0 "" 2
 374               	/* #NOAPP */
 375               	.LBB3:
2262:FreeRTOS/Source/queue.c **** 
 377               	.LM50:
 378 0128 F58C      		ldd r15,Z+29
2268:FreeRTOS/Source/queue.c **** 				{
 380               	.LM51:
 381 012a E801      		movw r28,r16
 382 012c 2896      		adiw r28,8
 383               	.L22:
2264:FreeRTOS/Source/queue.c **** 		{
 385               	.LM52:
 386 012e 1F14      		cp __zero_reg__,r15
 387 0130 04F0      		brlt .L25
 388               	.L23:
2285:FreeRTOS/Source/queue.c **** 	}
 390               	.LM53:
 391 0132 8FEF      		ldi r24,lo8(-1)
 392 0134 F801      		movw r30,r16
 393 0136 858F      		std Z+29,r24
 394               	.LBE3:
2287:FreeRTOS/Source/queue.c **** }
 396               	.LM54:
 397               	/* #APP */
 398               	 ;  2287 "FreeRTOS/Source/queue.c" 1
 399 0138 0F90      		pop		__tmp_reg__
 400               	 ;  0 "" 2
 401               	 ;  2287 "FreeRTOS/Source/queue.c" 1
 402 013a 0FBE      		out		__SREG__, __tmp_reg__
 403               	 ;  0 "" 2
 404               	/* #NOAPP */
 405               	/* epilogue start */
2288:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 407               	.LM55:
 408 013c DF91      		pop r29
 409 013e CF91      		pop r28
 410 0140 1F91      		pop r17
 411 0142 0F91      		pop r16
 412 0144 FF90      		pop r15
 413 0146 0895      		ret
 414               	.L21:
 415               	.LBB4:
2232:FreeRTOS/Source/queue.c **** 				{
 417               	.LM56:
 418 0148 F801      		movw r30,r16
 419 014a 8189      		ldd r24,Z+17
2232:FreeRTOS/Source/queue.c **** 				{
 421               	.LM57:
 422 014c 8823      		tst r24
 423 014e 01F0      		breq .L19
2234:FreeRTOS/Source/queue.c **** 					{
 425               	.LM58:
 426 0150 CE01      		movw r24,r28
 427 0152 0E94 0000 		call xTaskRemoveFromEventList
2234:FreeRTOS/Source/queue.c **** 					{
 429               	.LM59:
 430 0156 8111      		cpse r24,__zero_reg__
2238:FreeRTOS/Source/queue.c **** 					}
 432               	.LM60:
 433 0158 0E94 0000 		call vTaskMissedYield
 434               	.L20:
 435 015c FA94      		dec r15
 436 015e 00C0      		rjmp .L18
 437               	.L25:
 438               	.LBE4:
 439               	.LBB5:
2266:FreeRTOS/Source/queue.c **** 			{
 441               	.LM61:
 442 0160 F801      		movw r30,r16
 443 0162 8085      		ldd r24,Z+8
2266:FreeRTOS/Source/queue.c **** 			{
 445               	.LM62:
 446 0164 8823      		tst r24
 447 0166 01F0      		breq .L23
2268:FreeRTOS/Source/queue.c **** 				{
 449               	.LM63:
 450 0168 CE01      		movw r24,r28
 451 016a 0E94 0000 		call xTaskRemoveFromEventList
2268:FreeRTOS/Source/queue.c **** 				{
 453               	.LM64:
 454 016e 8111      		cpse r24,__zero_reg__
2270:FreeRTOS/Source/queue.c **** 				}
 456               	.LM65:
 457 0170 0E94 0000 		call vTaskMissedYield
 458               	.L24:
 459 0174 FA94      		dec r15
 460 0176 00C0      		rjmp .L22
 461               	.LBE5:
 475               	.Lscope4:
 481               	.global	xQueueGenericReset
 483               	xQueueGenericReset:
 256:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 485               	.LM66:
 486               	.LFBB5:
 487 0178 CF93      		push r28
 488 017a DF93      		push r29
 489               	/* prologue: function */
 490               	/* frame size = 0 */
 491               	/* stack size = 2 */
 492               	.L__stack_usage = 2
 493 017c EC01      		movw r28,r24
 261:FreeRTOS/Source/queue.c **** 	{
 495               	.LM67:
 496               	/* #APP */
 497               	 ;  261 "FreeRTOS/Source/queue.c" 1
 498 017e 0FB6      		in		__tmp_reg__, __SREG__
 499               	 ;  0 "" 2
 500               	 ;  261 "FreeRTOS/Source/queue.c" 1
 501 0180 F894      		cli
 502               	 ;  0 "" 2
 503               	 ;  261 "FreeRTOS/Source/queue.c" 1
 504 0182 0F92      		push	__tmp_reg__
 505               	 ;  0 "" 2
 263:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 507               	.LM68:
 508               	/* #NOAPP */
 509 0184 8881      		ld r24,Y
 510 0186 9981      		ldd r25,Y+1
 263:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 512               	.LM69:
 513 0188 2B8D      		ldd r18,Y+27
 263:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 515               	.LM70:
 516 018a 4C8D      		ldd r20,Y+28
 263:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 518               	.LM71:
 519 018c FC01      		movw r30,r24
 520 018e 249F      		mul r18,r20
 521 0190 E00D      		add r30,r0
 522 0192 F11D      		adc r31,r1
 523 0194 1124      		clr __zero_reg__
 263:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 525               	.LM72:
 526 0196 FD83      		std Y+5,r31
 527 0198 EC83      		std Y+4,r30
 264:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 529               	.LM73:
 530 019a 1A8E      		std Y+26,__zero_reg__
 265:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
 532               	.LM74:
 533 019c 9B83      		std Y+3,r25
 534 019e 8A83      		std Y+2,r24
 266:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 536               	.LM75:
 537 01a0 2150      		subi r18,1
 538 01a2 330B      		sbc r19,r19
 266:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 540               	.LM76:
 541 01a4 429F      		mul r20,r18
 542 01a6 F001      		movw r30,r0
 543 01a8 439F      		mul r20,r19
 544 01aa F00D      		add r31,r0
 545 01ac 1124      		clr __zero_reg__
 266:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 547               	.LM77:
 548 01ae 8E0F      		add r24,r30
 549 01b0 9F1F      		adc r25,r31
 266:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 551               	.LM78:
 552 01b2 9F83      		std Y+7,r25
 553 01b4 8E83      		std Y+6,r24
 267:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 555               	.LM79:
 556 01b6 8FEF      		ldi r24,lo8(-1)
 557 01b8 8D8F      		std Y+29,r24
 268:FreeRTOS/Source/queue.c **** 
 559               	.LM80:
 560 01ba 8E8F      		std Y+30,r24
 270:FreeRTOS/Source/queue.c **** 		{
 562               	.LM81:
 563 01bc 6111      		cpse r22,__zero_reg__
 564 01be 00C0      		rjmp .L39
 277:FreeRTOS/Source/queue.c **** 			{
 566               	.LM82:
 567 01c0 8885      		ldd r24,Y+8
 277:FreeRTOS/Source/queue.c **** 			{
 569               	.LM83:
 570 01c2 8823      		tst r24
 571 01c4 01F0      		breq .L41
 279:FreeRTOS/Source/queue.c **** 				{
 573               	.LM84:
 574 01c6 CE01      		movw r24,r28
 575 01c8 0896      		adiw r24,8
 576 01ca 0E94 0000 		call xTaskRemoveFromEventList
 279:FreeRTOS/Source/queue.c **** 				{
 578               	.LM85:
 579 01ce 8111      		cpse r24,__zero_reg__
 281:FreeRTOS/Source/queue.c **** 				}
 581               	.LM86:
 582 01d0 0E94 0000 		call vPortYield
 583               	.L41:
 300:FreeRTOS/Source/queue.c **** 
 585               	.LM87:
 586               	/* #APP */
 587               	 ;  300 "FreeRTOS/Source/queue.c" 1
 588 01d4 0F90      		pop		__tmp_reg__
 589               	 ;  0 "" 2
 590               	 ;  300 "FreeRTOS/Source/queue.c" 1
 591 01d6 0FBE      		out		__SREG__, __tmp_reg__
 592               	 ;  0 "" 2
 305:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 594               	.LM88:
 595               	/* #NOAPP */
 596 01d8 81E0      		ldi r24,lo8(1)
 597               	/* epilogue start */
 598 01da DF91      		pop r29
 599 01dc CF91      		pop r28
 600 01de 0895      		ret
 601               	.L39:
 296:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 603               	.LM89:
 604 01e0 CE01      		movw r24,r28
 605 01e2 0896      		adiw r24,8
 606 01e4 0E94 0000 		call vListInitialise
 297:FreeRTOS/Source/queue.c **** 		}
 608               	.LM90:
 609 01e8 CE01      		movw r24,r28
 610 01ea 4196      		adiw r24,17
 611 01ec 0E94 0000 		call vListInitialise
 612 01f0 00C0      		rjmp .L41
 614               	.Lscope5:
 621               	.global	xQueueGenericCreate
 623               	xQueueGenericCreate:
 369:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 625               	.LM91:
 626               	.LFBB6:
 627 01f2 0F93      		push r16
 628 01f4 1F93      		push r17
 629 01f6 CF93      		push r28
 630 01f8 DF93      		push r29
 631               	/* prologue: function */
 632               	/* frame size = 0 */
 633               	/* stack size = 4 */
 634               	.L__stack_usage = 4
 635 01fa 182F      		mov r17,r24
 636 01fc 062F      		mov r16,r22
 379:FreeRTOS/Source/queue.c **** 
 638               	.LM92:
 639 01fe 869F      		mul r24,r22
 640 0200 C001      		movw r24,r0
 641 0202 1124      		clr __zero_reg__
 390:FreeRTOS/Source/queue.c **** 
 643               	.LM93:
 644 0204 4F96      		adiw r24,31
 645 0206 0E94 0000 		call pvPortMalloc
 646 020a EC01      		movw r28,r24
 392:FreeRTOS/Source/queue.c **** 		{
 648               	.LM94:
 649 020c 0097      		sbiw r24,0
 650 020e 01F0      		breq .L46
 651               	.LBB8:
 652               	.LBB9:
 428:FreeRTOS/Source/queue.c **** 	{
 654               	.LM95:
 655 0210 0111      		cpse r16,__zero_reg__
 656 0212 00C0      		rjmp .L48
 434:FreeRTOS/Source/queue.c **** 	}
 658               	.LM96:
 659 0214 9983      		std Y+1,r25
 660 0216 8883      		st Y,r24
 661               	.L49:
 444:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 663               	.LM97:
 664 0218 1B8F      		std Y+27,r17
 445:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 666               	.LM98:
 667 021a 0C8F      		std Y+28,r16
 446:FreeRTOS/Source/queue.c **** 
 669               	.LM99:
 670 021c 61E0      		ldi r22,lo8(1)
 671 021e CE01      		movw r24,r28
 672 0220 0E94 0000 		call xQueueGenericReset
 673               	.L46:
 674               	.LBE9:
 675               	.LBE8:
 417:FreeRTOS/Source/queue.c **** 
 677               	.LM100:
 678 0224 CE01      		movw r24,r28
 679               	/* epilogue start */
 680 0226 DF91      		pop r29
 681 0228 CF91      		pop r28
 682 022a 1F91      		pop r17
 683 022c 0F91      		pop r16
 684 022e 0895      		ret
 685               	.L48:
 397:FreeRTOS/Source/queue.c **** 
 687               	.LM101:
 688 0230 4F96      		adiw r24,31
 689               	.LBB11:
 690               	.LBB10:
 439:FreeRTOS/Source/queue.c **** 	}
 692               	.LM102:
 693 0232 9983      		std Y+1,r25
 694 0234 8883      		st Y,r24
 695 0236 00C0      		rjmp .L49
 696               	.LBE10:
 697               	.LBE11:
 702               	.Lscope6:
 707               	.global	xQueueCreateCountingSemaphore
 709               	xQueueCreateCountingSemaphore:
 715:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 711               	.LM103:
 712               	.LFBB7:
 713 0238 CF93      		push r28
 714               	/* prologue: function */
 715               	/* frame size = 0 */
 716               	/* stack size = 1 */
 717               	.L__stack_usage = 1
 718 023a C62F      		mov r28,r22
 721:FreeRTOS/Source/queue.c **** 
 720               	.LM104:
 721 023c 42E0      		ldi r20,lo8(2)
 722 023e 60E0      		ldi r22,0
 723 0240 0E94 0000 		call xQueueGenericCreate
 723:FreeRTOS/Source/queue.c **** 		{
 725               	.LM105:
 726 0244 0097      		sbiw r24,0
 727 0246 01F0      		breq .L53
 725:FreeRTOS/Source/queue.c **** 
 729               	.LM106:
 730 0248 FC01      		movw r30,r24
 731 024a C28F      		std Z+26,r28
 732               	.L53:
 733               	/* epilogue start */
 735:FreeRTOS/Source/queue.c **** 
 735               	.LM107:
 736 024c CF91      		pop r28
 737 024e 0895      		ret
 742               	.Lscope7:
 749               	.global	xQueueGenericSend
 751               	xQueueGenericSend:
 741:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 753               	.LM108:
 754               	.LFBB8:
 755 0250 AF92      		push r10
 756 0252 BF92      		push r11
 757 0254 DF92      		push r13
 758 0256 EF92      		push r14
 759 0258 FF92      		push r15
 760 025a 0F93      		push r16
 761 025c 1F93      		push r17
 762 025e CF93      		push r28
 763 0260 DF93      		push r29
 764 0262 00D0      		rcall .
 765 0264 00D0      		rcall .
 766 0266 0F92      		push __tmp_reg__
 767 0268 CDB7      		in r28,__SP_L__
 768 026a DEB7      		in r29,__SP_H__
 769               	/* prologue: function */
 770               	/* frame size = 5 */
 771               	/* stack size = 14 */
 772               	.L__stack_usage = 14
 773 026c 8C01      		movw r16,r24
 774 026e 7B01      		movw r14,r22
 775 0270 5D83      		std Y+5,r21
 776 0272 4C83      		std Y+4,r20
 777 0274 D22E      		mov r13,r18
 742:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 779               	.LM109:
 780 0276 80E0      		ldi r24,0
 911:FreeRTOS/Source/queue.c **** 
 782               	.LM110:
 783 0278 5801      		movw r10,r16
 784 027a 98E0      		ldi r25,8
 785 027c A90E      		add r10,r25
 786 027e B11C      		adc r11,__zero_reg__
 787               	.L59:
 761:FreeRTOS/Source/queue.c **** 		{
 789               	.LM111:
 790               	/* #APP */
 791               	 ;  761 "FreeRTOS/Source/queue.c" 1
 792 0280 0FB6      		in		__tmp_reg__, __SREG__
 793               	 ;  0 "" 2
 794               	 ;  761 "FreeRTOS/Source/queue.c" 1
 795 0282 F894      		cli
 796               	 ;  0 "" 2
 797               	 ;  761 "FreeRTOS/Source/queue.c" 1
 798 0284 0F92      		push	__tmp_reg__
 799               	 ;  0 "" 2
 767:FreeRTOS/Source/queue.c **** 			{
 801               	.LM112:
 802               	/* #NOAPP */
 803 0286 F801      		movw r30,r16
 804 0288 228D      		ldd r18,Z+26
 767:FreeRTOS/Source/queue.c **** 			{
 806               	.LM113:
 807 028a 938D      		ldd r25,Z+27
 808 028c 2917      		cp r18,r25
 809 028e 00F0      		brlo .L60
 767:FreeRTOS/Source/queue.c **** 			{
 811               	.LM114:
 812 0290 F2E0      		ldi r31,lo8(2)
 813 0292 DF12      		cpse r13,r31
 814 0294 00C0      		rjmp .L61
 815               	.L60:
 833:FreeRTOS/Source/queue.c **** 
 817               	.LM115:
 818 0296 4D2D      		mov r20,r13
 819 0298 B701      		movw r22,r14
 820 029a C801      		movw r24,r16
 821 029c 0E94 0000 		call prvCopyDataToQueue
 837:FreeRTOS/Source/queue.c **** 					{
 823               	.LM116:
 824 02a0 F801      		movw r30,r16
 825 02a2 9189      		ldd r25,Z+17
 837:FreeRTOS/Source/queue.c **** 					{
 827               	.LM117:
 828 02a4 9923      		tst r25
 829 02a6 01F0      		breq .L74
 839:FreeRTOS/Source/queue.c **** 						{
 831               	.LM118:
 832 02a8 C801      		movw r24,r16
 833 02aa 4196      		adiw r24,17
 834 02ac 0E94 0000 		call xTaskRemoveFromEventList
 835               	.L74:
 839:FreeRTOS/Source/queue.c **** 						{
 837               	.LM119:
 838 02b0 8111      		cpse r24,__zero_reg__
 845:FreeRTOS/Source/queue.c **** 						}
 840               	.LM120:
 841 02b2 0E94 0000 		call vPortYield
 842               	.L64:
 867:FreeRTOS/Source/queue.c **** 				return pdPASS;
 844               	.LM121:
 845               	/* #APP */
 846               	 ;  867 "FreeRTOS/Source/queue.c" 1
 847 02b6 0F90      		pop		__tmp_reg__
 848               	 ;  0 "" 2
 849               	 ;  867 "FreeRTOS/Source/queue.c" 1
 850 02b8 0FBE      		out		__SREG__, __tmp_reg__
 851               	 ;  0 "" 2
 868:FreeRTOS/Source/queue.c **** 			}
 853               	.LM122:
 854               	/* #NOAPP */
 855 02ba 81E0      		ldi r24,lo8(1)
 856               	.L58:
 857               	/* epilogue start */
 947:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 859               	.LM123:
 860 02bc 0F90      		pop __tmp_reg__
 861 02be 0F90      		pop __tmp_reg__
 862 02c0 0F90      		pop __tmp_reg__
 863 02c2 0F90      		pop __tmp_reg__
 864 02c4 0F90      		pop __tmp_reg__
 865 02c6 DF91      		pop r29
 866 02c8 CF91      		pop r28
 867 02ca 1F91      		pop r17
 868 02cc 0F91      		pop r16
 869 02ce FF90      		pop r15
 870 02d0 EF90      		pop r14
 871 02d2 DF90      		pop r13
 872 02d4 BF90      		pop r11
 873 02d6 AF90      		pop r10
 874 02d8 0895      		ret
 875               	.L61:
 872:FreeRTOS/Source/queue.c **** 				{
 877               	.LM124:
 878 02da 2C81      		ldd r18,Y+4
 879 02dc 3D81      		ldd r19,Y+5
 880 02de 232B      		or r18,r19
 881 02e0 01F4      		brne .L67
 876:FreeRTOS/Source/queue.c **** 
 883               	.LM125:
 884               	/* #APP */
 885               	 ;  876 "FreeRTOS/Source/queue.c" 1
 886 02e2 0F90      		pop		__tmp_reg__
 887               	 ;  0 "" 2
 888               	 ;  876 "FreeRTOS/Source/queue.c" 1
 889 02e4 0FBE      		out		__SREG__, __tmp_reg__
 890               	 ;  0 "" 2
 891               	/* #NOAPP */
 892               	.L75:
 944:FreeRTOS/Source/queue.c **** 		}
 894               	.LM126:
 895 02e6 80E0      		ldi r24,0
 896 02e8 00C0      		rjmp .L58
 897               	.L67:
 883:FreeRTOS/Source/queue.c **** 				{
 899               	.LM127:
 900 02ea 8111      		cpse r24,__zero_reg__
 901 02ec 00C0      		rjmp .L68
 887:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 903               	.LM128:
 904 02ee CE01      		movw r24,r28
 905 02f0 0196      		adiw r24,1
 906 02f2 0E94 0000 		call vTaskInternalSetTimeOutState
 907               	.L68:
 897:FreeRTOS/Source/queue.c **** 
 909               	.LM129:
 910               	/* #APP */
 911               	 ;  897 "FreeRTOS/Source/queue.c" 1
 912 02f6 0F90      		pop		__tmp_reg__
 913               	 ;  0 "" 2
 914               	 ;  897 "FreeRTOS/Source/queue.c" 1
 915 02f8 0FBE      		out		__SREG__, __tmp_reg__
 916               	 ;  0 "" 2
 902:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 918               	.LM130:
 919               	/* #NOAPP */
 920 02fa 0E94 0000 		call vTaskSuspendAll
 903:FreeRTOS/Source/queue.c **** 
 922               	.LM131:
 923               	/* #APP */
 924               	 ;  903 "FreeRTOS/Source/queue.c" 1
 925 02fe 0FB6      		in		__tmp_reg__, __SREG__
 926               	 ;  0 "" 2
 927               	 ;  903 "FreeRTOS/Source/queue.c" 1
 928 0300 F894      		cli
 929               	 ;  0 "" 2
 930               	 ;  903 "FreeRTOS/Source/queue.c" 1
 931 0302 0F92      		push	__tmp_reg__
 932               	 ;  0 "" 2
 933               	/* #NOAPP */
 934 0304 F801      		movw r30,r16
 935 0306 858D      		ldd r24,Z+29
 936 0308 8F3F      		cpi r24,lo8(-1)
 937 030a 01F4      		brne .L69
 903:FreeRTOS/Source/queue.c **** 
 939               	.LM132:
 940 030c 158E      		std Z+29,__zero_reg__
 941               	.L69:
 903:FreeRTOS/Source/queue.c **** 
 943               	.LM133:
 944 030e F801      		movw r30,r16
 945 0310 868D      		ldd r24,Z+30
 946 0312 8F3F      		cpi r24,lo8(-1)
 947 0314 01F4      		brne .L70
 903:FreeRTOS/Source/queue.c **** 
 949               	.LM134:
 950 0316 168E      		std Z+30,__zero_reg__
 951               	.L70:
 903:FreeRTOS/Source/queue.c **** 
 953               	.LM135:
 954               	/* #APP */
 955               	 ;  903 "FreeRTOS/Source/queue.c" 1
 956 0318 0F90      		pop		__tmp_reg__
 957               	 ;  0 "" 2
 958               	 ;  903 "FreeRTOS/Source/queue.c" 1
 959 031a 0FBE      		out		__SREG__, __tmp_reg__
 960               	 ;  0 "" 2
 906:FreeRTOS/Source/queue.c **** 		{
 962               	.LM136:
 963               	/* #NOAPP */
 964 031c BE01      		movw r22,r28
 965 031e 6C5F      		subi r22,-4
 966 0320 7F4F      		sbci r23,-1
 967 0322 CE01      		movw r24,r28
 968 0324 0196      		adiw r24,1
 969 0326 0E94 0000 		call xTaskCheckForTimeOut
 906:FreeRTOS/Source/queue.c **** 		{
 971               	.LM137:
 972 032a 8111      		cpse r24,__zero_reg__
 973 032c 00C0      		rjmp .L71
 974               	.LBB14:
 975               	.LBB15:
2310:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2311:FreeRTOS/Source/queue.c **** 
2312:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2313:FreeRTOS/Source/queue.c **** {
2314:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2315:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
2316:FreeRTOS/Source/queue.c **** 
2317:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2318:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2319:FreeRTOS/Source/queue.c **** 	{
2320:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2321:FreeRTOS/Source/queue.c **** 	}
2322:FreeRTOS/Source/queue.c **** 	else
2323:FreeRTOS/Source/queue.c **** 	{
2324:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2325:FreeRTOS/Source/queue.c **** 	}
2326:FreeRTOS/Source/queue.c **** 
2327:FreeRTOS/Source/queue.c **** 	return xReturn;
2328:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2329:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2330:FreeRTOS/Source/queue.c **** 
2331:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2332:FreeRTOS/Source/queue.c **** {
2333:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2334:FreeRTOS/Source/queue.c **** 
2335:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 977               	.LM138:
 978               	/* #APP */
 979               	 ;  2335 "FreeRTOS/Source/queue.c" 1
 980 032e 0FB6      		in		__tmp_reg__, __SREG__
 981               	 ;  0 "" 2
 982               	 ;  2335 "FreeRTOS/Source/queue.c" 1
 983 0330 F894      		cli
 984               	 ;  0 "" 2
 985               	 ;  2335 "FreeRTOS/Source/queue.c" 1
 986 0332 0F92      		push	__tmp_reg__
 987               	 ;  0 "" 2
2336:FreeRTOS/Source/queue.c **** 	{
2337:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 989               	.LM139:
 990               	/* #NOAPP */
 991 0334 F801      		movw r30,r16
 992 0336 928D      		ldd r25,Z+26
2338:FreeRTOS/Source/queue.c **** 		{
2339:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2340:FreeRTOS/Source/queue.c **** 		}
2341:FreeRTOS/Source/queue.c **** 		else
2342:FreeRTOS/Source/queue.c **** 		{
2343:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2344:FreeRTOS/Source/queue.c **** 		}
2345:FreeRTOS/Source/queue.c **** 	}
2346:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 994               	.LM140:
 995               	/* #APP */
 996               	 ;  2346 "FreeRTOS/Source/queue.c" 1
 997 0338 0F90      		pop		__tmp_reg__
 998               	 ;  0 "" 2
 999               	 ;  2346 "FreeRTOS/Source/queue.c" 1
 1000 033a 0FBE      		out		__SREG__, __tmp_reg__
 1001               	 ;  0 "" 2
 1002               	/* #NOAPP */
 1003               	.LBE15:
 1004               	.LBE14:
 908:FreeRTOS/Source/queue.c **** 			{
 1006               	.LM141:
 1007 033c 838D      		ldd r24,Z+27
 1008 033e 9813      		cpse r25,r24
 1009 0340 00C0      		rjmp .L72
 911:FreeRTOS/Source/queue.c **** 
 1011               	.LM142:
 1012 0342 6C81      		ldd r22,Y+4
 1013 0344 7D81      		ldd r23,Y+5
 1014 0346 C501      		movw r24,r10
 1015 0348 0E94 0000 		call vTaskPlaceOnEventList
 918:FreeRTOS/Source/queue.c **** 
 1017               	.LM143:
 1018 034c C801      		movw r24,r16
 1019 034e 0E94 0000 		call prvUnlockQueue
 925:FreeRTOS/Source/queue.c **** 				{
 1021               	.LM144:
 1022 0352 0E94 0000 		call xTaskResumeAll
 925:FreeRTOS/Source/queue.c **** 				{
 1024               	.LM145:
 1025 0356 8111      		cpse r24,__zero_reg__
 1026 0358 00C0      		rjmp .L73
 927:FreeRTOS/Source/queue.c **** 				}
 1028               	.LM146:
 1029 035a 0E94 0000 		call vPortYield
 1030               	.L73:
 741:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1032               	.LM147:
 1033 035e 81E0      		ldi r24,lo8(1)
 1034 0360 00C0      		rjmp .L59
 1035               	.L72:
 933:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1037               	.LM148:
 1038 0362 C801      		movw r24,r16
 1039 0364 0E94 0000 		call prvUnlockQueue
 934:FreeRTOS/Source/queue.c **** 			}
 1041               	.LM149:
 1042 0368 0E94 0000 		call xTaskResumeAll
 1043 036c 00C0      		rjmp .L73
 1044               	.L71:
 940:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1046               	.LM150:
 1047 036e C801      		movw r24,r16
 1048 0370 0E94 0000 		call prvUnlockQueue
 941:FreeRTOS/Source/queue.c **** 
 1050               	.LM151:
 1051 0374 0E94 0000 		call xTaskResumeAll
 1052 0378 00C0      		rjmp .L75
 1061               	.Lscope8:
 1065               	.global	xQueueCreateMutex
 1067               	xQueueCreateMutex:
 497:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 1069               	.LM152:
 1070               	.LFBB9:
 1071 037a CF93      		push r28
 1072 037c DF93      		push r29
 1073               	/* prologue: function */
 1074               	/* frame size = 0 */
 1075               	/* stack size = 2 */
 1076               	.L__stack_usage = 2
 1077 037e 482F      		mov r20,r24
 501:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1079               	.LM153:
 1080 0380 60E0      		ldi r22,0
 1081 0382 81E0      		ldi r24,lo8(1)
 1082 0384 0E94 0000 		call xQueueGenericCreate
 1083 0388 EC01      		movw r28,r24
 1084               	.LBB18:
 1085               	.LBB19:
 468:FreeRTOS/Source/queue.c **** 		{
 1087               	.LM154:
 1088 038a 0097      		sbiw r24,0
 1089 038c 01F0      		breq .L76
 474:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1091               	.LM155:
 1092 038e 1D82      		std Y+5,__zero_reg__
 1093 0390 1C82      		std Y+4,__zero_reg__
 475:FreeRTOS/Source/queue.c **** 
 1095               	.LM156:
 1096 0392 1982      		std Y+1,__zero_reg__
 1097 0394 1882      		st Y,__zero_reg__
 478:FreeRTOS/Source/queue.c **** 
 1099               	.LM157:
 1100 0396 1E82      		std Y+6,__zero_reg__
 483:FreeRTOS/Source/queue.c **** 		}
 1102               	.LM158:
 1103 0398 20E0      		ldi r18,0
 1104 039a 50E0      		ldi r21,0
 1105 039c 40E0      		ldi r20,0
 1106 039e 70E0      		ldi r23,0
 1107 03a0 60E0      		ldi r22,0
 1108 03a2 0E94 0000 		call xQueueGenericSend
 1109               	.L76:
 1110               	.LBE19:
 1111               	.LBE18:
 505:FreeRTOS/Source/queue.c **** 
 1113               	.LM159:
 1114 03a6 CE01      		movw r24,r28
 1115               	/* epilogue start */
 1116 03a8 DF91      		pop r29
 1117 03aa CF91      		pop r28
 1118 03ac 0895      		ret
 1123               	.Lscope9:
 1130               	.global	xQueueGenericSendFromISR
 1132               	xQueueGenericSendFromISR:
 951:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1134               	.LM160:
 1135               	.LFBB10:
 1136 03ae FF92      		push r15
 1137 03b0 0F93      		push r16
 1138 03b2 1F93      		push r17
 1139 03b4 CF93      		push r28
 1140 03b6 DF93      		push r29
 1141               	/* prologue: function */
 1142               	/* frame size = 0 */
 1143               	/* stack size = 5 */
 1144               	.L__stack_usage = 5
 1145 03b8 EC01      		movw r28,r24
 1146 03ba 8A01      		movw r16,r20
 1147 03bc 422F      		mov r20,r18
 983:FreeRTOS/Source/queue.c **** 		{
 1149               	.LM161:
 1150 03be 9A8D      		ldd r25,Y+26
 983:FreeRTOS/Source/queue.c **** 		{
 1152               	.LM162:
 1153 03c0 8B8D      		ldd r24,Y+27
 1154 03c2 9817      		cp r25,r24
 1155 03c4 00F0      		brlo .L82
1103:FreeRTOS/Source/queue.c **** 		}
 1157               	.LM163:
 1158 03c6 80E0      		ldi r24,0
 983:FreeRTOS/Source/queue.c **** 		{
 1160               	.LM164:
 1161 03c8 2230      		cpi r18,lo8(2)
 1162 03ca 01F4      		brne .L81
 1163               	.L82:
 1164               	.LBB20:
 985:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1166               	.LM165:
 1167 03cc FE8C      		ldd r15,Y+30
 986:FreeRTOS/Source/queue.c **** 
 1169               	.LM166:
 1170 03ce 8A8D      		ldd r24,Y+26
 995:FreeRTOS/Source/queue.c **** 
 1172               	.LM167:
 1173 03d0 CE01      		movw r24,r28
 1174 03d2 0E94 0000 		call prvCopyDataToQueue
 999:FreeRTOS/Source/queue.c **** 			{
 1176               	.LM168:
 1177 03d6 8FEF      		ldi r24,lo8(-1)
 1178 03d8 F812      		cpse r15,r24
 1179 03da 00C0      		rjmp .L84
1061:FreeRTOS/Source/queue.c **** 					{
 1181               	.LM169:
 1182 03dc 8989      		ldd r24,Y+17
1061:FreeRTOS/Source/queue.c **** 					{
 1184               	.LM170:
 1185 03de 8111      		cpse r24,__zero_reg__
 1186 03e0 00C0      		rjmp .L85
 1187               	.L94:
1098:FreeRTOS/Source/queue.c **** 		}
 1189               	.LM171:
 1190 03e2 81E0      		ldi r24,lo8(1)
 1191 03e4 00C0      		rjmp .L81
 1192               	.L85:
1063:FreeRTOS/Source/queue.c **** 						{
 1194               	.LM172:
 1195 03e6 CE01      		movw r24,r28
 1196 03e8 4196      		adiw r24,17
 1197 03ea 0E94 0000 		call xTaskRemoveFromEventList
1063:FreeRTOS/Source/queue.c **** 						{
 1199               	.LM173:
 1200 03ee 8823      		tst r24
 1201 03f0 01F0      		breq .L94
1067:FreeRTOS/Source/queue.c **** 							{
 1203               	.LM174:
 1204 03f2 0115      		cp r16,__zero_reg__
 1205 03f4 1105      		cpc r17,__zero_reg__
 1206 03f6 01F0      		breq .L94
1069:FreeRTOS/Source/queue.c **** 							}
 1208               	.LM175:
 1209 03f8 81E0      		ldi r24,lo8(1)
 1210 03fa F801      		movw r30,r16
 1211 03fc 8083      		st Z,r24
 1212               	.L81:
 1213               	/* epilogue start */
 1214               	.LBE20:
1109:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1216               	.LM176:
 1217 03fe DF91      		pop r29
 1218 0400 CF91      		pop r28
 1219 0402 1F91      		pop r17
 1220 0404 0F91      		pop r16
 1221 0406 FF90      		pop r15
 1222 0408 0895      		ret
 1223               	.L84:
 1224               	.LBB21:
1095:FreeRTOS/Source/queue.c **** 			}
 1226               	.LM177:
 1227 040a F394      		inc r15
1095:FreeRTOS/Source/queue.c **** 			}
 1229               	.LM178:
 1230 040c FE8E      		std Y+30,r15
 1231 040e 00C0      		rjmp .L94
 1232               	.LBE21:
 1245               	.Lscope10:
 1250               	.global	xQueueGiveFromISR
 1252               	xQueueGiveFromISR:
1113:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1254               	.LM179:
 1255               	.LFBB11:
 1256 0410 CF93      		push r28
 1257 0412 DF93      		push r29
 1258               	/* prologue: function */
 1259               	/* frame size = 0 */
 1260               	/* stack size = 2 */
 1261               	.L__stack_usage = 2
 1262 0414 FC01      		movw r30,r24
 1263 0416 EB01      		movw r28,r22
 1264               	.LBB22:
1153:FreeRTOS/Source/queue.c **** 
 1266               	.LM180:
 1267 0418 928D      		ldd r25,Z+26
1158:FreeRTOS/Source/queue.c **** 		{
 1269               	.LM181:
 1270 041a 838D      		ldd r24,Z+27
 1271 041c 9817      		cp r25,r24
 1272 041e 00F4      		brsh .L100
 1273               	.LBB23:
1160:FreeRTOS/Source/queue.c **** 
 1275               	.LM182:
 1276 0420 868D      		ldd r24,Z+30
1170:FreeRTOS/Source/queue.c **** 
 1278               	.LM183:
 1279 0422 9F5F      		subi r25,lo8(-(1))
1170:FreeRTOS/Source/queue.c **** 
 1281               	.LM184:
 1282 0424 928F      		std Z+26,r25
1174:FreeRTOS/Source/queue.c **** 			{
 1284               	.LM185:
 1285 0426 8F3F      		cpi r24,lo8(-1)
 1286 0428 01F4      		brne .L97
1229:FreeRTOS/Source/queue.c **** 					{
 1288               	.LM186:
 1289 042a 8189      		ldd r24,Z+17
1229:FreeRTOS/Source/queue.c **** 					{
 1291               	.LM187:
 1292 042c 8111      		cpse r24,__zero_reg__
 1293 042e 00C0      		rjmp .L98
 1294               	.L107:
1263:FreeRTOS/Source/queue.c **** 		}
 1296               	.LM188:
 1297 0430 81E0      		ldi r24,lo8(1)
 1298 0432 00C0      		rjmp .L95
 1299               	.L98:
1231:FreeRTOS/Source/queue.c **** 						{
 1301               	.LM189:
 1302 0434 CF01      		movw r24,r30
 1303 0436 4196      		adiw r24,17
 1304 0438 0E94 0000 		call xTaskRemoveFromEventList
1231:FreeRTOS/Source/queue.c **** 						{
 1306               	.LM190:
 1307 043c 8823      		tst r24
 1308 043e 01F0      		breq .L107
1235:FreeRTOS/Source/queue.c **** 							{
 1310               	.LM191:
 1311 0440 2097      		sbiw r28,0
 1312 0442 01F0      		breq .L107
1237:FreeRTOS/Source/queue.c **** 							}
 1314               	.LM192:
 1315 0444 81E0      		ldi r24,lo8(1)
 1316 0446 8883      		st Y,r24
 1317               	.L95:
 1318               	/* epilogue start */
 1319               	.LBE23:
 1320               	.LBE22:
1274:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1322               	.LM193:
 1323 0448 DF91      		pop r29
 1324 044a CF91      		pop r28
 1325 044c 0895      		ret
 1326               	.L97:
 1327               	.LBB25:
 1328               	.LBB24:
1260:FreeRTOS/Source/queue.c **** 			}
 1330               	.LM194:
 1331 044e 8F5F      		subi r24,lo8(-(1))
1260:FreeRTOS/Source/queue.c **** 			}
 1333               	.LM195:
 1334 0450 868F      		std Z+30,r24
 1335 0452 00C0      		rjmp .L107
 1336               	.L100:
 1337               	.LBE24:
1268:FreeRTOS/Source/queue.c **** 		}
 1339               	.LM196:
 1340 0454 80E0      		ldi r24,0
 1341               	.LBE25:
1273:FreeRTOS/Source/queue.c **** }
 1343               	.LM197:
 1344 0456 00C0      		rjmp .L95
 1361               	.Lscope11:
 1367               	.global	xQueueReceive
 1369               	xQueueReceive:
1278:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1371               	.LM198:
 1372               	.LFBB12:
 1373 0458 BF92      		push r11
 1374 045a CF92      		push r12
 1375 045c DF92      		push r13
 1376 045e EF92      		push r14
 1377 0460 FF92      		push r15
 1378 0462 0F93      		push r16
 1379 0464 1F93      		push r17
 1380 0466 CF93      		push r28
 1381 0468 DF93      		push r29
 1382 046a 00D0      		rcall .
 1383 046c 00D0      		rcall .
 1384 046e 0F92      		push __tmp_reg__
 1385 0470 CDB7      		in r28,__SP_L__
 1386 0472 DEB7      		in r29,__SP_H__
 1387               	/* prologue: function */
 1388               	/* frame size = 5 */
 1389               	/* stack size = 14 */
 1390               	.L__stack_usage = 14
 1391 0474 8C01      		movw r16,r24
 1392 0476 7B01      		movw r14,r22
 1393 0478 5D83      		std Y+5,r21
 1394 047a 4C83      		std Y+4,r20
1279:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1396               	.LM199:
 1397 047c 80E0      		ldi r24,0
1378:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1399               	.LM200:
 1400 047e 6801      		movw r12,r16
 1401 0480 91E1      		ldi r25,17
 1402 0482 C90E      		add r12,r25
 1403 0484 D11C      		adc r13,__zero_reg__
 1404               	.L109:
1303:FreeRTOS/Source/queue.c **** 		{
 1406               	.LM201:
 1407               	/* #APP */
 1408               	 ;  1303 "FreeRTOS/Source/queue.c" 1
 1409 0486 0FB6      		in		__tmp_reg__, __SREG__
 1410               	 ;  0 "" 2
 1411               	 ;  1303 "FreeRTOS/Source/queue.c" 1
 1412 0488 F894      		cli
 1413               	 ;  0 "" 2
 1414               	 ;  1303 "FreeRTOS/Source/queue.c" 1
 1415 048a 0F92      		push	__tmp_reg__
 1416               	 ;  0 "" 2
 1417               	/* #NOAPP */
 1418               	.LBB26:
1305:FreeRTOS/Source/queue.c **** 
 1420               	.LM202:
 1421 048c F801      		movw r30,r16
 1422 048e B28C      		ldd r11,Z+26
1309:FreeRTOS/Source/queue.c **** 			{
 1424               	.LM203:
 1425 0490 BB20      		tst r11
 1426 0492 01F0      		breq .L110
1312:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
 1428               	.LM204:
 1429 0494 B701      		movw r22,r14
 1430 0496 C801      		movw r24,r16
 1431 0498 0E94 0000 		call prvCopyDataFromQueue
1314:FreeRTOS/Source/queue.c **** 
 1433               	.LM205:
 1434 049c BA94      		dec r11
1314:FreeRTOS/Source/queue.c **** 
 1436               	.LM206:
 1437 049e F801      		movw r30,r16
 1438 04a0 B28E      		std Z+26,r11
1319:FreeRTOS/Source/queue.c **** 				{
 1440               	.LM207:
 1441 04a2 8085      		ldd r24,Z+8
1319:FreeRTOS/Source/queue.c **** 				{
 1443               	.LM208:
 1444 04a4 8823      		tst r24
 1445 04a6 01F0      		breq .L112
1321:FreeRTOS/Source/queue.c **** 					{
 1447               	.LM209:
 1448 04a8 C801      		movw r24,r16
 1449 04aa 0896      		adiw r24,8
 1450 04ac 0E94 0000 		call xTaskRemoveFromEventList
1321:FreeRTOS/Source/queue.c **** 					{
 1452               	.LM210:
 1453 04b0 8111      		cpse r24,__zero_reg__
1323:FreeRTOS/Source/queue.c **** 					}
 1455               	.LM211:
 1456 04b2 0E94 0000 		call vPortYield
 1457               	.L112:
1335:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1459               	.LM212:
 1460               	/* #APP */
 1461               	 ;  1335 "FreeRTOS/Source/queue.c" 1
 1462 04b6 0F90      		pop		__tmp_reg__
 1463               	 ;  0 "" 2
 1464               	 ;  1335 "FreeRTOS/Source/queue.c" 1
 1465 04b8 0FBE      		out		__SREG__, __tmp_reg__
 1466               	 ;  0 "" 2
1336:FreeRTOS/Source/queue.c **** 			}
 1468               	.LM213:
 1469               	/* #NOAPP */
 1470 04ba 81E0      		ldi r24,lo8(1)
 1471               	.L108:
 1472               	/* epilogue start */
 1473               	.LBE26:
1415:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1475               	.LM214:
 1476 04bc 0F90      		pop __tmp_reg__
 1477 04be 0F90      		pop __tmp_reg__
 1478 04c0 0F90      		pop __tmp_reg__
 1479 04c2 0F90      		pop __tmp_reg__
 1480 04c4 0F90      		pop __tmp_reg__
 1481 04c6 DF91      		pop r29
 1482 04c8 CF91      		pop r28
 1483 04ca 1F91      		pop r17
 1484 04cc 0F91      		pop r16
 1485 04ce FF90      		pop r15
 1486 04d0 EF90      		pop r14
 1487 04d2 DF90      		pop r13
 1488 04d4 CF90      		pop r12
 1489 04d6 BF90      		pop r11
 1490 04d8 0895      		ret
 1491               	.L110:
 1492               	.LBB27:
1340:FreeRTOS/Source/queue.c **** 				{
 1494               	.LM215:
 1495 04da 2C81      		ldd r18,Y+4
 1496 04dc 3D81      		ldd r19,Y+5
 1497 04de 232B      		or r18,r19
 1498 04e0 01F4      		brne .L115
1344:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1500               	.LM216:
 1501               	/* #APP */
 1502               	 ;  1344 "FreeRTOS/Source/queue.c" 1
 1503 04e2 0F90      		pop		__tmp_reg__
 1504               	 ;  0 "" 2
 1505               	 ;  1344 "FreeRTOS/Source/queue.c" 1
 1506 04e4 0FBE      		out		__SREG__, __tmp_reg__
 1507               	 ;  0 "" 2
 1508               	/* #NOAPP */
 1509               	.L129:
 1510               	.LBE27:
1407:FreeRTOS/Source/queue.c **** 			}
 1512               	.LM217:
 1513 04e6 80E0      		ldi r24,0
 1514 04e8 00C0      		rjmp .L108
 1515               	.L115:
 1516               	.LBB28:
1348:FreeRTOS/Source/queue.c **** 				{
 1518               	.LM218:
 1519 04ea 8111      		cpse r24,__zero_reg__
 1520 04ec 00C0      		rjmp .L116
1352:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1522               	.LM219:
 1523 04ee CE01      		movw r24,r28
 1524 04f0 0196      		adiw r24,1
 1525 04f2 0E94 0000 		call vTaskInternalSetTimeOutState
 1526               	.L116:
 1527               	.LBE28:
1362:FreeRTOS/Source/queue.c **** 
 1529               	.LM220:
 1530               	/* #APP */
 1531               	 ;  1362 "FreeRTOS/Source/queue.c" 1
 1532 04f6 0F90      		pop		__tmp_reg__
 1533               	 ;  0 "" 2
 1534               	 ;  1362 "FreeRTOS/Source/queue.c" 1
 1535 04f8 0FBE      		out		__SREG__, __tmp_reg__
 1536               	 ;  0 "" 2
1367:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1538               	.LM221:
 1539               	/* #NOAPP */
 1540 04fa 0E94 0000 		call vTaskSuspendAll
1368:FreeRTOS/Source/queue.c **** 
 1542               	.LM222:
 1543               	/* #APP */
 1544               	 ;  1368 "FreeRTOS/Source/queue.c" 1
 1545 04fe 0FB6      		in		__tmp_reg__, __SREG__
 1546               	 ;  0 "" 2
 1547               	 ;  1368 "FreeRTOS/Source/queue.c" 1
 1548 0500 F894      		cli
 1549               	 ;  0 "" 2
 1550               	 ;  1368 "FreeRTOS/Source/queue.c" 1
 1551 0502 0F92      		push	__tmp_reg__
 1552               	 ;  0 "" 2
 1553               	/* #NOAPP */
 1554 0504 F801      		movw r30,r16
 1555 0506 858D      		ldd r24,Z+29
 1556 0508 8F3F      		cpi r24,lo8(-1)
 1557 050a 01F4      		brne .L117
1368:FreeRTOS/Source/queue.c **** 
 1559               	.LM223:
 1560 050c 158E      		std Z+29,__zero_reg__
 1561               	.L117:
1368:FreeRTOS/Source/queue.c **** 
 1563               	.LM224:
 1564 050e F801      		movw r30,r16
 1565 0510 868D      		ldd r24,Z+30
 1566 0512 8F3F      		cpi r24,lo8(-1)
 1567 0514 01F4      		brne .L118
1368:FreeRTOS/Source/queue.c **** 
 1569               	.LM225:
 1570 0516 168E      		std Z+30,__zero_reg__
 1571               	.L118:
1368:FreeRTOS/Source/queue.c **** 
 1573               	.LM226:
 1574               	/* #APP */
 1575               	 ;  1368 "FreeRTOS/Source/queue.c" 1
 1576 0518 0F90      		pop		__tmp_reg__
 1577               	 ;  0 "" 2
 1578               	 ;  1368 "FreeRTOS/Source/queue.c" 1
 1579 051a 0FBE      		out		__SREG__, __tmp_reg__
 1580               	 ;  0 "" 2
1371:FreeRTOS/Source/queue.c **** 		{
 1582               	.LM227:
 1583               	/* #NOAPP */
 1584 051c BE01      		movw r22,r28
 1585 051e 6C5F      		subi r22,-4
 1586 0520 7F4F      		sbci r23,-1
 1587 0522 CE01      		movw r24,r28
 1588 0524 0196      		adiw r24,1
 1589 0526 0E94 0000 		call xTaskCheckForTimeOut
1371:FreeRTOS/Source/queue.c **** 		{
 1591               	.LM228:
 1592 052a 8111      		cpse r24,__zero_reg__
 1593 052c 00C0      		rjmp .L119
1375:FreeRTOS/Source/queue.c **** 			{
 1595               	.LM229:
 1596 052e C801      		movw r24,r16
 1597 0530 0E94 0000 		call prvIsQueueEmpty
1375:FreeRTOS/Source/queue.c **** 			{
 1599               	.LM230:
 1600 0534 8823      		tst r24
 1601 0536 01F0      		breq .L120
1378:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1603               	.LM231:
 1604 0538 6C81      		ldd r22,Y+4
 1605 053a 7D81      		ldd r23,Y+5
 1606 053c C601      		movw r24,r12
 1607 053e 0E94 0000 		call vTaskPlaceOnEventList
1379:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1609               	.LM232:
 1610 0542 C801      		movw r24,r16
 1611 0544 0E94 0000 		call prvUnlockQueue
1380:FreeRTOS/Source/queue.c **** 				{
 1613               	.LM233:
 1614 0548 0E94 0000 		call xTaskResumeAll
1380:FreeRTOS/Source/queue.c **** 				{
 1616               	.LM234:
 1617 054c 8111      		cpse r24,__zero_reg__
 1618 054e 00C0      		rjmp .L122
1382:FreeRTOS/Source/queue.c **** 				}
 1620               	.LM235:
 1621 0550 0E94 0000 		call vPortYield
 1622               	.L122:
1278:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1624               	.LM236:
 1625 0554 81E0      		ldi r24,lo8(1)
 1626 0556 00C0      		rjmp .L109
 1627               	.L120:
1393:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1629               	.LM237:
 1630 0558 C801      		movw r24,r16
 1631 055a 0E94 0000 		call prvUnlockQueue
1394:FreeRTOS/Source/queue.c **** 			}
 1633               	.LM238:
 1634 055e 0E94 0000 		call xTaskResumeAll
 1635 0562 00C0      		rjmp .L122
 1636               	.L119:
1401:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1638               	.LM239:
 1639 0564 C801      		movw r24,r16
 1640 0566 0E94 0000 		call prvUnlockQueue
1402:FreeRTOS/Source/queue.c **** 
 1642               	.LM240:
 1643 056a 0E94 0000 		call xTaskResumeAll
1404:FreeRTOS/Source/queue.c **** 			{
 1645               	.LM241:
 1646 056e C801      		movw r24,r16
 1647 0570 0E94 0000 		call prvIsQueueEmpty
1404:FreeRTOS/Source/queue.c **** 			{
 1649               	.LM242:
 1650 0574 8823      		tst r24
 1651 0576 01F0      		breq .L122
 1652 0578 00C0      		rjmp .L129
 1667               	.Lscope12:
 1672               	.global	xQueueSemaphoreTake
 1674               	xQueueSemaphoreTake:
1419:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1676               	.LM243:
 1677               	.LFBB13:
 1678 057a CF92      		push r12
 1679 057c DF92      		push r13
 1680 057e FF92      		push r15
 1681 0580 0F93      		push r16
 1682 0582 1F93      		push r17
 1683 0584 CF93      		push r28
 1684 0586 DF93      		push r29
 1685 0588 00D0      		rcall .
 1686 058a 00D0      		rcall .
 1687 058c 0F92      		push __tmp_reg__
 1688 058e CDB7      		in r28,__SP_L__
 1689 0590 DEB7      		in r29,__SP_H__
 1690               	/* prologue: function */
 1691               	/* frame size = 5 */
 1692               	/* stack size = 12 */
 1693               	.L__stack_usage = 12
 1694 0592 8C01      		movw r16,r24
 1695 0594 7D83      		std Y+5,r23
 1696 0596 6C83      		std Y+4,r22
1425:FreeRTOS/Source/queue.c **** #endif
 1698               	.LM244:
 1699 0598 F12C      		mov r15,__zero_reg__
1420:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1701               	.LM245:
 1702 059a 90E0      		ldi r25,0
1569:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1704               	.LM246:
 1705 059c 6801      		movw r12,r16
 1706 059e 81E1      		ldi r24,17
 1707 05a0 C80E      		add r12,r24
 1708 05a2 D11C      		adc r13,__zero_reg__
 1709               	.L131:
1448:FreeRTOS/Source/queue.c **** 		{
 1711               	.LM247:
 1712               	/* #APP */
 1713               	 ;  1448 "FreeRTOS/Source/queue.c" 1
 1714 05a4 0FB6      		in		__tmp_reg__, __SREG__
 1715               	 ;  0 "" 2
 1716               	 ;  1448 "FreeRTOS/Source/queue.c" 1
 1717 05a6 F894      		cli
 1718               	 ;  0 "" 2
 1719               	 ;  1448 "FreeRTOS/Source/queue.c" 1
 1720 05a8 0F92      		push	__tmp_reg__
 1721               	 ;  0 "" 2
 1722               	/* #NOAPP */
 1723               	.LBB33:
1452:FreeRTOS/Source/queue.c **** 
 1725               	.LM248:
 1726 05aa D801      		movw r26,r16
 1727 05ac 5A96      		adiw r26,26
 1728 05ae 8C91      		ld r24,X
 1729 05b0 5A97      		sbiw r26,26
1456:FreeRTOS/Source/queue.c **** 			{
 1731               	.LM249:
 1732 05b2 8823      		tst r24
 1733 05b4 01F0      		breq .L132
1462:FreeRTOS/Source/queue.c **** 
 1735               	.LM250:
 1736 05b6 8150      		subi r24,lo8(-(-1))
1462:FreeRTOS/Source/queue.c **** 
 1738               	.LM251:
 1739 05b8 5A96      		adiw r26,26
 1740 05ba 8C93      		st X,r24
 1741 05bc 5A97      		sbiw r26,26
1466:FreeRTOS/Source/queue.c **** 					{
 1743               	.LM252:
 1744 05be 8D91      		ld r24,X+
 1745 05c0 9C91      		ld r25,X
 1746 05c2 892B      		or r24,r25
 1747 05c4 01F4      		brne .L133
1470:FreeRTOS/Source/queue.c **** 					}
 1749               	.LM253:
 1750 05c6 0E94 0000 		call pvTaskIncrementMutexHeldCount
1470:FreeRTOS/Source/queue.c **** 					}
 1752               	.LM254:
 1753 05ca F801      		movw r30,r16
 1754 05cc 9583      		std Z+5,r25
 1755 05ce 8483      		std Z+4,r24
 1756               	.L133:
1481:FreeRTOS/Source/queue.c **** 				{
 1758               	.LM255:
 1759 05d0 D801      		movw r26,r16
 1760 05d2 1896      		adiw r26,8
 1761 05d4 8C91      		ld r24,X
1481:FreeRTOS/Source/queue.c **** 				{
 1763               	.LM256:
 1764 05d6 8823      		tst r24
 1765 05d8 01F0      		breq .L135
1483:FreeRTOS/Source/queue.c **** 					{
 1767               	.LM257:
 1768 05da C801      		movw r24,r16
 1769 05dc 0896      		adiw r24,8
 1770 05de 0E94 0000 		call xTaskRemoveFromEventList
1483:FreeRTOS/Source/queue.c **** 					{
 1772               	.LM258:
 1773 05e2 8111      		cpse r24,__zero_reg__
1485:FreeRTOS/Source/queue.c **** 					}
 1775               	.LM259:
 1776 05e4 0E94 0000 		call vPortYield
 1777               	.L135:
1497:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1779               	.LM260:
 1780               	/* #APP */
 1781               	 ;  1497 "FreeRTOS/Source/queue.c" 1
 1782 05e8 0F90      		pop		__tmp_reg__
 1783               	 ;  0 "" 2
 1784               	 ;  1497 "FreeRTOS/Source/queue.c" 1
 1785 05ea 0FBE      		out		__SREG__, __tmp_reg__
 1786               	 ;  0 "" 2
1498:FreeRTOS/Source/queue.c **** 			}
 1788               	.LM261:
 1789               	/* #NOAPP */
 1790 05ec FF24      		clr r15
 1791 05ee F394      		inc r15
 1792               	.L130:
 1793               	.LBE33:
1633:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1795               	.LM262:
 1796 05f0 8F2D      		mov r24,r15
 1797               	/* epilogue start */
 1798 05f2 0F90      		pop __tmp_reg__
 1799 05f4 0F90      		pop __tmp_reg__
 1800 05f6 0F90      		pop __tmp_reg__
 1801 05f8 0F90      		pop __tmp_reg__
 1802 05fa 0F90      		pop __tmp_reg__
 1803 05fc DF91      		pop r29
 1804 05fe CF91      		pop r28
 1805 0600 1F91      		pop r17
 1806 0602 0F91      		pop r16
 1807 0604 FF90      		pop r15
 1808 0606 DF90      		pop r13
 1809 0608 CF90      		pop r12
 1810 060a 0895      		ret
 1811               	.L132:
 1812               	.LBB34:
1502:FreeRTOS/Source/queue.c **** 				{
 1814               	.LM263:
 1815 060c 2C81      		ldd r18,Y+4
 1816 060e 3D81      		ldd r19,Y+5
 1817 0610 232B      		or r18,r19
 1818 0612 01F4      		brne .L138
 1819               	.L159:
 1820               	.LBE34:
1619:FreeRTOS/Source/queue.c **** 					}
 1822               	.LM264:
 1823               	/* #APP */
 1824               	 ;  1619 "FreeRTOS/Source/queue.c" 1
 1825 0614 0F90      		pop		__tmp_reg__
 1826               	 ;  0 "" 2
 1827               	 ;  1619 "FreeRTOS/Source/queue.c" 1
 1828 0616 0FBE      		out		__SREG__, __tmp_reg__
 1829               	 ;  0 "" 2
1625:FreeRTOS/Source/queue.c **** 			}
 1831               	.LM265:
 1832               	/* #NOAPP */
 1833 0618 F12C      		mov r15,__zero_reg__
 1834 061a 00C0      		rjmp .L130
 1835               	.L138:
 1836               	.LBB35:
1519:FreeRTOS/Source/queue.c **** 				{
 1838               	.LM266:
 1839 061c 9111      		cpse r25,__zero_reg__
 1840 061e 00C0      		rjmp .L139
1523:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1842               	.LM267:
 1843 0620 CE01      		movw r24,r28
 1844 0622 0196      		adiw r24,1
 1845 0624 0E94 0000 		call vTaskInternalSetTimeOutState
 1846               	.L139:
 1847               	.LBE35:
1533:FreeRTOS/Source/queue.c **** 
 1849               	.LM268:
 1850               	/* #APP */
 1851               	 ;  1533 "FreeRTOS/Source/queue.c" 1
 1852 0628 0F90      		pop		__tmp_reg__
 1853               	 ;  0 "" 2
 1854               	 ;  1533 "FreeRTOS/Source/queue.c" 1
 1855 062a 0FBE      		out		__SREG__, __tmp_reg__
 1856               	 ;  0 "" 2
1538:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1858               	.LM269:
 1859               	/* #NOAPP */
 1860 062c 0E94 0000 		call vTaskSuspendAll
1539:FreeRTOS/Source/queue.c **** 
 1862               	.LM270:
 1863               	/* #APP */
 1864               	 ;  1539 "FreeRTOS/Source/queue.c" 1
 1865 0630 0FB6      		in		__tmp_reg__, __SREG__
 1866               	 ;  0 "" 2
 1867               	 ;  1539 "FreeRTOS/Source/queue.c" 1
 1868 0632 F894      		cli
 1869               	 ;  0 "" 2
 1870               	 ;  1539 "FreeRTOS/Source/queue.c" 1
 1871 0634 0F92      		push	__tmp_reg__
 1872               	 ;  0 "" 2
 1873               	/* #NOAPP */
 1874 0636 F801      		movw r30,r16
 1875 0638 858D      		ldd r24,Z+29
 1876 063a 8F3F      		cpi r24,lo8(-1)
 1877 063c 01F4      		brne .L140
1539:FreeRTOS/Source/queue.c **** 
 1879               	.LM271:
 1880 063e 158E      		std Z+29,__zero_reg__
 1881               	.L140:
1539:FreeRTOS/Source/queue.c **** 
 1883               	.LM272:
 1884 0640 D801      		movw r26,r16
 1885 0642 5E96      		adiw r26,30
 1886 0644 8C91      		ld r24,X
 1887 0646 5E97      		sbiw r26,30
 1888 0648 8F3F      		cpi r24,lo8(-1)
 1889 064a 01F4      		brne .L141
1539:FreeRTOS/Source/queue.c **** 
 1891               	.LM273:
 1892 064c 5E96      		adiw r26,30
 1893 064e 1C92      		st X,__zero_reg__
 1894               	.L141:
1539:FreeRTOS/Source/queue.c **** 
 1896               	.LM274:
 1897               	/* #APP */
 1898               	 ;  1539 "FreeRTOS/Source/queue.c" 1
 1899 0650 0F90      		pop		__tmp_reg__
 1900               	 ;  0 "" 2
 1901               	 ;  1539 "FreeRTOS/Source/queue.c" 1
 1902 0652 0FBE      		out		__SREG__, __tmp_reg__
 1903               	 ;  0 "" 2
1542:FreeRTOS/Source/queue.c **** 		{
 1905               	.LM275:
 1906               	/* #NOAPP */
 1907 0654 BE01      		movw r22,r28
 1908 0656 6C5F      		subi r22,-4
 1909 0658 7F4F      		sbci r23,-1
 1910 065a CE01      		movw r24,r28
 1911 065c 0196      		adiw r24,1
 1912 065e 0E94 0000 		call xTaskCheckForTimeOut
1542:FreeRTOS/Source/queue.c **** 		{
 1914               	.LM276:
 1915 0662 8111      		cpse r24,__zero_reg__
 1916 0664 00C0      		rjmp .L142
1548:FreeRTOS/Source/queue.c **** 			{
 1918               	.LM277:
 1919 0666 C801      		movw r24,r16
 1920 0668 0E94 0000 		call prvIsQueueEmpty
1548:FreeRTOS/Source/queue.c **** 			{
 1922               	.LM278:
 1923 066c 8823      		tst r24
 1924 066e 01F0      		breq .L143
1554:FreeRTOS/Source/queue.c **** 					{
 1926               	.LM279:
 1927 0670 F801      		movw r30,r16
 1928 0672 8081      		ld r24,Z
 1929 0674 9181      		ldd r25,Z+1
 1930 0676 892B      		or r24,r25
 1931 0678 01F4      		brne .L144
1556:FreeRTOS/Source/queue.c **** 						{
 1933               	.LM280:
 1934               	/* #APP */
 1935               	 ;  1556 "FreeRTOS/Source/queue.c" 1
 1936 067a 0FB6      		in		__tmp_reg__, __SREG__
 1937               	 ;  0 "" 2
 1938               	 ;  1556 "FreeRTOS/Source/queue.c" 1
 1939 067c F894      		cli
 1940               	 ;  0 "" 2
 1941               	 ;  1556 "FreeRTOS/Source/queue.c" 1
 1942 067e 0F92      		push	__tmp_reg__
 1943               	 ;  0 "" 2
1558:FreeRTOS/Source/queue.c **** 						}
 1945               	.LM281:
 1946               	/* #NOAPP */
 1947 0680 8481      		ldd r24,Z+4
 1948 0682 9581      		ldd r25,Z+5
 1949 0684 0E94 0000 		call xTaskPriorityInherit
 1950 0688 F82E      		mov r15,r24
1560:FreeRTOS/Source/queue.c **** 					}
 1952               	.LM282:
 1953               	/* #APP */
 1954               	 ;  1560 "FreeRTOS/Source/queue.c" 1
 1955 068a 0F90      		pop		__tmp_reg__
 1956               	 ;  0 "" 2
 1957               	 ;  1560 "FreeRTOS/Source/queue.c" 1
 1958 068c 0FBE      		out		__SREG__, __tmp_reg__
 1959               	 ;  0 "" 2
 1960               	/* #NOAPP */
 1961               	.L144:
1569:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1963               	.LM283:
 1964 068e 6C81      		ldd r22,Y+4
 1965 0690 7D81      		ldd r23,Y+5
 1966 0692 C601      		movw r24,r12
 1967 0694 0E94 0000 		call vTaskPlaceOnEventList
1570:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1969               	.LM284:
 1970 0698 C801      		movw r24,r16
 1971 069a 0E94 0000 		call prvUnlockQueue
1571:FreeRTOS/Source/queue.c **** 				{
 1973               	.LM285:
 1974 069e 0E94 0000 		call xTaskResumeAll
1571:FreeRTOS/Source/queue.c **** 				{
 1976               	.LM286:
 1977 06a2 8111      		cpse r24,__zero_reg__
 1978 06a4 00C0      		rjmp .L145
1573:FreeRTOS/Source/queue.c **** 				}
 1980               	.LM287:
 1981 06a6 0E94 0000 		call vPortYield
 1982               	.L145:
1419:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1984               	.LM288:
 1985 06aa 91E0      		ldi r25,lo8(1)
 1986 06ac 00C0      		rjmp .L131
 1987               	.L143:
1584:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1989               	.LM289:
 1990 06ae C801      		movw r24,r16
 1991 06b0 0E94 0000 		call prvUnlockQueue
1585:FreeRTOS/Source/queue.c **** 			}
 1993               	.LM290:
 1994 06b4 0E94 0000 		call xTaskResumeAll
 1995 06b8 00C0      		rjmp .L145
 1996               	.L142:
1591:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1998               	.LM291:
 1999 06ba C801      		movw r24,r16
 2000 06bc 0E94 0000 		call prvUnlockQueue
1592:FreeRTOS/Source/queue.c **** 
 2002               	.LM292:
 2003 06c0 0E94 0000 		call xTaskResumeAll
1598:FreeRTOS/Source/queue.c **** 			{
 2005               	.LM293:
 2006 06c4 C801      		movw r24,r16
 2007 06c6 0E94 0000 		call prvIsQueueEmpty
1598:FreeRTOS/Source/queue.c **** 			{
 2009               	.LM294:
 2010 06ca 8823      		tst r24
 2011 06cc 01F0      		breq .L145
1605:FreeRTOS/Source/queue.c **** 					{
 2013               	.LM295:
 2014 06ce FF20      		tst r15
 2015 06d0 01F4      		brne .+2
 2016 06d2 00C0      		rjmp .L130
1607:FreeRTOS/Source/queue.c **** 						{
 2018               	.LM296:
 2019               	/* #APP */
 2020               	 ;  1607 "FreeRTOS/Source/queue.c" 1
 2021 06d4 0FB6      		in		__tmp_reg__, __SREG__
 2022               	 ;  0 "" 2
 2023               	 ;  1607 "FreeRTOS/Source/queue.c" 1
 2024 06d6 F894      		cli
 2025               	 ;  0 "" 2
 2026               	 ;  1607 "FreeRTOS/Source/queue.c" 1
 2027 06d8 0F92      		push	__tmp_reg__
 2028               	 ;  0 "" 2
 2029               	/* #NOAPP */
 2030               	.LBB36:
 2031               	.LBB37:
 2032               	.LBB38:
2059:FreeRTOS/Source/queue.c **** 		{
 2034               	.LM297:
 2035 06da F801      		movw r30,r16
 2036 06dc 6189      		ldd r22,Z+17
2059:FreeRTOS/Source/queue.c **** 		{
 2038               	.LM298:
 2039 06de 6623      		tst r22
 2040 06e0 01F0      		breq .L146
2061:FreeRTOS/Source/queue.c **** 		}
 2042               	.LM299:
 2043 06e2 0688      		ldd __tmp_reg__,Z+22
 2044 06e4 F789      		ldd r31,Z+23
 2045 06e6 E02D      		mov r30,__tmp_reg__
2061:FreeRTOS/Source/queue.c **** 		}
 2047               	.LM300:
 2048 06e8 8081      		ld r24,Z
 2049 06ea 64E0      		ldi r22,lo8(4)
 2050 06ec 681B      		sub r22,r24
 2051               	.L146:
 2052               	.LBE38:
 2053               	.LBE37:
1617:FreeRTOS/Source/queue.c **** 						}
 2055               	.LM301:
 2056 06ee D801      		movw r26,r16
 2057 06f0 1496      		adiw r26,4
 2058 06f2 8D91      		ld r24,X+
 2059 06f4 9C91      		ld r25,X
 2060 06f6 0E94 0000 		call vTaskPriorityDisinheritAfterTimeout
 2061 06fa 00C0      		rjmp .L159
 2062               	.LBE36:
 2081               	.Lscope13:
 2087               	.global	xQueuePeek
 2089               	xQueuePeek:
1637:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2091               	.LM302:
 2092               	.LFBB14:
 2093 06fc CF92      		push r12
 2094 06fe DF92      		push r13
 2095 0700 EF92      		push r14
 2096 0702 FF92      		push r15
 2097 0704 0F93      		push r16
 2098 0706 1F93      		push r17
 2099 0708 CF93      		push r28
 2100 070a DF93      		push r29
 2101 070c 00D0      		rcall .
 2102 070e 00D0      		rcall .
 2103 0710 0F92      		push __tmp_reg__
 2104 0712 CDB7      		in r28,__SP_L__
 2105 0714 DEB7      		in r29,__SP_H__
 2106               	/* prologue: function */
 2107               	/* frame size = 5 */
 2108               	/* stack size = 13 */
 2109               	.L__stack_usage = 13
 2110 0716 8C01      		movw r16,r24
 2111 0718 7B01      		movw r14,r22
 2112 071a 5D83      		std Y+5,r21
 2113 071c 4C83      		std Y+4,r20
1638:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 2115               	.LM303:
 2116 071e 80E0      		ldi r24,0
1745:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 2118               	.LM304:
 2119 0720 6801      		movw r12,r16
 2120 0722 91E1      		ldi r25,17
 2121 0724 C90E      		add r12,r25
 2122 0726 D11C      		adc r13,__zero_reg__
 2123               	.L161:
1663:FreeRTOS/Source/queue.c **** 		{
 2125               	.LM305:
 2126               	/* #APP */
 2127               	 ;  1663 "FreeRTOS/Source/queue.c" 1
 2128 0728 0FB6      		in		__tmp_reg__, __SREG__
 2129               	 ;  0 "" 2
 2130               	 ;  1663 "FreeRTOS/Source/queue.c" 1
 2131 072a F894      		cli
 2132               	 ;  0 "" 2
 2133               	 ;  1663 "FreeRTOS/Source/queue.c" 1
 2134 072c 0F92      		push	__tmp_reg__
 2135               	 ;  0 "" 2
 2136               	/* #NOAPP */
 2137               	.LBB39:
1665:FreeRTOS/Source/queue.c **** 
 2139               	.LM306:
 2140 072e F801      		movw r30,r16
 2141 0730 928D      		ldd r25,Z+26
1669:FreeRTOS/Source/queue.c **** 			{
 2143               	.LM307:
 2144 0732 9923      		tst r25
 2145 0734 01F0      		breq .L162
1674:FreeRTOS/Source/queue.c **** 
 2147               	.LM308:
 2148 0736 C680      		ldd r12,Z+6
 2149 0738 D780      		ldd r13,Z+7
1676:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
 2151               	.LM309:
 2152 073a B701      		movw r22,r14
 2153 073c C801      		movw r24,r16
 2154 073e 0E94 0000 		call prvCopyDataFromQueue
1680:FreeRTOS/Source/queue.c **** 
 2156               	.LM310:
 2157 0742 F801      		movw r30,r16
 2158 0744 D782      		std Z+7,r13
 2159 0746 C682      		std Z+6,r12
1684:FreeRTOS/Source/queue.c **** 				{
 2161               	.LM311:
 2162 0748 8189      		ldd r24,Z+17
1684:FreeRTOS/Source/queue.c **** 				{
 2164               	.LM312:
 2165 074a 8823      		tst r24
 2166 074c 01F0      		breq .L164
1686:FreeRTOS/Source/queue.c **** 					{
 2168               	.LM313:
 2169 074e C801      		movw r24,r16
 2170 0750 4196      		adiw r24,17
 2171 0752 0E94 0000 		call xTaskRemoveFromEventList
1686:FreeRTOS/Source/queue.c **** 					{
 2173               	.LM314:
 2174 0756 8111      		cpse r24,__zero_reg__
1689:FreeRTOS/Source/queue.c **** 					}
 2176               	.LM315:
 2177 0758 0E94 0000 		call vPortYield
 2178               	.L164:
1701:FreeRTOS/Source/queue.c **** 				return pdPASS;
 2180               	.LM316:
 2181               	/* #APP */
 2182               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 2183 075c 0F90      		pop		__tmp_reg__
 2184               	 ;  0 "" 2
 2185               	 ;  1701 "FreeRTOS/Source/queue.c" 1
 2186 075e 0FBE      		out		__SREG__, __tmp_reg__
 2187               	 ;  0 "" 2
1702:FreeRTOS/Source/queue.c **** 			}
 2189               	.LM317:
 2190               	/* #NOAPP */
 2191 0760 81E0      		ldi r24,lo8(1)
 2192               	.L160:
 2193               	/* epilogue start */
 2194               	.LBE39:
1782:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2196               	.LM318:
 2197 0762 0F90      		pop __tmp_reg__
 2198 0764 0F90      		pop __tmp_reg__
 2199 0766 0F90      		pop __tmp_reg__
 2200 0768 0F90      		pop __tmp_reg__
 2201 076a 0F90      		pop __tmp_reg__
 2202 076c DF91      		pop r29
 2203 076e CF91      		pop r28
 2204 0770 1F91      		pop r17
 2205 0772 0F91      		pop r16
 2206 0774 FF90      		pop r15
 2207 0776 EF90      		pop r14
 2208 0778 DF90      		pop r13
 2209 077a CF90      		pop r12
 2210 077c 0895      		ret
 2211               	.L162:
 2212               	.LBB40:
1706:FreeRTOS/Source/queue.c **** 				{
 2214               	.LM319:
 2215 077e 2C81      		ldd r18,Y+4
 2216 0780 3D81      		ldd r19,Y+5
 2217 0782 232B      		or r18,r19
 2218 0784 01F4      		brne .L167
1710:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
 2220               	.LM320:
 2221               	/* #APP */
 2222               	 ;  1710 "FreeRTOS/Source/queue.c" 1
 2223 0786 0F90      		pop		__tmp_reg__
 2224               	 ;  0 "" 2
 2225               	 ;  1710 "FreeRTOS/Source/queue.c" 1
 2226 0788 0FBE      		out		__SREG__, __tmp_reg__
 2227               	 ;  0 "" 2
 2228               	/* #NOAPP */
 2229               	.L181:
 2230               	.LBE40:
1774:FreeRTOS/Source/queue.c **** 			}
 2232               	.LM321:
 2233 078a 80E0      		ldi r24,0
 2234 078c 00C0      		rjmp .L160
 2235               	.L167:
 2236               	.LBB41:
1714:FreeRTOS/Source/queue.c **** 				{
 2238               	.LM322:
 2239 078e 8111      		cpse r24,__zero_reg__
 2240 0790 00C0      		rjmp .L168
1719:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 2242               	.LM323:
 2243 0792 CE01      		movw r24,r28
 2244 0794 0196      		adiw r24,1
 2245 0796 0E94 0000 		call vTaskInternalSetTimeOutState
 2246               	.L168:
 2247               	.LBE41:
1729:FreeRTOS/Source/queue.c **** 
 2249               	.LM324:
 2250               	/* #APP */
 2251               	 ;  1729 "FreeRTOS/Source/queue.c" 1
 2252 079a 0F90      		pop		__tmp_reg__
 2253               	 ;  0 "" 2
 2254               	 ;  1729 "FreeRTOS/Source/queue.c" 1
 2255 079c 0FBE      		out		__SREG__, __tmp_reg__
 2256               	 ;  0 "" 2
1734:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 2258               	.LM325:
 2259               	/* #NOAPP */
 2260 079e 0E94 0000 		call vTaskSuspendAll
1735:FreeRTOS/Source/queue.c **** 
 2262               	.LM326:
 2263               	/* #APP */
 2264               	 ;  1735 "FreeRTOS/Source/queue.c" 1
 2265 07a2 0FB6      		in		__tmp_reg__, __SREG__
 2266               	 ;  0 "" 2
 2267               	 ;  1735 "FreeRTOS/Source/queue.c" 1
 2268 07a4 F894      		cli
 2269               	 ;  0 "" 2
 2270               	 ;  1735 "FreeRTOS/Source/queue.c" 1
 2271 07a6 0F92      		push	__tmp_reg__
 2272               	 ;  0 "" 2
 2273               	/* #NOAPP */
 2274 07a8 F801      		movw r30,r16
 2275 07aa 858D      		ldd r24,Z+29
 2276 07ac 8F3F      		cpi r24,lo8(-1)
 2277 07ae 01F4      		brne .L169
1735:FreeRTOS/Source/queue.c **** 
 2279               	.LM327:
 2280 07b0 158E      		std Z+29,__zero_reg__
 2281               	.L169:
1735:FreeRTOS/Source/queue.c **** 
 2283               	.LM328:
 2284 07b2 F801      		movw r30,r16
 2285 07b4 868D      		ldd r24,Z+30
 2286 07b6 8F3F      		cpi r24,lo8(-1)
 2287 07b8 01F4      		brne .L170
1735:FreeRTOS/Source/queue.c **** 
 2289               	.LM329:
 2290 07ba 168E      		std Z+30,__zero_reg__
 2291               	.L170:
1735:FreeRTOS/Source/queue.c **** 
 2293               	.LM330:
 2294               	/* #APP */
 2295               	 ;  1735 "FreeRTOS/Source/queue.c" 1
 2296 07bc 0F90      		pop		__tmp_reg__
 2297               	 ;  0 "" 2
 2298               	 ;  1735 "FreeRTOS/Source/queue.c" 1
 2299 07be 0FBE      		out		__SREG__, __tmp_reg__
 2300               	 ;  0 "" 2
1738:FreeRTOS/Source/queue.c **** 		{
 2302               	.LM331:
 2303               	/* #NOAPP */
 2304 07c0 BE01      		movw r22,r28
 2305 07c2 6C5F      		subi r22,-4
 2306 07c4 7F4F      		sbci r23,-1
 2307 07c6 CE01      		movw r24,r28
 2308 07c8 0196      		adiw r24,1
 2309 07ca 0E94 0000 		call xTaskCheckForTimeOut
1738:FreeRTOS/Source/queue.c **** 		{
 2311               	.LM332:
 2312 07ce 8111      		cpse r24,__zero_reg__
 2313 07d0 00C0      		rjmp .L171
1742:FreeRTOS/Source/queue.c **** 			{
 2315               	.LM333:
 2316 07d2 C801      		movw r24,r16
 2317 07d4 0E94 0000 		call prvIsQueueEmpty
1742:FreeRTOS/Source/queue.c **** 			{
 2319               	.LM334:
 2320 07d8 8823      		tst r24
 2321 07da 01F0      		breq .L172
1745:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 2323               	.LM335:
 2324 07dc 6C81      		ldd r22,Y+4
 2325 07de 7D81      		ldd r23,Y+5
 2326 07e0 C601      		movw r24,r12
 2327 07e2 0E94 0000 		call vTaskPlaceOnEventList
1746:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2329               	.LM336:
 2330 07e6 C801      		movw r24,r16
 2331 07e8 0E94 0000 		call prvUnlockQueue
1747:FreeRTOS/Source/queue.c **** 				{
 2333               	.LM337:
 2334 07ec 0E94 0000 		call xTaskResumeAll
1747:FreeRTOS/Source/queue.c **** 				{
 2336               	.LM338:
 2337 07f0 8111      		cpse r24,__zero_reg__
 2338 07f2 00C0      		rjmp .L174
1749:FreeRTOS/Source/queue.c **** 				}
 2340               	.LM339:
 2341 07f4 0E94 0000 		call vPortYield
 2342               	.L174:
1637:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2344               	.LM340:
 2345 07f8 81E0      		ldi r24,lo8(1)
 2346 07fa 00C0      		rjmp .L161
 2347               	.L172:
1760:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 2349               	.LM341:
 2350 07fc C801      		movw r24,r16
 2351 07fe 0E94 0000 		call prvUnlockQueue
1761:FreeRTOS/Source/queue.c **** 			}
 2353               	.LM342:
 2354 0802 0E94 0000 		call xTaskResumeAll
 2355 0806 00C0      		rjmp .L174
 2356               	.L171:
1768:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 2358               	.LM343:
 2359 0808 C801      		movw r24,r16
 2360 080a 0E94 0000 		call prvUnlockQueue
1769:FreeRTOS/Source/queue.c **** 
 2362               	.LM344:
 2363 080e 0E94 0000 		call xTaskResumeAll
1771:FreeRTOS/Source/queue.c **** 			{
 2365               	.LM345:
 2366 0812 C801      		movw r24,r16
 2367 0814 0E94 0000 		call prvIsQueueEmpty
1771:FreeRTOS/Source/queue.c **** 			{
 2369               	.LM346:
 2370 0818 8823      		tst r24
 2371 081a 01F0      		breq .L174
 2372 081c 00C0      		rjmp .L181
 2388               	.Lscope14:
 2394               	.global	xQueueReceiveFromISR
 2396               	xQueueReceiveFromISR:
1786:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2398               	.LM347:
 2399               	.LFBB15:
 2400 081e EF92      		push r14
 2401 0820 FF92      		push r15
 2402 0822 0F93      		push r16
 2403 0824 1F93      		push r17
 2404 0826 CF93      		push r28
 2405 0828 DF93      		push r29
 2406               	/* prologue: function */
 2407               	/* frame size = 0 */
 2408               	/* stack size = 6 */
 2409               	.L__stack_usage = 6
 2410 082a EC01      		movw r28,r24
 2411 082c 8A01      		movw r16,r20
 2412               	.LBB42:
1812:FreeRTOS/Source/queue.c **** 
 2414               	.LM348:
 2415 082e EA8C      		ldd r14,Y+26
1866:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 2417               	.LM349:
 2418 0830 80E0      		ldi r24,0
1815:FreeRTOS/Source/queue.c **** 		{
 2420               	.LM350:
 2421 0832 EE20      		tst r14
 2422 0834 01F0      		breq .L182
 2423               	.LBB43:
1817:FreeRTOS/Source/queue.c **** 
 2425               	.LM351:
 2426 0836 FD8C      		ldd r15,Y+29
1821:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2428               	.LM352:
 2429 0838 CE01      		movw r24,r28
 2430 083a 0E94 0000 		call prvCopyDataFromQueue
1822:FreeRTOS/Source/queue.c **** 
 2432               	.LM353:
 2433 083e EA94      		dec r14
1822:FreeRTOS/Source/queue.c **** 
 2435               	.LM354:
 2436 0840 EA8E      		std Y+26,r14
1828:FreeRTOS/Source/queue.c **** 			{
 2438               	.LM355:
 2439 0842 8FEF      		ldi r24,lo8(-1)
 2440 0844 F812      		cpse r15,r24
 2441 0846 00C0      		rjmp .L184
1830:FreeRTOS/Source/queue.c **** 				{
 2443               	.LM356:
 2444 0848 8885      		ldd r24,Y+8
1830:FreeRTOS/Source/queue.c **** 				{
 2446               	.LM357:
 2447 084a 8111      		cpse r24,__zero_reg__
 2448 084c 00C0      		rjmp .L185
 2449               	.L194:
1862:FreeRTOS/Source/queue.c **** 		}
 2451               	.LM358:
 2452 084e 81E0      		ldi r24,lo8(1)
 2453 0850 00C0      		rjmp .L182
 2454               	.L185:
1832:FreeRTOS/Source/queue.c **** 					{
 2456               	.LM359:
 2457 0852 CE01      		movw r24,r28
 2458 0854 0896      		adiw r24,8
 2459 0856 0E94 0000 		call xTaskRemoveFromEventList
1832:FreeRTOS/Source/queue.c **** 					{
 2461               	.LM360:
 2462 085a 8823      		tst r24
 2463 085c 01F0      		breq .L194
1836:FreeRTOS/Source/queue.c **** 						{
 2465               	.LM361:
 2466 085e 0115      		cp r16,__zero_reg__
 2467 0860 1105      		cpc r17,__zero_reg__
 2468 0862 01F0      		breq .L194
1838:FreeRTOS/Source/queue.c **** 						}
 2470               	.LM362:
 2471 0864 81E0      		ldi r24,lo8(1)
 2472 0866 F801      		movw r30,r16
 2473 0868 8083      		st Z,r24
 2474               	.L182:
 2475               	/* epilogue start */
 2476               	.LBE43:
 2477               	.LBE42:
1873:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2479               	.LM363:
 2480 086a DF91      		pop r29
 2481 086c CF91      		pop r28
 2482 086e 1F91      		pop r17
 2483 0870 0F91      		pop r16
 2484 0872 FF90      		pop r15
 2485 0874 EF90      		pop r14
 2486 0876 0895      		ret
 2487               	.L184:
 2488               	.LBB45:
 2489               	.LBB44:
1859:FreeRTOS/Source/queue.c **** 			}
 2491               	.LM364:
 2492 0878 F394      		inc r15
1859:FreeRTOS/Source/queue.c **** 			}
 2494               	.LM365:
 2495 087a FD8E      		std Y+29,r15
 2496 087c 00C0      		rjmp .L194
 2497               	.LBE44:
 2498               	.LBE45:
 2515               	.Lscope15:
 2520               	.global	xQueuePeekFromISR
 2522               	xQueuePeekFromISR:
1877:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2524               	.LM366:
 2525               	.LFBB16:
 2526 087e 0F93      		push r16
 2527 0880 1F93      		push r17
 2528 0882 CF93      		push r28
 2529 0884 DF93      		push r29
 2530               	/* prologue: function */
 2531               	/* frame size = 0 */
 2532               	/* stack size = 4 */
 2533               	.L__stack_usage = 4
 2534 0886 EC01      		movw r28,r24
1906:FreeRTOS/Source/queue.c **** 		{
 2536               	.LM367:
 2537 0888 8A8D      		ldd r24,Y+26
1906:FreeRTOS/Source/queue.c **** 		{
 2539               	.LM368:
 2540 088a 8823      		tst r24
 2541 088c 01F0      		breq .L197
1912:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2543               	.LM369:
 2544 088e 0E81      		ldd r16,Y+6
 2545 0890 1F81      		ldd r17,Y+7
1913:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2547               	.LM370:
 2548 0892 CE01      		movw r24,r28
 2549 0894 0E94 0000 		call prvCopyDataFromQueue
1914:FreeRTOS/Source/queue.c **** 
 2551               	.LM371:
 2552 0898 1F83      		std Y+7,r17
 2553 089a 0E83      		std Y+6,r16
1916:FreeRTOS/Source/queue.c **** 		}
 2555               	.LM372:
 2556 089c 81E0      		ldi r24,lo8(1)
 2557               	.L195:
 2558               	/* epilogue start */
1927:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2560               	.LM373:
 2561 089e DF91      		pop r29
 2562 08a0 CF91      		pop r28
 2563 08a2 1F91      		pop r17
 2564 08a4 0F91      		pop r16
 2565 08a6 0895      		ret
 2566               	.L197:
1920:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 2568               	.LM374:
 2569 08a8 80E0      		ldi r24,0
1926:FreeRTOS/Source/queue.c **** }
 2571               	.LM375:
 2572 08aa 00C0      		rjmp .L195
 2578               	.Lscope16:
 2582               	.global	uxQueueMessagesWaiting
 2584               	uxQueueMessagesWaiting:
1931:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2586               	.LM376:
 2587               	.LFBB17:
 2588               	/* prologue: function */
 2589               	/* frame size = 0 */
 2590               	/* stack size = 0 */
 2591               	.L__stack_usage = 0
1936:FreeRTOS/Source/queue.c **** 	{
 2593               	.LM377:
 2594               	/* #APP */
 2595               	 ;  1936 "FreeRTOS/Source/queue.c" 1
 2596 08ac 0FB6      		in		__tmp_reg__, __SREG__
 2597               	 ;  0 "" 2
 2598               	 ;  1936 "FreeRTOS/Source/queue.c" 1
 2599 08ae F894      		cli
 2600               	 ;  0 "" 2
 2601               	 ;  1936 "FreeRTOS/Source/queue.c" 1
 2602 08b0 0F92      		push	__tmp_reg__
 2603               	 ;  0 "" 2
1938:FreeRTOS/Source/queue.c **** 	}
 2605               	.LM378:
 2606               	/* #NOAPP */
 2607 08b2 FC01      		movw r30,r24
 2608 08b4 828D      		ldd r24,Z+26
1940:FreeRTOS/Source/queue.c **** 
 2610               	.LM379:
 2611               	/* #APP */
 2612               	 ;  1940 "FreeRTOS/Source/queue.c" 1
 2613 08b6 0F90      		pop		__tmp_reg__
 2614               	 ;  0 "" 2
 2615               	 ;  1940 "FreeRTOS/Source/queue.c" 1
 2616 08b8 0FBE      		out		__SREG__, __tmp_reg__
 2617               	 ;  0 "" 2
 2618               	/* #NOAPP */
 2619               	/* epilogue start */
1943:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2621               	.LM380:
 2622 08ba 0895      		ret
 2627               	.Lscope17:
 2631               	.global	uxQueueSpacesAvailable
 2633               	uxQueueSpacesAvailable:
1947:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2635               	.LM381:
 2636               	.LFBB18:
 2637               	/* prologue: function */
 2638               	/* frame size = 0 */
 2639               	/* stack size = 0 */
 2640               	.L__stack_usage = 0
 2641 08bc FC01      		movw r30,r24
1953:FreeRTOS/Source/queue.c **** 	{
 2643               	.LM382:
 2644               	/* #APP */
 2645               	 ;  1953 "FreeRTOS/Source/queue.c" 1
 2646 08be 0FB6      		in		__tmp_reg__, __SREG__
 2647               	 ;  0 "" 2
 2648               	 ;  1953 "FreeRTOS/Source/queue.c" 1
 2649 08c0 F894      		cli
 2650               	 ;  0 "" 2
 2651               	 ;  1953 "FreeRTOS/Source/queue.c" 1
 2652 08c2 0F92      		push	__tmp_reg__
 2653               	 ;  0 "" 2
1955:FreeRTOS/Source/queue.c **** 	}
 2655               	.LM383:
 2656               	/* #NOAPP */
 2657 08c4 928D      		ldd r25,Z+26
1957:FreeRTOS/Source/queue.c **** 
 2659               	.LM384:
 2660               	/* #APP */
 2661               	 ;  1957 "FreeRTOS/Source/queue.c" 1
 2662 08c6 0F90      		pop		__tmp_reg__
 2663               	 ;  0 "" 2
 2664               	 ;  1957 "FreeRTOS/Source/queue.c" 1
 2665 08c8 0FBE      		out		__SREG__, __tmp_reg__
 2666               	 ;  0 "" 2
1955:FreeRTOS/Source/queue.c **** 	}
 2668               	.LM385:
 2669               	/* #NOAPP */
 2670 08ca 838D      		ldd r24,Z+27
1960:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2672               	.LM386:
 2673 08cc 891B      		sub r24,r25
 2674               	/* epilogue start */
 2675 08ce 0895      		ret
 2677               	.Lscope18:
 2681               	.global	uxQueueMessagesWaitingFromISR
 2683               	uxQueueMessagesWaitingFromISR:
1964:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 2685               	.LM387:
 2686               	.LFBB19:
 2687               	/* prologue: function */
 2688               	/* frame size = 0 */
 2689               	/* stack size = 0 */
 2690               	.L__stack_usage = 0
1969:FreeRTOS/Source/queue.c **** 
 2692               	.LM388:
 2693 08d0 FC01      		movw r30,r24
 2694 08d2 828D      		ldd r24,Z+26
 2695               	/* epilogue start */
1972:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2697               	.LM389:
 2698 08d4 0895      		ret
 2703               	.Lscope19:
 2707               	.global	vQueueDelete
 2709               	vQueueDelete:
1976:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2711               	.LM390:
 2712               	.LFBB20:
 2713               	/* prologue: function */
 2714               	/* frame size = 0 */
 2715               	/* stack size = 0 */
 2716               	.L__stack_usage = 0
1992:FreeRTOS/Source/queue.c **** 	}
 2718               	.LM391:
 2719 08d6 0C94 0000 		jmp vPortFree
 2721               	.Lscope20:
 2725               	.global	xQueueIsQueueEmptyFromISR
 2727               	xQueueIsQueueEmptyFromISR:
2313:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 2729               	.LM392:
 2730               	.LFBB21:
 2731               	/* prologue: function */
 2732               	/* frame size = 0 */
 2733               	/* stack size = 0 */
 2734               	.L__stack_usage = 0
2318:FreeRTOS/Source/queue.c **** 	{
 2736               	.LM393:
 2737 08da FC01      		movw r30,r24
 2738 08dc 928D      		ldd r25,Z+26
2318:FreeRTOS/Source/queue.c **** 	{
 2740               	.LM394:
 2741 08de 81E0      		ldi r24,lo8(1)
 2742 08e0 9111      		cpse r25,__zero_reg__
 2743 08e2 80E0      		ldi r24,0
 2744               	.L203:
 2745               	/* epilogue start */
2328:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2747               	.LM395:
 2748 08e4 0895      		ret
 2750               	.Lscope21:
 2754               	.global	xQueueIsQueueFullFromISR
 2756               	xQueueIsQueueFullFromISR:
2347:FreeRTOS/Source/queue.c **** 
2348:FreeRTOS/Source/queue.c **** 	return xReturn;
2349:FreeRTOS/Source/queue.c **** }
2350:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2351:FreeRTOS/Source/queue.c **** 
2352:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2353:FreeRTOS/Source/queue.c **** {
 2758               	.LM396:
 2759               	.LFBB22:
 2760               	/* prologue: function */
 2761               	/* frame size = 0 */
 2762               	/* stack size = 0 */
 2763               	.L__stack_usage = 0
 2764 08e6 FC01      		movw r30,r24
2354:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2355:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
2356:FreeRTOS/Source/queue.c **** 
2357:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2358:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2766               	.LM397:
 2767 08e8 928D      		ldd r25,Z+26
 2769               	.LM398:
 2770 08ea 81E0      		ldi r24,lo8(1)
 2771 08ec 238D      		ldd r18,Z+27
 2772 08ee 2913      		cpse r18,r25
 2773 08f0 80E0      		ldi r24,0
 2774               	.L208:
 2775               	/* epilogue start */
2359:FreeRTOS/Source/queue.c **** 	{
2360:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2361:FreeRTOS/Source/queue.c **** 	}
2362:FreeRTOS/Source/queue.c **** 	else
2363:FreeRTOS/Source/queue.c **** 	{
2364:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2365:FreeRTOS/Source/queue.c **** 	}
2366:FreeRTOS/Source/queue.c **** 
2367:FreeRTOS/Source/queue.c **** 	return xReturn;
2368:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2777               	.LM399:
 2778 08f2 0895      		ret
 2780               	.Lscope22:
 2786               	.global	xQueueCRSend
 2788               	xQueueCRSend:
2369:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2370:FreeRTOS/Source/queue.c **** 
2371:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2372:FreeRTOS/Source/queue.c **** 
2373:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2374:FreeRTOS/Source/queue.c **** 	{
 2790               	.LM400:
 2791               	.LFBB23:
 2792 08f4 CF93      		push r28
 2793 08f6 DF93      		push r29
 2794               	/* prologue: function */
 2795               	/* frame size = 0 */
 2796               	/* stack size = 2 */
 2797               	.L__stack_usage = 2
 2798 08f8 EC01      		movw r28,r24
 2799 08fa CA01      		movw r24,r20
2375:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2376:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2377:FreeRTOS/Source/queue.c **** 
2378:FreeRTOS/Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2379:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2380:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2381:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2801               	.LM401:
 2802               	/* #APP */
 2803               	 ;  2381 "FreeRTOS/Source/queue.c" 1
 2804 08fc F894      		cli
 2805               	 ;  0 "" 2
 2806               	/* #NOAPP */
 2807               	.LBB48:
 2808               	.LBB49:
2335:FreeRTOS/Source/queue.c **** 	{
 2810               	.LM402:
 2811               	/* #APP */
 2812               	 ;  2335 "FreeRTOS/Source/queue.c" 1
 2813 08fe 0FB6      		in		__tmp_reg__, __SREG__
 2814               	 ;  0 "" 2
 2815               	 ;  2335 "FreeRTOS/Source/queue.c" 1
 2816 0900 F894      		cli
 2817               	 ;  0 "" 2
 2818               	 ;  2335 "FreeRTOS/Source/queue.c" 1
 2819 0902 0F92      		push	__tmp_reg__
 2820               	 ;  0 "" 2
2337:FreeRTOS/Source/queue.c **** 		{
 2822               	.LM403:
 2823               	/* #NOAPP */
 2824 0904 3A8D      		ldd r19,Y+26
2337:FreeRTOS/Source/queue.c **** 		{
 2826               	.LM404:
 2827 0906 2B8D      		ldd r18,Y+27
2346:FreeRTOS/Source/queue.c **** 
 2829               	.LM405:
 2830               	/* #APP */
 2831               	 ;  2346 "FreeRTOS/Source/queue.c" 1
 2832 0908 0F90      		pop		__tmp_reg__
 2833               	 ;  0 "" 2
 2834               	 ;  2346 "FreeRTOS/Source/queue.c" 1
 2835 090a 0FBE      		out		__SREG__, __tmp_reg__
 2836               	 ;  0 "" 2
 2837               	/* #NOAPP */
 2838               	.LBE49:
 2839               	.LBE48:
2382:FreeRTOS/Source/queue.c **** 		{
2383:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 2841               	.LM406:
 2842 090c 3213      		cpse r19,r18
 2843 090e 00C0      		rjmp .L210
2384:FreeRTOS/Source/queue.c **** 			{
2385:FreeRTOS/Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2386:FreeRTOS/Source/queue.c **** 				posting? */
2387:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2845               	.LM407:
 2846 0910 0097      		sbiw r24,0
 2847 0912 01F0      		breq .L211
2388:FreeRTOS/Source/queue.c **** 				{
2389:FreeRTOS/Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2390:FreeRTOS/Source/queue.c **** 					return indicating that we need to block. */
2391:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 2849               	.LM408:
 2850 0914 BE01      		movw r22,r28
 2851 0916 685F      		subi r22,-8
 2852 0918 7F4F      		sbci r23,-1
 2853 091a 0E94 0000 		call vCoRoutineAddToDelayedList
2392:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2855               	.LM409:
 2856               	/* #APP */
 2857               	 ;  2392 "FreeRTOS/Source/queue.c" 1
 2858 091e 7894      		sei
 2859               	 ;  0 "" 2
2393:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 2861               	.LM410:
 2862               	/* #NOAPP */
 2863 0920 8CEF      		ldi r24,lo8(-4)
 2864               	.L209:
 2865               	/* epilogue start */
2394:FreeRTOS/Source/queue.c **** 				}
2395:FreeRTOS/Source/queue.c **** 				else
2396:FreeRTOS/Source/queue.c **** 				{
2397:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
2398:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
2399:FreeRTOS/Source/queue.c **** 				}
2400:FreeRTOS/Source/queue.c **** 			}
2401:FreeRTOS/Source/queue.c **** 		}
2402:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
2403:FreeRTOS/Source/queue.c **** 
2404:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
2405:FreeRTOS/Source/queue.c **** 		{
2406:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2407:FreeRTOS/Source/queue.c **** 			{
2408:FreeRTOS/Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2409:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2410:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2411:FreeRTOS/Source/queue.c **** 
2412:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2413:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2414:FreeRTOS/Source/queue.c **** 				{
2415:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2416:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2417:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2418:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2419:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2420:FreeRTOS/Source/queue.c **** 					{
2421:FreeRTOS/Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2422:FreeRTOS/Source/queue.c **** 						that a yield might be appropriate. */
2423:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2424:FreeRTOS/Source/queue.c **** 					}
2425:FreeRTOS/Source/queue.c **** 					else
2426:FreeRTOS/Source/queue.c **** 					{
2427:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2428:FreeRTOS/Source/queue.c **** 					}
2429:FreeRTOS/Source/queue.c **** 				}
2430:FreeRTOS/Source/queue.c **** 				else
2431:FreeRTOS/Source/queue.c **** 				{
2432:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2433:FreeRTOS/Source/queue.c **** 				}
2434:FreeRTOS/Source/queue.c **** 			}
2435:FreeRTOS/Source/queue.c **** 			else
2436:FreeRTOS/Source/queue.c **** 			{
2437:FreeRTOS/Source/queue.c **** 				xReturn = errQUEUE_FULL;
2438:FreeRTOS/Source/queue.c **** 			}
2439:FreeRTOS/Source/queue.c **** 		}
2440:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
2441:FreeRTOS/Source/queue.c **** 
2442:FreeRTOS/Source/queue.c **** 		return xReturn;
2443:FreeRTOS/Source/queue.c **** 	}
 2867               	.LM411:
 2868 0922 DF91      		pop r29
 2869 0924 CF91      		pop r28
 2870 0926 0895      		ret
 2871               	.L211:
2397:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 2873               	.LM412:
 2874               	/* #APP */
 2875               	 ;  2397 "FreeRTOS/Source/queue.c" 1
 2876 0928 7894      		sei
 2877               	 ;  0 "" 2
2398:FreeRTOS/Source/queue.c **** 				}
 2879               	.LM413:
 2880               	/* #NOAPP */
 2881 092a 80E0      		ldi r24,0
 2882 092c 00C0      		rjmp .L209
 2883               	.L210:
2402:FreeRTOS/Source/queue.c **** 
 2885               	.LM414:
 2886               	/* #APP */
 2887               	 ;  2402 "FreeRTOS/Source/queue.c" 1
 2888 092e 7894      		sei
 2889               	 ;  0 "" 2
2404:FreeRTOS/Source/queue.c **** 		{
 2891               	.LM415:
 2892               	 ;  2404 "FreeRTOS/Source/queue.c" 1
 2893 0930 F894      		cli
 2894               	 ;  0 "" 2
2406:FreeRTOS/Source/queue.c **** 			{
 2896               	.LM416:
 2897               	/* #NOAPP */
 2898 0932 8A8D      		ldd r24,Y+26
2406:FreeRTOS/Source/queue.c **** 			{
 2900               	.LM417:
 2901 0934 8217      		cp r24,r18
 2902 0936 00F4      		brsh .L216
2409:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
 2904               	.LM418:
 2905 0938 40E0      		ldi r20,0
 2906 093a CE01      		movw r24,r28
 2907 093c 0E94 0000 		call prvCopyDataToQueue
2413:FreeRTOS/Source/queue.c **** 				{
 2909               	.LM419:
 2910 0940 8989      		ldd r24,Y+17
2413:FreeRTOS/Source/queue.c **** 				{
 2912               	.LM420:
 2913 0942 8111      		cpse r24,__zero_reg__
 2914 0944 00C0      		rjmp .L214
 2915               	.L215:
2410:FreeRTOS/Source/queue.c **** 
 2917               	.LM421:
 2918 0946 81E0      		ldi r24,lo8(1)
 2919               	.L213:
2440:FreeRTOS/Source/queue.c **** 
 2921               	.LM422:
 2922               	/* #APP */
 2923               	 ;  2440 "FreeRTOS/Source/queue.c" 1
 2924 0948 7894      		sei
 2925               	 ;  0 "" 2
2442:FreeRTOS/Source/queue.c **** 	}
 2927               	.LM423:
 2928               	/* #NOAPP */
 2929 094a 00C0      		rjmp .L209
 2930               	.L214:
2419:FreeRTOS/Source/queue.c **** 					{
 2932               	.LM424:
 2933 094c CE01      		movw r24,r28
 2934 094e 4196      		adiw r24,17
 2935 0950 0E94 0000 		call xCoRoutineRemoveFromEventList
2419:FreeRTOS/Source/queue.c **** 					{
 2937               	.LM425:
 2938 0954 8823      		tst r24
 2939 0956 01F0      		breq .L215
2423:FreeRTOS/Source/queue.c **** 					}
 2941               	.LM426:
 2942 0958 8BEF      		ldi r24,lo8(-5)
 2943 095a 00C0      		rjmp .L213
 2944               	.L216:
2437:FreeRTOS/Source/queue.c **** 			}
 2946               	.LM427:
 2947 095c 80E0      		ldi r24,0
 2948 095e 00C0      		rjmp .L213
 2950               	.Lscope23:
 2956               	.global	xQueueCRReceive
 2958               	xQueueCRReceive:
2444:FreeRTOS/Source/queue.c **** 
2445:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2446:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2447:FreeRTOS/Source/queue.c **** 
2448:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2449:FreeRTOS/Source/queue.c **** 
2450:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2451:FreeRTOS/Source/queue.c **** 	{
 2960               	.LM428:
 2961               	.LFBB24:
 2962 0960 CF93      		push r28
 2963 0962 DF93      		push r29
 2964               	/* prologue: function */
 2965               	/* frame size = 0 */
 2966               	/* stack size = 2 */
 2967               	.L__stack_usage = 2
 2968 0964 EC01      		movw r28,r24
 2969 0966 9B01      		movw r18,r22
 2970 0968 CA01      		movw r24,r20
2452:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2453:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2454:FreeRTOS/Source/queue.c **** 
2455:FreeRTOS/Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2456:FreeRTOS/Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2457:FreeRTOS/Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2458:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
 2972               	.LM429:
 2973               	/* #APP */
 2974               	 ;  2458 "FreeRTOS/Source/queue.c" 1
 2975 096a F894      		cli
 2976               	 ;  0 "" 2
2459:FreeRTOS/Source/queue.c **** 		{
2460:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2978               	.LM430:
 2979               	/* #NOAPP */
 2980 096c 4A8D      		ldd r20,Y+26
 2982               	.LM431:
 2983 096e 4111      		cpse r20,__zero_reg__
 2984 0970 00C0      		rjmp .L221
2461:FreeRTOS/Source/queue.c **** 			{
2462:FreeRTOS/Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2463:FreeRTOS/Source/queue.c **** 				leave with nothing? */
2464:FreeRTOS/Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 2986               	.LM432:
 2987 0972 0097      		sbiw r24,0
 2988 0974 01F0      		breq .L222
2465:FreeRTOS/Source/queue.c **** 				{
2466:FreeRTOS/Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2467:FreeRTOS/Source/queue.c **** 					indicating that we need to block. */
2468:FreeRTOS/Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 2990               	.LM433:
 2991 0976 BE01      		movw r22,r28
 2992 0978 6F5E      		subi r22,-17
 2993 097a 7F4F      		sbci r23,-1
 2994 097c 0E94 0000 		call vCoRoutineAddToDelayedList
2469:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
 2996               	.LM434:
 2997               	/* #APP */
 2998               	 ;  2469 "FreeRTOS/Source/queue.c" 1
 2999 0980 7894      		sei
 3000               	 ;  0 "" 2
2470:FreeRTOS/Source/queue.c **** 					return errQUEUE_BLOCKED;
 3002               	.LM435:
 3003               	/* #NOAPP */
 3004 0982 8CEF      		ldi r24,lo8(-4)
 3005               	.L220:
 3006               	/* epilogue start */
2471:FreeRTOS/Source/queue.c **** 				}
2472:FreeRTOS/Source/queue.c **** 				else
2473:FreeRTOS/Source/queue.c **** 				{
2474:FreeRTOS/Source/queue.c **** 					portENABLE_INTERRUPTS();
2475:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
2476:FreeRTOS/Source/queue.c **** 				}
2477:FreeRTOS/Source/queue.c **** 			}
2478:FreeRTOS/Source/queue.c **** 			else
2479:FreeRTOS/Source/queue.c **** 			{
2480:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2481:FreeRTOS/Source/queue.c **** 			}
2482:FreeRTOS/Source/queue.c **** 		}
2483:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
2484:FreeRTOS/Source/queue.c **** 
2485:FreeRTOS/Source/queue.c **** 		portDISABLE_INTERRUPTS();
2486:FreeRTOS/Source/queue.c **** 		{
2487:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2488:FreeRTOS/Source/queue.c **** 			{
2489:FreeRTOS/Source/queue.c **** 				/* Data is available from the queue. */
2490:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2491:FreeRTOS/Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2492:FreeRTOS/Source/queue.c **** 				{
2493:FreeRTOS/Source/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2494:FreeRTOS/Source/queue.c **** 				}
2495:FreeRTOS/Source/queue.c **** 				else
2496:FreeRTOS/Source/queue.c **** 				{
2497:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2498:FreeRTOS/Source/queue.c **** 				}
2499:FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2500:FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
2501:FreeRTOS/Source/queue.c **** 
2502:FreeRTOS/Source/queue.c **** 				xReturn = pdPASS;
2503:FreeRTOS/Source/queue.c **** 
2504:FreeRTOS/Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2505:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2506:FreeRTOS/Source/queue.c **** 				{
2507:FreeRTOS/Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2508:FreeRTOS/Source/queue.c **** 					into the ready list as we are within a critical section.
2509:FreeRTOS/Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2510:FreeRTOS/Source/queue.c **** 					the event were caused from within an interrupt. */
2511:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2512:FreeRTOS/Source/queue.c **** 					{
2513:FreeRTOS/Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2514:FreeRTOS/Source/queue.c **** 					}
2515:FreeRTOS/Source/queue.c **** 					else
2516:FreeRTOS/Source/queue.c **** 					{
2517:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2518:FreeRTOS/Source/queue.c **** 					}
2519:FreeRTOS/Source/queue.c **** 				}
2520:FreeRTOS/Source/queue.c **** 				else
2521:FreeRTOS/Source/queue.c **** 				{
2522:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2523:FreeRTOS/Source/queue.c **** 				}
2524:FreeRTOS/Source/queue.c **** 			}
2525:FreeRTOS/Source/queue.c **** 			else
2526:FreeRTOS/Source/queue.c **** 			{
2527:FreeRTOS/Source/queue.c **** 				xReturn = pdFAIL;
2528:FreeRTOS/Source/queue.c **** 			}
2529:FreeRTOS/Source/queue.c **** 		}
2530:FreeRTOS/Source/queue.c **** 		portENABLE_INTERRUPTS();
2531:FreeRTOS/Source/queue.c **** 
2532:FreeRTOS/Source/queue.c **** 		return xReturn;
2533:FreeRTOS/Source/queue.c **** 	}
 3008               	.LM436:
 3009 0984 DF91      		pop r29
 3010 0986 CF91      		pop r28
 3011 0988 0895      		ret
 3012               	.L222:
2474:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 3014               	.LM437:
 3015               	/* #APP */
 3016               	 ;  2474 "FreeRTOS/Source/queue.c" 1
 3017 098a 7894      		sei
 3018               	 ;  0 "" 2
2475:FreeRTOS/Source/queue.c **** 				}
 3020               	.LM438:
 3021               	/* #NOAPP */
 3022 098c 80E0      		ldi r24,0
 3023 098e 00C0      		rjmp .L220
 3024               	.L221:
2483:FreeRTOS/Source/queue.c **** 
 3026               	.LM439:
 3027               	/* #APP */
 3028               	 ;  2483 "FreeRTOS/Source/queue.c" 1
 3029 0990 7894      		sei
 3030               	 ;  0 "" 2
2485:FreeRTOS/Source/queue.c **** 		{
 3032               	.LM440:
 3033               	 ;  2485 "FreeRTOS/Source/queue.c" 1
 3034 0992 F894      		cli
 3035               	 ;  0 "" 2
2487:FreeRTOS/Source/queue.c **** 			{
 3037               	.LM441:
 3038               	/* #NOAPP */
 3039 0994 8A8D      		ldd r24,Y+26
2487:FreeRTOS/Source/queue.c **** 			{
 3041               	.LM442:
 3042 0996 8823      		tst r24
 3043 0998 01F0      		breq .L228
2490:FreeRTOS/Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 3045               	.LM443:
 3046 099a 4C8D      		ldd r20,Y+28
 3047 099c 50E0      		ldi r21,0
2490:FreeRTOS/Source/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 3049               	.LM444:
 3050 099e 8E81      		ldd r24,Y+6
 3051 09a0 9F81      		ldd r25,Y+7
 3052 09a2 840F      		add r24,r20
 3053 09a4 951F      		adc r25,r21
 3054 09a6 9F83      		std Y+7,r25
 3055 09a8 8E83      		std Y+6,r24
2491:FreeRTOS/Source/queue.c **** 				{
 3057               	.LM445:
 3058 09aa 6C81      		ldd r22,Y+4
 3059 09ac 7D81      		ldd r23,Y+5
 3060 09ae 8617      		cp r24,r22
 3061 09b0 9707      		cpc r25,r23
 3062 09b2 00F0      		brlo .L225
2493:FreeRTOS/Source/queue.c **** 				}
 3064               	.LM446:
 3065 09b4 8881      		ld r24,Y
 3066 09b6 9981      		ldd r25,Y+1
 3067 09b8 9F83      		std Y+7,r25
 3068 09ba 8E83      		std Y+6,r24
 3069               	.L225:
2499:FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
 3071               	.LM447:
 3072 09bc 8A8D      		ldd r24,Y+26
2499:FreeRTOS/Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
 3074               	.LM448:
 3075 09be 8150      		subi r24,lo8(-(-1))
 3076 09c0 8A8F      		std Y+26,r24
2500:FreeRTOS/Source/queue.c **** 
 3078               	.LM449:
 3079 09c2 6E81      		ldd r22,Y+6
 3080 09c4 7F81      		ldd r23,Y+7
 3081 09c6 C901      		movw r24,r18
 3082 09c8 0E94 0000 		call memcpy
2505:FreeRTOS/Source/queue.c **** 				{
 3084               	.LM450:
 3085 09cc 8885      		ldd r24,Y+8
2505:FreeRTOS/Source/queue.c **** 				{
 3087               	.LM451:
 3088 09ce 8111      		cpse r24,__zero_reg__
 3089 09d0 00C0      		rjmp .L226
 3090               	.L227:
2502:FreeRTOS/Source/queue.c **** 
 3092               	.LM452:
 3093 09d2 81E0      		ldi r24,lo8(1)
 3094               	.L224:
2530:FreeRTOS/Source/queue.c **** 
 3096               	.LM453:
 3097               	/* #APP */
 3098               	 ;  2530 "FreeRTOS/Source/queue.c" 1
 3099 09d4 7894      		sei
 3100               	 ;  0 "" 2
2532:FreeRTOS/Source/queue.c **** 	}
 3102               	.LM454:
 3103               	/* #NOAPP */
 3104 09d6 00C0      		rjmp .L220
 3105               	.L226:
2511:FreeRTOS/Source/queue.c **** 					{
 3107               	.LM455:
 3108 09d8 CE01      		movw r24,r28
 3109 09da 0896      		adiw r24,8
 3110 09dc 0E94 0000 		call xCoRoutineRemoveFromEventList
2511:FreeRTOS/Source/queue.c **** 					{
 3112               	.LM456:
 3113 09e0 8823      		tst r24
 3114 09e2 01F0      		breq .L227
2513:FreeRTOS/Source/queue.c **** 					}
 3116               	.LM457:
 3117 09e4 8BEF      		ldi r24,lo8(-5)
 3118 09e6 00C0      		rjmp .L224
 3119               	.L228:
2527:FreeRTOS/Source/queue.c **** 			}
 3121               	.LM458:
 3122 09e8 80E0      		ldi r24,0
 3123 09ea 00C0      		rjmp .L224
 3125               	.Lscope24:
 3131               	.global	xQueueCRSendFromISR
 3133               	xQueueCRSendFromISR:
2534:FreeRTOS/Source/queue.c **** 
2535:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2536:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2537:FreeRTOS/Source/queue.c **** 
2538:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2539:FreeRTOS/Source/queue.c **** 
2540:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2541:FreeRTOS/Source/queue.c **** 	{
 3135               	.LM459:
 3136               	.LFBB25:
 3137 09ec 1F93      		push r17
 3138 09ee CF93      		push r28
 3139 09f0 DF93      		push r29
 3140               	/* prologue: function */
 3141               	/* frame size = 0 */
 3142               	/* stack size = 3 */
 3143               	.L__stack_usage = 3
 3144 09f2 EC01      		movw r28,r24
 3145 09f4 142F      		mov r17,r20
2542:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2543:FreeRTOS/Source/queue.c **** 
2544:FreeRTOS/Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2545:FreeRTOS/Source/queue.c **** 		exit without doing anything. */
2546:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 3147               	.LM460:
 3148 09f6 9A8D      		ldd r25,Y+26
 3150               	.LM461:
 3151 09f8 8B8D      		ldd r24,Y+27
 3152 09fa 9817      		cp r25,r24
 3153 09fc 00F4      		brsh .L234
2547:FreeRTOS/Source/queue.c **** 		{
2548:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 3155               	.LM462:
 3156 09fe 40E0      		ldi r20,0
 3157 0a00 CE01      		movw r24,r28
 3158 0a02 0E94 0000 		call prvCopyDataToQueue
2549:FreeRTOS/Source/queue.c **** 
2550:FreeRTOS/Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2551:FreeRTOS/Source/queue.c **** 			co-routine has not already been woken. */
2552:FreeRTOS/Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
 3160               	.LM463:
 3161 0a06 1111      		cpse r17,__zero_reg__
 3162 0a08 00C0      		rjmp .L234
2553:FreeRTOS/Source/queue.c **** 			{
2554:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 3164               	.LM464:
 3165 0a0a 8989      		ldd r24,Y+17
 3167               	.LM465:
 3168 0a0c 8823      		tst r24
 3169 0a0e 01F0      		breq .L234
2555:FreeRTOS/Source/queue.c **** 				{
2556:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 3171               	.LM466:
 3172 0a10 CE01      		movw r24,r28
 3173 0a12 4196      		adiw r24,17
 3174 0a14 0E94 0000 		call xCoRoutineRemoveFromEventList
 3176               	.LM467:
 3177 0a18 11E0      		ldi r17,lo8(1)
 3178 0a1a 8111      		cpse r24,__zero_reg__
 3179 0a1c 00C0      		rjmp .L234
 3180 0a1e 10E0      		ldi r17,0
 3181               	.L234:
2557:FreeRTOS/Source/queue.c **** 					{
2558:FreeRTOS/Source/queue.c **** 						return pdTRUE;
2559:FreeRTOS/Source/queue.c **** 					}
2560:FreeRTOS/Source/queue.c **** 					else
2561:FreeRTOS/Source/queue.c **** 					{
2562:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2563:FreeRTOS/Source/queue.c **** 					}
2564:FreeRTOS/Source/queue.c **** 				}
2565:FreeRTOS/Source/queue.c **** 				else
2566:FreeRTOS/Source/queue.c **** 				{
2567:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2568:FreeRTOS/Source/queue.c **** 				}
2569:FreeRTOS/Source/queue.c **** 			}
2570:FreeRTOS/Source/queue.c **** 			else
2571:FreeRTOS/Source/queue.c **** 			{
2572:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2573:FreeRTOS/Source/queue.c **** 			}
2574:FreeRTOS/Source/queue.c **** 		}
2575:FreeRTOS/Source/queue.c **** 		else
2576:FreeRTOS/Source/queue.c **** 		{
2577:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2578:FreeRTOS/Source/queue.c **** 		}
2579:FreeRTOS/Source/queue.c **** 
2580:FreeRTOS/Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2581:FreeRTOS/Source/queue.c **** 	}
 3183               	.LM468:
 3184 0a20 812F      		mov r24,r17
 3185               	/* epilogue start */
 3186 0a22 DF91      		pop r29
 3187 0a24 CF91      		pop r28
 3188 0a26 1F91      		pop r17
 3189 0a28 0895      		ret
 3191               	.Lscope25:
 3197               	.global	xQueueCRReceiveFromISR
 3199               	xQueueCRReceiveFromISR:
2582:FreeRTOS/Source/queue.c **** 
2583:FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2584:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2585:FreeRTOS/Source/queue.c **** 
2586:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2587:FreeRTOS/Source/queue.c **** 
2588:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2589:FreeRTOS/Source/queue.c **** 	{
 3201               	.LM469:
 3202               	.LFBB26:
 3203 0a2a 0F93      		push r16
 3204 0a2c 1F93      		push r17
 3205 0a2e CF93      		push r28
 3206 0a30 DF93      		push r29
 3207               	/* prologue: function */
 3208               	/* frame size = 0 */
 3209               	/* stack size = 4 */
 3210               	.L__stack_usage = 4
 3211 0a32 EC01      		movw r28,r24
 3212 0a34 CB01      		movw r24,r22
 3213 0a36 8A01      		movw r16,r20
2590:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
2591:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = xQueue;
2592:FreeRTOS/Source/queue.c **** 
2593:FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2594:FreeRTOS/Source/queue.c **** 		not then just leave without doing anything. */
2595:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 3215               	.LM470:
 3216 0a38 2A8D      		ldd r18,Y+26
 3218               	.LM471:
 3219 0a3a 2223      		tst r18
 3220 0a3c 01F0      		breq .L245
2596:FreeRTOS/Source/queue.c **** 		{
2597:FreeRTOS/Source/queue.c **** 			/* Copy the data from the queue. */
2598:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 3222               	.LM472:
 3223 0a3e 4C8D      		ldd r20,Y+28
 3224 0a40 50E0      		ldi r21,0
 3226               	.LM473:
 3227 0a42 2E81      		ldd r18,Y+6
 3228 0a44 3F81      		ldd r19,Y+7
 3229 0a46 240F      		add r18,r20
 3230 0a48 351F      		adc r19,r21
 3231 0a4a 3F83      		std Y+7,r19
 3232 0a4c 2E83      		std Y+6,r18
2599:FreeRTOS/Source/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 3234               	.LM474:
 3235 0a4e 6C81      		ldd r22,Y+4
 3236 0a50 7D81      		ldd r23,Y+5
 3237 0a52 2617      		cp r18,r22
 3238 0a54 3707      		cpc r19,r23
 3239 0a56 00F0      		brlo .L242
2600:FreeRTOS/Source/queue.c **** 			{
2601:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 3241               	.LM475:
 3242 0a58 2881      		ld r18,Y
 3243 0a5a 3981      		ldd r19,Y+1
 3244 0a5c 3F83      		std Y+7,r19
 3245 0a5e 2E83      		std Y+6,r18
 3246               	.L242:
2602:FreeRTOS/Source/queue.c **** 			}
2603:FreeRTOS/Source/queue.c **** 			else
2604:FreeRTOS/Source/queue.c **** 			{
2605:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2606:FreeRTOS/Source/queue.c **** 			}
2607:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 3248               	.LM476:
 3249 0a60 2A8D      		ldd r18,Y+26
 3251               	.LM477:
 3252 0a62 2150      		subi r18,lo8(-(-1))
 3253 0a64 2A8F      		std Y+26,r18
2608:FreeRTOS/Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
 3255               	.LM478:
 3256 0a66 6E81      		ldd r22,Y+6
 3257 0a68 7F81      		ldd r23,Y+7
 3258 0a6a 0E94 0000 		call memcpy
2609:FreeRTOS/Source/queue.c **** 
2610:FreeRTOS/Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
 3260               	.LM479:
 3261 0a6e F801      		movw r30,r16
 3262 0a70 8081      		ld r24,Z
 3263 0a72 8823      		tst r24
 3264 0a74 01F0      		breq .L243
 3265               	.L244:
2611:FreeRTOS/Source/queue.c **** 			{
2612:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2613:FreeRTOS/Source/queue.c **** 				{
2614:FreeRTOS/Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2615:FreeRTOS/Source/queue.c **** 					{
2616:FreeRTOS/Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2617:FreeRTOS/Source/queue.c **** 					}
2618:FreeRTOS/Source/queue.c **** 					else
2619:FreeRTOS/Source/queue.c **** 					{
2620:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2621:FreeRTOS/Source/queue.c **** 					}
2622:FreeRTOS/Source/queue.c **** 				}
2623:FreeRTOS/Source/queue.c **** 				else
2624:FreeRTOS/Source/queue.c **** 				{
2625:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2626:FreeRTOS/Source/queue.c **** 				}
2627:FreeRTOS/Source/queue.c **** 			}
2628:FreeRTOS/Source/queue.c **** 			else
2629:FreeRTOS/Source/queue.c **** 			{
2630:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2631:FreeRTOS/Source/queue.c **** 			}
2632:FreeRTOS/Source/queue.c **** 
2633:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 3267               	.LM480:
 3268 0a76 81E0      		ldi r24,lo8(1)
 3269               	.L240:
 3270               	/* epilogue start */
2634:FreeRTOS/Source/queue.c **** 		}
2635:FreeRTOS/Source/queue.c **** 		else
2636:FreeRTOS/Source/queue.c **** 		{
2637:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
2638:FreeRTOS/Source/queue.c **** 		}
2639:FreeRTOS/Source/queue.c **** 
2640:FreeRTOS/Source/queue.c **** 		return xReturn;
2641:FreeRTOS/Source/queue.c **** 	}
 3272               	.LM481:
 3273 0a78 DF91      		pop r29
 3274 0a7a CF91      		pop r28
 3275 0a7c 1F91      		pop r17
 3276 0a7e 0F91      		pop r16
 3277 0a80 0895      		ret
 3278               	.L243:
2612:FreeRTOS/Source/queue.c **** 				{
 3280               	.LM482:
 3281 0a82 8885      		ldd r24,Y+8
2612:FreeRTOS/Source/queue.c **** 				{
 3283               	.LM483:
 3284 0a84 8823      		tst r24
 3285 0a86 01F0      		breq .L244
2614:FreeRTOS/Source/queue.c **** 					{
 3287               	.LM484:
 3288 0a88 CE01      		movw r24,r28
 3289 0a8a 0896      		adiw r24,8
 3290 0a8c 0E94 0000 		call xCoRoutineRemoveFromEventList
2614:FreeRTOS/Source/queue.c **** 					{
 3292               	.LM485:
 3293 0a90 8823      		tst r24
 3294 0a92 01F0      		breq .L244
2616:FreeRTOS/Source/queue.c **** 					}
 3296               	.LM486:
 3297 0a94 81E0      		ldi r24,lo8(1)
 3298 0a96 F801      		movw r30,r16
 3299 0a98 8083      		st Z,r24
 3300 0a9a 00C0      		rjmp .L240
 3301               	.L245:
2637:FreeRTOS/Source/queue.c **** 		}
 3303               	.LM487:
 3304 0a9c 80E0      		ldi r24,0
2640:FreeRTOS/Source/queue.c **** 	}
 3306               	.LM488:
 3307 0a9e 00C0      		rjmp .L240
 3312               	.Lscope26:
 3315               	.Letext0:
 3316               		.ident	"GCC: (SUSE Linux) 10.0.1 20200218 (experimental) [revision fa1160f6e50500aa38162fefb43bfb1
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccAqdCnO.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccAqdCnO.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccAqdCnO.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccAqdCnO.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccAqdCnO.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccAqdCnO.s:32     .text:0000000000000000 prvIsQueueEmpty
     /tmp/ccAqdCnO.s:86     .text:0000000000000016 prvCopyDataToQueue
     /tmp/ccAqdCnO.s:248    .text:00000000000000c6 prvCopyDataFromQueue
     /tmp/ccAqdCnO.s:306    .text:00000000000000fa prvUnlockQueue
     /tmp/ccAqdCnO.s:483    .text:0000000000000178 xQueueGenericReset
     /tmp/ccAqdCnO.s:623    .text:00000000000001f2 xQueueGenericCreate
     /tmp/ccAqdCnO.s:709    .text:0000000000000238 xQueueCreateCountingSemaphore
     /tmp/ccAqdCnO.s:751    .text:0000000000000250 xQueueGenericSend
     /tmp/ccAqdCnO.s:1067   .text:000000000000037a xQueueCreateMutex
     /tmp/ccAqdCnO.s:1132   .text:00000000000003ae xQueueGenericSendFromISR
     /tmp/ccAqdCnO.s:1252   .text:0000000000000410 xQueueGiveFromISR
     /tmp/ccAqdCnO.s:1369   .text:0000000000000458 xQueueReceive
     /tmp/ccAqdCnO.s:1674   .text:000000000000057a xQueueSemaphoreTake
     /tmp/ccAqdCnO.s:2089   .text:00000000000006fc xQueuePeek
     /tmp/ccAqdCnO.s:2396   .text:000000000000081e xQueueReceiveFromISR
     /tmp/ccAqdCnO.s:2522   .text:000000000000087e xQueuePeekFromISR
     /tmp/ccAqdCnO.s:2584   .text:00000000000008ac uxQueueMessagesWaiting
     /tmp/ccAqdCnO.s:2633   .text:00000000000008bc uxQueueSpacesAvailable
     /tmp/ccAqdCnO.s:2683   .text:00000000000008d0 uxQueueMessagesWaitingFromISR
     /tmp/ccAqdCnO.s:2709   .text:00000000000008d6 vQueueDelete
     /tmp/ccAqdCnO.s:2727   .text:00000000000008da xQueueIsQueueEmptyFromISR
     /tmp/ccAqdCnO.s:2756   .text:00000000000008e6 xQueueIsQueueFullFromISR
     /tmp/ccAqdCnO.s:2788   .text:00000000000008f4 xQueueCRSend
     /tmp/ccAqdCnO.s:2958   .text:0000000000000960 xQueueCRReceive
     /tmp/ccAqdCnO.s:3133   .text:00000000000009ec xQueueCRSendFromISR
     /tmp/ccAqdCnO.s:3199   .text:0000000000000a2a xQueueCRReceiveFromISR

UNDEFINED SYMBOLS
xTaskPriorityDisinherit
memcpy
xTaskRemoveFromEventList
vTaskMissedYield
vPortYield
vListInitialise
pvPortMalloc
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
vCoRoutineAddToDelayedList
xCoRoutineRemoveFromEventList
